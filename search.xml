<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Effective Java - 创建和销毁对象</title>
    <url>/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h2><p>当我们的类的一些属性是必须的，有些属性是可选的，参数较多的情况下我们可以适当考虑使用构建器，其实在 Java 开发中我们也经常遇到这种通过构建器来创建类实例的情况，然后再结合链式调用写出来的代码还是比较美观的。下面结合一个简单的例子来说明：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String phone;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可选参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer sex;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可选参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String birthday;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可选参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String[] hobby;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String username;</span><br><span class="line">        private String password;</span><br><span class="line">        private String phone;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private Integer sex &#x3D; 1;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private String birthday &#x3D; &quot;0-0-0-0&quot;;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private String[] hobby &#x3D; new String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        public Builder(String username, String password, String phone) &#123;</span><br><span class="line">            this.username &#x3D; username;</span><br><span class="line">            this.password &#x3D; password;</span><br><span class="line">            this.phone &#x3D; phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder sex(Integer sex) &#123;</span><br><span class="line">            sex &#x3D; sex;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder birthday(String birthday) &#123;</span><br><span class="line">            birthday &#x3D; birthday;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder hobby(String[] hobby) &#123;</span><br><span class="line">            hobby &#x3D; hobby;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public User build() &#123;</span><br><span class="line">            return new User(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private User(Builder builder) &#123;</span><br><span class="line">        username &#x3D; builder.username;</span><br><span class="line">        password &#x3D; builder.password;</span><br><span class="line">        phone &#x3D; builder.phone;</span><br><span class="line">        sex &#x3D; builder.sex;</span><br><span class="line">        birthday &#x3D; builder.birthday;</span><br><span class="line">        hobby &#x3D; builder.hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, password&#x3D;&#39;&quot; + password + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, phone&#x3D;&#39;&quot; + phone + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, sex&#x3D;&quot; + sex +</span><br><span class="line">                &quot;, birthday&#x3D;&#39;&quot; + birthday + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, hobby&#x3D;&quot; + Arrays.toString(hobby) +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>User 对象的创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user &#x3D; new User.Builder(&quot;admin&quot;, &quot;123456&quot;, &quot;13999999999&quot;).sex(0).build();</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这里只是一个简单的小例子，开发中一般不会用这种方式来创建实体类，可能还是需要看个人开发时具体情况决定是否采用这种方式，这里只对这种创建方式做一个简单的介绍。</p>
<h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>一般来说，最好能重用对象而不是在每次需要时都去频繁的创建，重用的方式快，而且能够避免频繁创建浪费资源。像下面这种情况就推荐重用对象,可以对比以下两种方式的差别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.TimeZone;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 不推荐这样做</span><br><span class="line"> *</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Person1 &#123;</span><br><span class="line"></span><br><span class="line">    private final Date birthDate &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">    public boolean isBabyBoomer() &#123;</span><br><span class="line">        Calendar calendar &#x3D; Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class="line">        calendar.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        Date boomStart &#x3D; calendar.getTime();</span><br><span class="line">        calendar.set(1965, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        Date boomEnd &#x3D; calendar.getTime();</span><br><span class="line">        return birthDate.compareTo(boomStart) &gt;&#x3D; 0 &amp;&amp; birthDate.compareTo(boomEnd) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.TimeZone;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 推荐这样做</span><br><span class="line"> *</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Person2 &#123;</span><br><span class="line"></span><br><span class="line">    private final Date birthDate &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">    private static final Date BOOM_START;</span><br><span class="line">    private static final Date BOOM_END;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Calendar calendar &#x3D; Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class="line">        calendar.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        BOOM_START &#x3D; calendar.getTime();</span><br><span class="line">        calendar.set(1965, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        BOOM_END &#x3D; calendar.getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isBabyBoomer() &#123;</span><br><span class="line">        return birthDate.compareTo(BOOM_START) &gt;&#x3D; 0 &amp;&amp; birthDate.compareTo(BOOM_END) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><p>我们在日常开发中可能稍有不慎就会遇到内存泄漏的问题，这需要我们从细节去防止这种情况的发生，一般而言，只要类是自己管理内存，就应该警惕内存泄漏的问题。下面展示一种可能会发生内存泄漏的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Stack &#123;</span><br><span class="line"></span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements &#x3D; new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object object) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop1() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop2() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object result &#x3D; elements[--size];</span><br><span class="line">        &#x2F;*</span><br><span class="line">        将弹出的值赋空，以便 jvm 回收，如果不赋空将不会被 jvm 回收，因为栈内部依然维护着这些对象的过期引用。</span><br><span class="line">        过期引用是指永远不会被解除的引用，在这里就是指在 elements 数组活动之外的引用，即元素下标小于 size 的那些元素。</span><br><span class="line">        所以一旦数组元素变成了非活动部分的一部分就应该手动清空这些数组元素。</span><br><span class="line">        *&#x2F;</span><br><span class="line">        elements[size] &#x3D; null;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length &#x3D;&#x3D; size) &#123;</span><br><span class="line">            elements &#x3D; Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个随着栈的不断的弹栈和压栈，每次弹出如果不清空该引用，随着量的增加就可能造成内存泄漏的情况。</p>
]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 特性--Lambda 表达式、接口默认方法以及方法引用</title>
    <url>/Java-8-%E7%89%B9%E6%80%A7-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本，Java 8 增加了许多的新特性，在此先记录一下 Lambda 表达式，接口默认方法和方法引用这三个特性。</p>
<a id="more"></a>

<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 表达式，也可称为闭包，允许把函数作为一个方法的参数（函数作为参数传递进方法中），使用 Lambda 表达式可以使代码变的更加简洁紧凑。<br>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression  或  (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<p>主要特征：</p>
<ul>
<li>可选类型声明，不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号，一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号，如果主体只包含一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字，如果主体只有一个表达式返回值则编译器会自动返回值，大括号的话需要指明表达式返回了一个数值。</li>
</ul>
<p>下面通过一些小例子来展示，首先先定义两个函数式接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface MathOperation &#123;</span><br><span class="line">    int operate(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Greeting &#123;</span><br><span class="line">    void sayMessage(String greeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个测试类，通过 main 方法来进行测试，代码中有详细注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Java8 java8 &#x3D; new Java8();</span><br><span class="line">    &#x2F;&#x2F;参数类型可声明可不声明</span><br><span class="line">    MathOperation addition &#x3D; (int a, int b) -&gt; a + b;</span><br><span class="line">    MathOperation subtraction &#x3D; (a, b) -&gt; a - b;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;可选的参数圆括号</span><br><span class="line">    Greeting greeting &#x3D; message -&gt; System.out.println(&quot;hello &quot; + message);</span><br><span class="line">    Greeting greeting1 &#x3D; (message) -&gt; System.out.println(&quot;hello &quot; + message);</span><br><span class="line">    greeting.sayMessage(&quot;Tom&quot;);</span><br><span class="line">    greeting1.sayMessage(&quot;Jim&quot;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;可选的大括号以及可选的返回关键字，当有大括号时返回值需指定 return 语句</span><br><span class="line">    MathOperation multiplication &#x3D; (int a, int b) -&gt; &#123;</span><br><span class="line">        return a * b;</span><br><span class="line">    &#125;;</span><br><span class="line">    MathOperation division &#x3D; (a, b) -&gt; a &#x2F; b;</span><br><span class="line">    &#x2F;&#x2F;测试执行输出，将上面定义的函数传进 operate 方法中</span><br><span class="line">    System.out.println(java8.operate(1, 2, addition));</span><br><span class="line">    &#x2F;&#x2F;上面的另一种写法</span><br><span class="line">    System.out.println(addition.operate(1, 2));</span><br><span class="line">    </span><br><span class="line">    System.out.println(java8.operate(1, 2, subtraction));</span><br><span class="line">    System.out.println(java8.operate(1, 2, multiplication));</span><br><span class="line">    System.out.println(java8.operate(1, 2, division));</span><br><span class="line">    System.out.println(java8.operate(1,2, (a, b) -&gt; a + b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">    return mathOperation.operate(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h2><p>默认方法就是接口可以有实现方法，而且不需要实现类去实现这个默认方法，定义时我们只需在方法名前面加个 default 关键字即可实现默认方法。</p>
<p>至于为什么会产生这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是当需要修改接口时候，需要修改它的全部实现类，目前 java 8之前的集合框架没有 foreach 方法，通常能想到的解决办法是在 JDK 里给相关的接口添加新的方法定义及给相应实现类添加实现，然而对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现，所以才引进的默认方法。目的就是为了解决接口的修改与现有的实现不兼容的问题。</p>
<p>下面是接口默认方法和接口静态默认方法的基本实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Action1 &#123;</span><br><span class="line">    &#x2F;&#x2F;默认方法</span><br><span class="line">    default void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃东西1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;静态默认方法</span><br><span class="line">    static void fun() &#123;</span><br><span class="line">        System.out.println(&quot;玩&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Action2 &#123;</span><br><span class="line">    default void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃东西2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里接口 Action1 和 Action2 都有 eat 这个相同的默认方法，当一个实现类同时实现了这个两个接口时就需要实现类显式的覆盖两个接口中相同的 eat 方法，至于实现类中如何重写 eat 方法取决于实现类，实现类既可以完完全全由自己重写，也可以使用 super 来调用两个接口中的 eat 方法。上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat implements Action1, Action2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action1.super.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*@Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action2.super.eat();</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*@Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action1.super.eat();</span><br><span class="line">        Action2.super.eat();</span><br><span class="line">        Action1.fun();</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用通过方法的名字来指向一个方法，方法引用可以使语言的构造更紧凑简洁，减少冗余代码，方法引用使用一对冒号 :: 表示。当要传递给Lambda体内的操作已经有实现的方法了，就可以使用方法引用了。</p>
<p>先定义一个函数式接口和一个测试类以及类中的一些方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Say&lt;T&gt; &#123;</span><br><span class="line">    void accept(T t1, T t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private String name &#x3D; &quot;default&quot;;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Student create(Supplier&lt;Student&gt; studentSupplier) &#123;</span><br><span class="line">        return studentSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String study() &#123;</span><br><span class="line">        System.out.println(&quot;study&quot;);</span><br><span class="line">        return &quot;knowledge&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String fun() &#123;</span><br><span class="line">        System.out.println( &quot;fun&quot;);</span><br><span class="line">        return &quot;fun&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ask() &#123;</span><br><span class="line">        System.out.println(this.getName() + &quot; ask&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void say(Student student) &#123;</span><br><span class="line">        System.out.println(this.getName() + &quot; say to&quot; + student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;set get 方法已省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 main 方法测试方法引用的具体使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</span><br><span class="line">    Student student &#x3D; Student.create(Student :: new );</span><br><span class="line">    Student student1 &#x3D; Student.create(() -&gt; new Student(&quot;小红&quot;));</span><br><span class="line">    Student student2 &#x3D; Student.create(() -&gt; new Student(&quot;小绿&quot;));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;静态方法引用：它的语法是Class::static_method</span><br><span class="line">    Supplier&lt;String&gt; supplier1 &#x3D; Student :: study;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;特定类的任意对象的方法引用：它的语法是Class::method</span><br><span class="line">    Consumer&lt;Student&gt; consumer &#x3D; Student :: ask;</span><br><span class="line">    &#x2F;&#x2F;下面 student 参数是 ask 方法的调用者</span><br><span class="line">    consumer.accept(student);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;特定类的任意对象的方法引用：它的语法是Class::method</span><br><span class="line">    Say&lt;Student&gt; say &#x3D; Student :: say;</span><br><span class="line">    &#x2F;&#x2F;下面 student1 参数是 say 方法的调用者，student2 参数是 say 方法的参数</span><br><span class="line">    say.accept(student1, student2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;特定对象的方法引用：它的语法是instance::method</span><br><span class="line">    supplier1 &#x3D; student :: fun;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面静态方法引用和特定类的任意对象的方法引用的区别，前者是一个静态方法，可通过类访问，后者则是参数列表的第一个参数是实例方法的调用者，第二个参数(或无参)是实例方法的参数时才会采取这种语法。</p>
<p>在使用方法引用时一定注意：</p>
<ol>
<li>方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表完全一致。</li>
<li>方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值完全一致</li>
</ol>
]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 特性--Optional 类、时间 API 以及 Base64 编解码</title>
    <url>/Java-8-%E7%89%B9%E6%80%A7-Optional-%E7%B1%BB%E3%80%81%E6%97%B6%E9%97%B4-API-%E4%BB%A5%E5%8F%8A-Base64-%E7%BC%96%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><p>Optional 类是一个可以为 null 的容器对象，可以保存类型 T 的值，或者仅仅保存 null，它提供很多有用的方法，让我们不用再显式的进行空值检测，Optional 类的引入很好的避免了发生空指针异常，下面我们看一个简单的例子：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer value1 &#x3D; null;</span><br><span class="line">Integer value2 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">Optional&lt;Integer&gt; optional1 &#x3D; Optional.ofNullable(value1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">Optional&lt;Integer&gt; optional2 &#x3D; Optional.of(value2);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;第一个参数值是否存在: &quot; + optional1.isPresent());</span><br><span class="line">System.out.println(&quot;第二个参数值是否存在: &quot; + optional2.isPresent());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">Integer result1 &#x3D; optional1.orElse(0);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Optional.get - 获取值，值需要存在</span><br><span class="line">Integer result2 &#x3D; optional2.orElse(0);</span><br><span class="line">System.out.println(result2);</span><br></pre></td></tr></table></figure>

<h2 id="Java-8-日期时间-API"><a href="#Java-8-日期时间-API" class="headerlink" title="Java 8 日期时间 API"></a>Java 8 日期时间 API</h2><p>在 Java 8 以前，我们都知道 Java 中的时间处理很繁琐，有时候还会去纠结我到底是用 java.util 包下的日期还是 java.sql 包下的日期呢。因此往往在遇到时间处理问题时都会借助于框架来实现，比如 Joda-Time。但在 Java 8 中也增加了同样的类似框架功能的时间处理 API，下面列出一些简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Clock 类使用时区来返回当前的毫秒数和日期。Clock 可以替代System.currentTimeMillis() 和 TimeZone.getDefault()。</span><br><span class="line"> </span><br><span class="line">Clock clock &#x3D; Clock.systemUTC();</span><br><span class="line">System.out.println(clock.millis());</span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前日期</span><br><span class="line">LocalDate currentDate &#x3D; LocalDate.now();</span><br><span class="line">System.out.println(&quot;当前日期: &quot; + currentDate);</span><br><span class="line">&#x2F;&#x2F; 获取当前时间</span><br><span class="line">LocalTime currentTime &#x3D; LocalTime.now();</span><br><span class="line">System.out.println(&quot;当前时间: &quot; + currentTime);</span><br><span class="line">&#x2F;&#x2F; 获取当前日期时间</span><br><span class="line">LocalDateTime currentDateTime &#x3D; LocalDateTime.now();</span><br><span class="line">System.out.println(&quot;当前日期时间: &quot; + currentDateTime);</span><br><span class="line">&#x2F;&#x2F; 根据当前日期时间获取当前日期</span><br><span class="line">LocalDate currentDate1 &#x3D; currentDateTime.toLocalDate();</span><br><span class="line">System.out.println(&quot;currentDate1: &quot; + currentDate1);</span><br><span class="line">&#x2F;&#x2F; 根据当前日期时间获取当前时间</span><br><span class="line">LocalTime currentTime1 &#x3D; currentDateTime.toLocalTime();</span><br><span class="line">System.out.println(&quot;currentTime1: &quot; + currentTime1);</span><br><span class="line"></span><br><span class="line">Month month &#x3D; currentDateTime.getMonth();</span><br><span class="line">int day &#x3D; currentDateTime.getDayOfMonth();</span><br><span class="line">int seconds &#x3D; currentDateTime.getSecond();</span><br><span class="line">System.out.println(&quot;月: &quot; + month +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定日期</span><br><span class="line">LocalDateTime date2 &#x3D; currentDateTime.withDayOfMonth(10).withYear(2012);</span><br><span class="line">System.out.println(&quot;date2: &quot; + date2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 12 december 2014</span><br><span class="line">LocalDate date3 &#x3D; LocalDate.of(2014, Month.DECEMBER, 12);</span><br><span class="line">System.out.println(&quot;date3: &quot; + date3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 22 小时 15 分钟</span><br><span class="line">LocalTime date4 &#x3D; LocalTime.of(22, 15);</span><br><span class="line">System.out.println(&quot;date4: &quot; + date4);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解析字符串</span><br><span class="line">LocalTime date5 &#x3D; LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">System.out.println(&quot;date5: &quot; + date5);</span><br><span class="line">&#x2F;&#x2F; 获取当前日期时间的另一个时区的日期时间</span><br><span class="line"></span><br><span class="line">System.out.println(currentDateTime.atZone(ZoneId.of(&quot;America&#x2F;New_York&quot;)));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime from &#x3D; LocalDateTime.of( 2017, Month.MAY, 16, 0, 0, 0 );</span><br><span class="line">LocalDateTime to &#x3D; LocalDateTime.of( 2018, Month.MAY, 16, 23, 59, 59 );</span><br><span class="line">Duration duration &#x3D; Duration.between( from, to );</span><br><span class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</span><br><span class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours());</span><br></pre></td></tr></table></figure>
<p>上面只是列举了一些简单的东西，其实还有一些，比如时间的加减运算，这些在用到时可以根据提示来进行我们想要的操作。</p>
<h2 id="Java8-Base64"><a href="#Java8-Base64" class="headerlink" title="Java8 Base64"></a>Java8 Base64</h2><p>Java 8 内置了 Base64 编码的编码器和解码器，并且 Base64 工具类提供了一套静态方法获取下面三种 BASE64 编解码器：</p>
<ul>
<li>基本：输出被映射到一组字符 A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持 A-Za-z0-9+/。</li>
<li>URL：输出映射到一组字符A-Za-z0-9+_，输出是 URL 和文件。</li>
<li>MIME：输出映射到 MIME 友好格式，输出每行不超过 76 字符，并且使用 ‘\r’ 并跟随 ‘\n’ 作为分割，编码输出最后没有行分割。</li>
</ul>
<p>下面也是一个简单的例子展示了如何获取这三种编解码器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本编码</span><br><span class="line">String base64encodedString &#x3D; Base64.getEncoder().encodeToString(&quot;java 8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line">&#x2F;&#x2F; 基本解码</span><br><span class="line">byte[] base64decodedBytes &#x3D; Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; URL 编码</span><br><span class="line">base64encodedString &#x3D; Base64.getUrlEncoder().encodeToString(&quot;url?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line">&#x2F;&#x2F; URL 解码</span><br><span class="line">byte[] base64decodedBytesUrl &#x3D; Base64.getUrlDecoder().decode(base64encodedString);</span><br><span class="line">System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytesUrl, &quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line">byte[] mimeBytes &#x3D; stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">&#x2F;&#x2F; MINE 编码</span><br><span class="line">String mimeEncodedString &#x3D; Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 特性--Stream 流</title>
    <url>/Java-8-%E7%89%B9%E6%80%A7-Stream-%E6%B5%81/</url>
    <content><![CDATA[<p>Java 8 API 添加了一个新的抽象称为流 Stream，可以让你以一种声明的方式处理数据，Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API 可以极大提高 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation) 得到前面处理的结果。</p>
<a id="more"></a>

<h2 id="Stream-的定义"><a href="#Stream-的定义" class="headerlink" title="Stream 的定义"></a>Stream 的定义</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作，元素是特定类型的对象，形成一个队列。 Java 中的 Stream 并不会存储元素，而是按需计算。</p>
<ul>
<li>数据源：流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作：类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的 Collection 操作不同， Stream 操作还有两个基础的特征：</p>
<ul>
<li>Pipelining: 中间操作都会返回流对象本身。这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行 (laziness) 和短路 (short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过 Iterator 或者 For-Each 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式 (Visitor) 实现。</li>
</ul>
<p>在 Java 8 中，集合接口有两个方法生成流：</p>
<ul>
<li>stream() − 为集合创建串行流。</li>
<li>parallelStream() − 为集合创建并行流。</li>
</ul>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计空字符串数量</span><br><span class="line">long count &#x3D; strings.stream().filter(String::isEmpty).count();</span><br><span class="line">System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">&#x2F;&#x2F; 流并行处理</span><br><span class="line">count &#x3D; strings.parallelStream().filter(String::isEmpty).count();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将字符串不为空的筛选出来并且以逗号分隔合并起来</span><br><span class="line">String mergedString &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure>

<h2 id="map-映射"><a href="#map-映射" class="headerlink" title="map 映射"></a>map 映射</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">&#x2F;&#x2F; 求各元素的平方</span><br><span class="line">List&lt;Integer&gt; squaresList &#x3D; numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;Squares List: &quot; + squaresList);</span><br></pre></td></tr></table></figure>

<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19);</span><br><span class="line">IntSummaryStatistics stats &#x3D; integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据景区等级分组</span><br><span class="line">List&lt;Scenic&gt; scenicList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">scenicList.add(new Scenic(1L, &quot;西湖&quot;, 5));</span><br><span class="line">scenicList.add(new Scenic(2L, &quot;千岛湖&quot;, 5));</span><br><span class="line">scenicList.add(new Scenic(3L, &quot;乌镇&quot;, 4));</span><br><span class="line">scenicList.add(new Scenic(4L, &quot;雷峰塔&quot;, 3));</span><br><span class="line">scenicList.add(new Scenic(4L, &quot;灵隐寺&quot;, 4));</span><br><span class="line">Map&lt;Integer, List&lt;Scenic&gt;&gt; mapGroup &#x3D; scenicList.stream().collect(Collectors.groupingBy(Scenic::getScenicLevel));</span><br><span class="line">System.out.println(mapGroup);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="转成-Map"><a href="#转成-Map" class="headerlink" title="转成 Map"></a>转成 Map</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* toMap 如果集合对象有重复的key，会报错Duplicate key ....</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F;Map&lt;Long, Scenic&gt; scenicMap &#x3D; scenicList.stream().collect(Collectors.toMap(Scenic::getId, a -&gt; a));</span><br><span class="line">&#x2F;&#x2F;System.out.println(scenicMap);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以用 (k1,k2)-&gt;k1 来设置，如果有重复的 key,则保留 key1,舍弃 key2</span><br><span class="line">Map&lt;Long, Scenic&gt; scenicMap &#x3D; scenicList.stream().collect(Collectors.toMap(Scenic::getId, a -&gt; a, (k1, k2) -&gt; k1));</span><br><span class="line">System.out.println(scenicMap);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="reduce-sum-求和"><a href="#reduce-sum-求和" class="headerlink" title="reduce sum 求和"></a>reduce sum 求和</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">&#x2F;&#x2F; 没有起始值时返回为Optional类型</span><br><span class="line">Optional&lt;Integer&gt; sumOptional &#x3D; integers.stream().reduce(Integer::sum);</span><br><span class="line">System.out.println(sumOptional.get());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以给一个起始种子值</span><br><span class="line">Integer sumReduce &#x3D; integers.stream().reduce(0, Integer::sum);</span><br><span class="line">System.out.println(sumReduce);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;直接用sum方法</span><br><span class="line">Integer sum &#x3D; integers.stream().mapToInt(i -&gt; i).sum();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<h2 id="根据某个属性求平均数"><a href="#根据某个属性求平均数" class="headerlink" title="根据某个属性求平均数"></a>根据某个属性求平均数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 等级平均数</span><br><span class="line">OptionalDouble average &#x3D; scenicList.stream().mapToInt(Scenic :: getScenicLevel).average();</span><br><span class="line">System.out.println(average.getAsDouble());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
  </entry>
  <entry>
    <title>Java 面试系列——基础篇(一)</title>
    <url>/Java-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="面向对象的特征：封装、继承、多态、抽象"><a href="#面向对象的特征：封装、继承、多态、抽象" class="headerlink" title="面向对象的特征：封装、继承、多态、抽象"></a>面向对象的特征：封装、继承、多态、抽象</h2><p>封装给对象提供了隐藏内部特性和行为的能力，对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 4 种访问权限，对应有三个修饰符 : public、private 、protected，每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。下面列出了使用封装的一些好处:</p>
<a id="more"></a>
<ul>
<li>通过隐藏对象的属性来保护对象内部的状态</li>
<li>提高了代码的可用性和可维护性,因为对象的行为可以被单独的改变或者是扩展</li>
<li>禁止对象之间的不良交互提高模块化</li>
</ul>
<p>继承给对象提供了从基类获取字段和方法的能力、继承提供了代码的重用行、在不修改类的情况下给现存的类添加新特性。</p>
<p>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力，一个多态类型上的操作可以应用到其他类型的值上面。</p>
<p>抽象是把想法从具体的实例中分离出来的步骤,因此,要根据他们的功能而不是实现细节来创建类，Java 支持创建只暴漏接口而不包含方法实现的抽象的类，这种抽象技术的主要目的是把类的行为和实现细节分离开。</p>
<p>** 备注: 抽象和封装是互补的概念。一方面,抽象关注对象的行为。另一方面,封装关注对象行为的 细节。一般是通过隐藏对象内部状态信息做到封装,因此,封装可以看成是用来提供抽象的一种策略。**</p>
<h2 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h2><p>final : 修饰符(关键字)，如果一个类被声明为 final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract 的,又被声明为 final 的。将变量或方法声明为 final,可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值,而在以后的引用中只能读取,不可修改。被声明为 final 的方法也同样只能使用,不能重载。</p>
<p>finally : 在异常处理时提供 finally 块来执行资源释放操作，如果抛出一个异常，那么相匹配的 catch 子句就会执行,然后就会进入 finally 块(如果有的话)。</p>
<p>finalize : 方法名，Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作，这个方法是由垃圾收集器在确定这个对象没有被引用时在释放对象占用的内存之前会调用该方法，它是在 Object 类中定义的，因此所有的类都继承了它，子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。</p>
<h2 id="Exception、Error、运行时异常与一般异常有何异同"><a href="#Exception、Error、运行时异常与一般异常有何异同" class="headerlink" title="Exception、Error、运行时异常与一般异常有何异同"></a>Exception、Error、运行时异常与一般异常有何异同</h2><p>error 表示程序运行出错了，它是一种比较严重的问题，比如说内存溢出，不可能指望程序能处理这样的情况。</p>
<p>exception 表示程序运行过程中可能会出现的异常情况，如果程序运行正常的话不会发生的情况。</p>
<p>异常表示程序运行过程中可能出现的非正常状态。运行时异常表示虚拟机的通常操作中可能遇到的异常,是一种常见运行错误，比如说 NullPointerException、IndexOutOfBoundsException、NumberFormatException、ClassCastException、IllegalArgumentException，这类异常的话 Java 虚拟机并不要求声明抛出或者捕获。而对于一般异常 Java 编译器要求方法必须声明抛出或者捕获，常见的这类异常有IOException、SQLException、InternetedException。</p>
<h2 id="int-和-Integer-有什么区别，Integer-的值缓存范围"><a href="#int-和-Integer-有什么区别，Integer-的值缓存范围" class="headerlink" title="int 和 Integer 有什么区别，Integer 的值缓存范围"></a>int 和 Integer 有什么区别，Integer 的值缓存范围</h2><p>Java 中有八种基本数据类型，int 就是其中一种，而每一种基本数据类型都有其对应的包装类型，两者之间的转换也称为自动装箱和自动拆箱。</p>
<p>对于 Integer 的值 Java 会进行缓存，值在 -128 - 127 之间的数字会进行缓存。</p>
<h2 id="String、StringBuilder、StringBuffer-的理解"><a href="#String、StringBuilder、StringBuffer-的理解" class="headerlink" title="String、StringBuilder、StringBuffer 的理解"></a>String、StringBuilder、StringBuffer 的理解</h2><p>首先 String 字符串常量，被 final 所修饰，不可被继承，StringBuilder 字符串变量，非线程安全，StringBuffer 字符串变量，线程安全，由于 String 是字符串常量，不可变，当涉及到字符串的拼接时会频繁的创建对象，所以这时需要使用 StringBuilder 和 StringBuffer 这两个类了，当然如果没有涉及到多线程的话尽量使用 StringBuilder ，它比 StringBuffer 这个类处理速度要快，当然如果涉及到多线程的话就只能使用 StringBuffer 类了。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>方法的重写 Overriding 是父类与子类之间多态性的一种表现，如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写，子类重写的方法访问修饰符的限制一定要大于被重写方法的访问修饰符 (public&gt;protected&gt;default&gt;private)，重写方法一定不能抛出新的检查异常或者比被重写方法声明更加宽泛的检查型异常。</p>
<p>重载 Overloading 是一个类中多态性的一种体现，子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们有不同的参数个数或者有不同的参数类型，则称为方法的重载 Overloading，Overloaded 的方法是可以改变返回值的类型，也可以有不同的访问修饰符，还可以抛出不同的异常。</p>
<h2 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h2><p>抽象类是对根源的抽象，它表示的是这个对象是什么。同时抽象类中可以没有抽象方法，抽象类中的变量可以任意定义，对于抽象方法是要被实现的，所以不能是静态的也不能是私有的，</p>
<p>接口是对动作的抽象，接口表示的是这个对象能做什么。对于接口中的抽象方法默认是都是公开的，接口里定义的变量只能是公共的静态的常量，接口中一般只做方法的声明，不过在 Java 8 中可以有具体的实现，一种是由 static 修饰，另一种使用 default关键字修饰，对于 static 修饰的由接口名称直接调用，而对于 default 修饰的方法则需要对应的实现类去调用，如果一个类实现了多个接口，而且这些接口中都有相同的默认方法时，此时必须重写掉默认方法，否则编译失败。</p>
<h2 id="反射的用途及实现"><a href="#反射的用途及实现" class="headerlink" title="反射的用途及实现"></a>反射的用途及实现</h2><p>当程序运行时，允许动态的改变程序结构或变量类型，通过反射我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。由于在运行时才动态加载的类或调用方法或属性，所以不需要事先（写代码的时候或编译期）知道运行对象是谁。<br>当我们在使用 IDE 时，当我们输入一个对象名或者类名并想调用它的属性和方法时，一按 (“.”) 点号，编译器就会自动列出它的属性和方法，这里就会用到反射。</p>
<p>反射最重要的用途就是开发各种通用框架，很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p>
<ul>
<li><p>先获得一个类的 Class 对象 :<br>  Class<?> klass = Class.forName(class 全类名);
Class<?> klass = 对象.class; 或者 Class<?> klass = 对象.getClass();
又或者 Class<?> klass = 类名.TYPE;</p>
</li>
<li><p>再通过拿到的 Class 对象创建实例 :<br>  Object str = klass.getInstance(); 或者<br>  Constructor constructor = klass.getConstructor(String.class);<br>//根据构造器创建实例<br>Object obj = constructor.newInstance(“23333”);</p>
</li>
</ul>
<h2 id="HTTP请求的-GET-与-POST-方式的区别"><a href="#HTTP请求的-GET-与-POST-方式的区别" class="headerlink" title="HTTP请求的 GET 与 POST 方式的区别"></a>HTTP请求的 GET 与 POST 方式的区别</h2><ul>
<li>GET 方式会将请求的参数拼接在 URL 后面，会显示在地址栏中，而 POST 方式则是         放在请求体中</li>
<li>GET方式提交的数据最多只能有 1024 字节，POST 方式没有限制</li>
<li>HTTP 请求默认是 GET 方式，对于敏感的数据类型最好采用 POST 方式提交请求。</li>
</ul>
<h2 id="Session与Cookie区别"><a href="#Session与Cookie区别" class="headerlink" title="Session与Cookie区别"></a>Session与Cookie区别</h2><ul>
<li>Cookie 和 Session 都是会话技术，Cookie 是运行在客户端，Session 是运行在服务器端，通过生成的 sessionId 来区分不同的客户，同时将 sessionId 的值通过 Cookie 返回给客户端。</li>
<li>Cookie 有大小限制以及浏览器在存 Cookie 的个数也有限制，Session 是没有大小限制的，和服务器的内存大小有关。</li>
<li>Cookie 有安全隐患，通过拦截或本地文件找得到你的 Cookie 后可以进行攻击。</li>
<li>Session 是保存在服务器端会存在一段时间才会消失，如果 Session 过多会增加服务器的压力。</li>
</ul>
]]></content>
      <categories>
        <category>面试系列</category>
      </categories>
  </entry>
  <entry>
    <title>Java 面试系列——基础篇(二)</title>
    <url>/Java-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="Java-中-equals-与-的区别"><a href="#Java-中-equals-与-的区别" class="headerlink" title="Java 中 equals 与 == 的区别"></a>Java 中 equals 与 == 的区别</h2><p>通俗的来说，“==” 比较的是地址，equals 比较的是内容。也就是说前者比较的是对象(堆)在(栈)内存中存放的内存地址，用来判断两个对象的地址是否相同，即是否是指向同一个对象。后者用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object 类的，所以适用于所有对象，注意如果没有对该方法进行重写的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是内存地址比较的结果，方法内容如下 ：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashCode-和-equals-方法的区别与联系"><a href="#hashCode-和-equals-方法的区别与联系" class="headerlink" title="hashCode 和 equals 方法的区别与联系"></a>hashCode 和 equals 方法的区别与联系</h2><p>hashCode 和 equals 方法都是 Object 中的方法，其中 hashCode 方法是 Native 修饰，该方法是计算出对象实例的哈希码，又称哈希函数，计算方式依赖于对象实例的内存地址，所以一般来说，每个对象实例的哈希码都是唯一的，当然如果对该方法进行重写了，结果也就不一样了。而 equals 方法一般是用来比较两个对象实例的值是否相等，当然如果没有对该方法进行重写，比较的就是两个对象的地址是否相等。</p>
<p>他们之间的联系就是当两个对象的 equals 相等那么 hashCode 一定相等，hashCode 不等那么equals 一定不等。反之 hashCode 相等，equals 不一定相等，因为哈希散列值有冲突的时候，当然好的哈希算法冲突的几率比较小。</p>
<p>其次在我们开发当中，一般都会同时对这两个方法进行重写，如果只重写其中一个或者都不重写当我们将这个对象放入 Map 集合或者 Set 集合中时就会出问题了。如果只重写了 hashCode 方法没有重写 equals 方法，那么就会出现 hashCode 值相同时，这时找到数组同一个位置的元素链表，由于没有重写 equals 方法导致向 Map 中取元素时找不到你要找的元素；当向 Map 集合中放入元素时就会放入重复的元素，因为此时比较的是两个元素的内存地址。如果只重写了 equals 方法没有重写 hashCode 方法，当你向 Map 中获取元素时，第一步比较 hashCode 值时就已经不等，所以也就找不到你想要找的元素了；当你向 Map 中放入元素时，第一步比较就始终定位在数组的不同的位置，这样也就达不到覆盖 key 值相同的元素，Set 集合也达不到去重的效果了。</p>
<p>还有就是对于需要大量并且快速的对比的话如果都用 equals 方法做比较显然效率太低，所以解决方式是每当需要对比的时候，首先用 hashCode 方法进行对比，如果hashCode 不一样，则表示这两个对象肯定不相等（也就是不必再用 equals 对比了），如果 hashCode 相同，此时再通过 equals 方法对比，如果 equals 也相同则表示这两个对象是真的相同了，这样既能大大提高效率也保证对比的绝对正确性！</p>
<p><strong><em>总之，这两个方法对实现 HashMap 的精确性和正确性，以及对 Set 集合中去重功能的实现至关重要，以下 String 类中的 hashCode 方法和 equals 方法：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h &#x3D; hash;</span><br><span class="line">    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] &#x3D; value;</span><br><span class="line">    </span><br><span class="line">        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h &#x3D; 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>public boolean equals(Object anObject) &#123;
    if (this == anObject) &#123;
        return true;
    &#125;
    if (anObject instanceof String) &#123;
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) &#123;
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) &#123;
                if (v1[i] != v2[i])
                    return false;
                i++;
            &#125;
            return true;
        &#125;
    &#125;
    return false;
&#125;</code></pre>
<h2 id="什么是-Java-序列化和反序列化，如何实现-Java-序列化？或者请解释-Serializable-接口的作用"><a href="#什么是-Java-序列化和反序列化，如何实现-Java-序列化？或者请解释-Serializable-接口的作用" class="headerlink" title="什么是 Java 序列化和反序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用"></a>什么是 Java 序列化和反序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用</h2><p>序列化就是一种用来处理对象流的机制,所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间，序列化是为了解决在对对象流进行读写操作时所引发的问题。反序列话则刚好相反，将流化后的对象重新恢复成对象状态就称为反序列化。<br>序列化的实现:将需要被序列化的类实现 Serializable 接口,该接口没有需要实现的方法，实现 Serializable 接口只是为了标注该对象是可被序列化的，然后使用一个输出流(如:FileOutputStream)来构造一个 ObjectOutputStream (对象流)对象，接着使用ObjectOutputStream 对象的 writeObject(Object obj) 方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则使用输入流。</p>
<h2 id="Object-类中常见的方法，为什么-wait-notify-会放在-Object-里边？"><a href="#Object-类中常见的方法，为什么-wait-notify-会放在-Object-里边？" class="headerlink" title="Object 类中常见的方法，为什么 wait notify 会放在 Object 里边？##"></a>Object 类中常见的方法，为什么 wait notify 会放在 Object 里边？##</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;&#125;</span><br><span class="line">public boolean equals(Object obj) &#123;&#125;</span><br><span class="line">public native int hashCode();</span><br><span class="line">protected void finalize() throws Throwable &#123;&#125;</span><br><span class="line">public final native Class&lt;?&gt; getClass();</span><br><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br><span class="line">public final void wait() throws InterruptedException &#123;&#125;</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;&#125;</span><br><span class="line">public final native void notify();</span><br><span class="line">public final native void notifyAll();</span><br><span class="line">private static native void registerNatives();</span><br></pre></td></tr></table></figure>
<p>以上便是 Object 类中所有的方法，其中 toString(), equals(), hashCode() 三个方法是我们见的相对较多的，finalize() 这个方法是由垃圾收集器在确定这个对象没有被引用时在释放对象占用的内存之前会调用该方法，clone() 方法是给对象创建一个自己的副本，前提是对象已经实现了 Cloneable 接口，否则抛出 CloneNotSupportedException，getClass() 方法返回此对象的运行时类型。</p>
<p>wait 有三个重载方法，同时必须捕获非运行时异常 InterruptedException。</p>
<ul>
<li>wait() 进入等待，需要 notify()，notifyAll() 才能唤醒</li>
<li>wait(long timeout) 进入等待，经过 timeout 超时后，若未被唤醒，则自动唤醒</li>
<li>wait(timeout, nanos) 进入等待，经过 timeout 超时后，若未被唤醒，则自动唤醒。相对 wait(long timeout) 时间更加精确。</li>
</ul>
<p>wait() 和 notify() 以及 notifyAll() 则是用来控制线程的状态的，它们必须在 synchronized 同步关键字所限定的作用域中调用，否则会报错 java.lang.IllegalMonitorStateException，意思是因为没有同步，所以线程对象锁的状态是不确定的，不能调用这些方法。同时 synchronized 关键字锁可以是任意对象，任意对象调用的方法则一定是定义在 Object 类中。</p>
<ul>
<li><p>wait 表示持有对象锁的线程准备释放对象锁，释放资源并进入等待状态，直到它被其他线程通过 notify() 或者 notifyAll() 唤醒。</p>
</li>
<li><p>notify 表示持有对象锁的线程准备释放对象锁，调用 notify() 通知 JVM 随机选择一个在该对象上调用 wait() 方法的线程，解除其阻塞状态使其获得对象锁，synchronized 代码作用域结束后，随机选择的那个线程获得对象锁，其他调用 wait() 方法的线程继续等待，直到有新的 notify() 或者 notifyAll() 被调用。</p>
</li>
<li><p>notifyAll 表示持有对象锁的线程准备释放对象锁，调用 notifyAll() 通知 JVM 唤醒所有在该对象上调用 wait() 方法的线程的阻塞状态, synchronized 代码作用域结束后，JVM 通过算法将对象锁指派给其中一个线程，当前获得对象锁的线程 synchronized 代码作用域结束后，然后所有被唤醒的线程不再等待，之前所有被唤醒的线程都有可能获得该对象锁权限，这个由 JVM 算法决定。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试系列</category>
      </categories>
  </entry>
  <entry>
    <title>JdbcTemplate 实现批量插入</title>
    <url>/JdbcTemplate-%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<p>项目中有时候我们会遇到 excel 导入的需求, excle 文件的每一行记录对应的可能都是数据库中的一条记录，一个 excel 中可能有很多行，所以导入一个 excel 就意味着 excel 里面有多少行，我们就要插入多少条记录。如果我们采用一条一条记录插入的方式，毫无疑问，这可能要执行很久。</p>
<p>如果是采用同步的方式的话，页面就会需要等好长一段时间才能有响应。就算采用异步的方式，先给前端一个响应，后台异步执行插入操作，用户也会需要等好长一段时间才能看到刚才 excel 导入的数据。</p>
<a id="more"></a>

<p>这时候批量插入的方式就显得很有必要了。这里我们采用 JdbcTemplate 来实现批量插入。</p>
<p>这里再次以活动统计表 activity_stats 来举例，比如需求就是要导入一份活动统计的 excel 数据,这里为了简单起见，就通过 for 循环来模拟构造一份 excel 数据。</p>
<p>这里我两种方式都实现了，一种是通过 for 循环一个一个保存的，另一种则是批量插入。先声明我测试使用的 mysql 驱动版本是:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring jdbc 依赖版本是:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先我们看 for 循环的方式，代码很简单，我就直接贴出来了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertStats</span><span class="params">(List&lt;ActivityStat&gt; activityStatList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(activityStatList))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = <span class="string">&quot;insert into activity_stats(activity_id, times_viewed, works_count, user_count) values(?, ?, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        activityStatList.forEach(item -&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.jdbcTemplate.update(sql, preparedStatement -&gt; &#123;</span><br><span class="line">                preparedStatement.setLong(<span class="number">1</span>, item.getActivityId());</span><br><span class="line">                preparedStatement.setLong(<span class="number">2</span>, item.getTimesViewed());</span><br><span class="line">                preparedStatement.setLong(<span class="number">3</span>, item.getWorksCount());</span><br><span class="line">                preparedStatement.setLong(<span class="number">4</span>, item.getUserCount());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">&quot;insert state cost &#123;&#125; s&quot;</span>, (System.currentTimeMillis() - start) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面则是批量的方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchInsertStats</span><span class="params">(List&lt;ActivityStat&gt; activityStatList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(activityStatList))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = <span class="string">&quot;insert into activity_stats(activity_id, times_viewed, works_count, user_count) values(?, ?, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate.batchUpdate(sql, <span class="keyword">new</span> BatchPreparedStatementSetter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PreparedStatement preparedStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                ActivityStat data = activityStatList.get(i);</span><br><span class="line">                preparedStatement.setLong(<span class="number">1</span>, data.getActivityId());</span><br><span class="line">                preparedStatement.setLong(<span class="number">2</span>, data.getTimesViewed());</span><br><span class="line">                preparedStatement.setLong(<span class="number">3</span>, data.getWorksCount());</span><br><span class="line">                preparedStatement.setLong(<span class="number">4</span>, data.getUserCount());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBatchSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> activityStatList.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">&quot;batch insert state cost &#123;&#125; s&quot;</span>, (System.currentTimeMillis() - start) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码实现写好了，接下来我们来测试下看看效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertStats</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ActivityStat&gt; activityStatList = mockStatsData();</span><br><span class="line">        <span class="keyword">this</span>.activityStatService.insertStats(activityStatList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchInsertStats</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ActivityStat&gt; activityStatList = mockStatsData();</span><br><span class="line">        <span class="keyword">this</span>.activityStatService.batchInsertStats(activityStatList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 mockStatsData() 方法是一个 for 循环构建了 10000 个 ActivityStat，返回 activityStatList:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ActivityStat&gt; <span class="title">mockStatsData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ActivityStat&gt; activityStatList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            ActivityStat activityStat = <span class="keyword">new</span> ActivityStat();</span><br><span class="line">            activityStat.setActivityId((<span class="keyword">long</span>)i)</span><br><span class="line">                    .setTimesViewed((<span class="keyword">long</span>)(i + <span class="number">100</span>))</span><br><span class="line">                    .setWorksCount((<span class="keyword">long</span>) i + <span class="number">50</span>)</span><br><span class="line">                    .setUserCount((<span class="keyword">long</span>) i + <span class="number">10</span>);</span><br><span class="line">            activityStatList.add(activityStat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activityStatList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行测试的结果是下面这样的:<br><img src="http://images.rookiezhou.top/inser_stats_result.png" alt="insert stats result"></p>
<p><img src="http://images.rookiezhou.top/batch_insert_stats_result.png" alt="batch insert stats result"></p>
<p>往数据库中插入 10000 条记录，采用 for 循环的方式和采用批量的方式插入竟然时间量级是一样的，是不是有点懵，说实话刚开始我也有点懵，就觉得不应该啊，如果这样的话那还要 batchUpdate 方法有什么意义呢。</p>
<p>懵归懵，但还是要找出其中的原因来，正常来说肯定不会是这种结果，应该是哪个环节没弄好，从我们写的代码来看应该是没有问题的，那就通过 debug 的方式看看 batchUpdate 方法里面到底是怎么执行的。这里建议如果要 debug 的源码是稍微比较复杂的，建议不要直接看 class 文件，calss 文件毕竟是编译之后的，代码看起来不是那么的直观，可以在打开 class 文件之后点击右上角提示的下载源码按钮。<br><img src="http://images.rookiezhou.top/download_source.png" alt="download_source"></p>
<p>通过 debug 的方式我在 ClientPreparedStatement 类中找到下面这样一段代码:<br><img src="http://images.rookiezhou.top/batch_insert_condition.png" alt="batch insert condition"></p>
<p>这里有个判断 !this.batchHasPlainStatements &amp;&amp; this.rewriteBatchedStatements.getValue()<br>只有这两个条件同时都满足的情况下才会执行下面的 executeBatchedInserts 或 executePreparedBatchAsMultiStatement 方法，这两个都是批量的方法，第一个是针对 Insert 语句的，下面那个是 Update 和 Delete 语句的批量方法。</p>
<p>当上面这两个条件只要有一个不满足，就会执行最下面的 executeBatchSerially 方法，而在这个方法的内部可以看到有一个 for 循环，然后在 for 循环里面一个一个执行 SQL。<br><img src="http://images.rookiezhou.top/batch_insert_for_loop.png" alt="batch insert for loop"></p>
<p>看到这里再仔细看上面两个条件，对于    !this.batchHasPlainStatements 是类的一个属性，默认值是 false:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Does the batch (if any) contain &quot;plain&quot; statements added by</span></span><br><span class="line"><span class="comment">     * Statement.addBatch(String)?</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * If so, we can&#x27;t re-write it to use multi-value or multi-queries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> batchHasPlainStatements = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>只有在 addBatch 方法中才会置为 true，所以第一个条件满足的。再看第二个条件 thi.rewriteBatchedStatements,是父类的一个属性:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> RuntimeProperty&lt;Boolean&gt; rewriteBatchedStatements;</span><br></pre></td></tr></table></figure>
<p><img src="http://images.rookiezhou.top/jdbc_url_property.png" alt="jdbc_url_property"><br>再看这个属性的初始化值的地方应该能猜到是这个是数据库地址 url 后面接的配置信息。</p>
<p>到这里我们应该知道为什么批量执行的方式和 for 循环一个一个插入时间量级是一样的了，是由于我们的少了rewriteBatchedStatements=true 的配置，导致 batchUpdate 代码内部其实还是通过 for 循环的方式来执行的，所以量级才会是一样的，接下来我们加上这项配置再执行就可以看到速度明显上来了，下面是加上改配置执行之后的结果:</p>
<p><img src="http://images.rookiezhou.top/real_batch_insert_stats_result.png" alt="real batch update result"></p>
<p>插入 10000 条记录用时才 2s，而加上配置之前是 30s。其实 rewriteBatchedStatements=true 配置对于批量的 insert 语句来说，是实现了下面的效果:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats(activity_id, times_viewed, works_count, user_count) <span class="keyword">values</span>(?, ?, ?, ?);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats(activity_id, times_viewed, works_count, user_count) <span class="keyword">values</span>(?, ?, ?, ?);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats(activity_id, times_viewed, works_count, user_count) <span class="keyword">values</span>(?, ?, ?, ?)</span><br><span class="line"><span class="comment"># 重写之后</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats(activity_id, times_viewed, works_count, user_count) <span class="keyword">values</span>(?, ?, ?, ?),(?, ?, ?, ?),(?, ?, ?, ?);</span><br></pre></td></tr></table></figure>
<p>也就是是否将多条重写成一条，然后在发给 MySQL 执行，这样不用一条一条发过去执行，大大提高了执行效率。</p>
<p>好了，上面整体就是 JdbcTemplate 批量插入的实现，记得千万不要忘了加上 rewriteBatchedStatements=true 的配置，不然可能你写完了以为已经实现了批量插入，但结果根本没有达到批量执行的效果。</p>
]]></content>
      <categories>
        <category>JdbcTemplate</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 系统下 AES 解密报错问题</title>
    <url>/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B-AES-%E8%A7%A3%E5%AF%86%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>前两天在开发中遇到一个问题，就是一个服务部署在 Window 系统上的，而另一个服务部署在 Linux 系统上，Linux 系统上的服务需要通过 WebService 向 Window 系统上的服务获取数据，而这个数据是经过 AES 加密的，获取到密文之后需要进行解密，然后拿到解密之后的数据进行处理，但是在 Linux 系统服务上进行解密时却报错了，下面就是报错信息。</p>
<a id="more"></a>

<p><img src="http://images.rookiezhou.top/AES-Error.png" alt="解密时报错信息"></p>
<p>遇到错误第一时间找度娘 ( 其实应该找 Google )，结果发现原来是操作系统的原因，Linux 系统下在进行 AES 加解密时生成 key 时是有问题的，key 值的生成方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeyGenerator generator &#x3D; KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">&#x2F;&#x2F;password 为加解密使用的密钥</span><br><span class="line">generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">Key key &#x3D; generator.generateKey();</span><br></pre></td></tr></table></figure>

<p>SecureRandom 的实现尝试完全随机化生成器本身的内部状态，因此随操作系统本身的內部状态而定，该实现在 windows 上每次生成的 key 都相同，但是在 linux 系统上则不同，除非调用方在调用 getInstance 方法之后又调用了 setSeed 方法，将上述生成 key 值的方式改为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeyGenerator generator &#x3D; KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">&#x2F;&#x2F;generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">SecureRandom secureRandom &#x3D; SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">&#x2F;&#x2F;password 为加解密使用的密钥</span><br><span class="line">secureRandom.setSeed(password.getBytes());</span><br><span class="line">generator.init(128, secureRandom);</span><br><span class="line">Key key &#x3D; generator.generateKey();</span><br></pre></td></tr></table></figure>
<p>上面只是修改了 key 值的生成方式，这样就能够避免在 Linux 系统上加解密失败的错误了。完整的 AES 加解密工具类如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu.common.util;</span><br><span class="line"></span><br><span class="line">import sun.misc.BASE64Decoder;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line">import javax.crypto.KeyGenerator;</span><br><span class="line">import java.security.Key;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AesEncodeUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String content &#x3D; &quot;www.baidu.com&quot;;</span><br><span class="line">        String pwd &#x3D; &quot;ecjtu&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;加密前content：&quot; + content);</span><br><span class="line">        &#x2F;&#x2F; 加密</span><br><span class="line">        String enContent &#x3D; encodeByAes(content, pwd);</span><br><span class="line">        System.out.println(&quot;加密后content：&quot; + enContent);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 解密</span><br><span class="line">        String deContent &#x3D; decodeByAes(enContent, pwd);</span><br><span class="line">        System.out.println(&quot;解密后content：&quot; + deContent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 加密</span><br><span class="line">     *</span><br><span class="line">     * @param content  待加密内容</span><br><span class="line">     * @param password 加密密钥</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String encodeByAes(String content, String password) &#123;</span><br><span class="line">        Key key &#x3D; generateKey(password);</span><br><span class="line">        BASE64Encoder base64en &#x3D; new BASE64Encoder();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建密码器</span><br><span class="line">            Cipher cipher &#x3D; Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">            byte[] byteContent &#x3D; content.getBytes(&quot;utf-8&quot;);</span><br><span class="line">            &#x2F;&#x2F; 初始化</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">            &#x2F;&#x2F; 加密</span><br><span class="line">            content &#x3D; base64en.encode(cipher.doFinal(byteContent));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解密</span><br><span class="line">     *</span><br><span class="line">     * @param content  待解密内容</span><br><span class="line">     * @param password 解密密钥</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String decodeByAes(String content, String password) &#123;</span><br><span class="line">        Key key &#x3D; generateKey(password);</span><br><span class="line">        BASE64Decoder base64de &#x3D; new BASE64Decoder();</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] byteContent &#x3D; base64de.decodeBuffer(content);</span><br><span class="line">            &#x2F;&#x2F; 创建密码器</span><br><span class="line">            Cipher cipher &#x3D; Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">            &#x2F;&#x2F; 初始化</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">            &#x2F;&#x2F; 解密</span><br><span class="line">            content &#x3D; new String(cipher.doFinal(byteContent), &quot;UTF8&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据密钥生成加解密使用的 key 值</span><br><span class="line">     *</span><br><span class="line">     * @param password 加解密密钥</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Key generateKey(String password) &#123;</span><br><span class="line">        Key key &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyGenerator generator &#x3D; KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">            &#x2F;&#x2F;下面这种方式在 Linux 系统下会报错</span><br><span class="line">            &#x2F;&#x2F;generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">            SecureRandom secureRandom &#x3D; SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">            secureRandom.setSeed(password.getBytes());</span><br><span class="line">            generator.init(128, secureRandom);</span><br><span class="line">            key &#x3D; generator.generateKey();</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 系统下的软链接和硬链接</title>
    <url>/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>之前一直不是很明白 Linux 系统下的软链接 (soft link) 和硬链接 (hard link) 的区别和用法，今天刚好又用到了，特意花了点时间去了解了一下，暂且在这里记录一下吧。</p>
<p>在介绍硬链接和软链接之前先介绍一下 Linux 系统下面的文件结构，文件在 Linux 下可以分为两个部分：元数据和用户数据。元数据中主要包含文件的一些附加属性，比如：文件大小，创建时间，所有者信息以及 文件的 inode 索引号，inode 索引号是文件索引节点号，也是文件的唯一标识，我们平常看到的文件名并非是用来区分文件而是一个别名便于我们识别和记忆；用户数据则是文件的数据块内容，也就是该文件保存的真正内容。</p>
<a id="more"></a>

<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>(1) 含义<br>硬链接表示的是一个文件的 inode 索引号对应于多个文件名，也就是说我们对一个文件创建了多个文件名，它们都对应于同一个 inode 索引号标识的文件，当我们删除其中任意一个文件名，都不会对其他文件名有影响，每删一个文件名，该文件的链接数减一，只有当该文件的链接数为 0 时系统会将其数据块和 inode 索引号回收。</p>
<p>(2) 创建方式<br>eg. 为 /root/fileA 创建硬链接 /home/fileB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln &#x2F;root&#x2F;fileA &#x2F;home&#x2F;fileB</span><br></pre></td></tr></table></figure>

<p>注意：应该使用文件的绝对路径，避免使用相对路径。</p>
<p>(3) 特性</p>
<ul>
<li>文件有相同的 inode 及 data block</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件</li>
<li>文件的链接数为 0 时系统会将其数据块和 inode 索引号回收</li>
</ul>
<p>(4) 使用限制</p>
<ul>
<li>不能对目录创建硬链接，只能对文件创建</li>
<li>不能对不同的文件系统创建硬链接,即两个文件名要在相同的文件系统下</li>
<li>只能对已存在的文件进行创建</li>
</ul>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>(1) 含义<br>软链接其实就是一个普通的文件，有着自己的 inode 索引号和数据块，特殊的是该文件的用户数据块中存放的是另一个文件的路径，有点类似于 Windows 系统中的快捷方式，通过快捷方式可以打开它所指向的文件，链接文件的删除不影响该链接文件数据块存放的路径指向的文件。</p>
<p>(2) 创建方式<br>eg. 为 /root/fileA 创建软链接 /home/fileB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;root&#x2F;fileA &#x2F;home&#x2F;fileB</span><br></pre></td></tr></table></figure>

<p>注意：应该使用文件的绝对路径，避免使用相对路径。</p>
<p>(3) 特性</p>
<ul>
<li>软链接有自己的文件属性及权限等</li>
<li>创建软链接时，链接计数不会增加</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）</li>
</ul>
<p>(4) 使用限制</p>
<ul>
<li>可以跨文件系统创建</li>
<li>可以对文件或者目录创建</li>
<li>可以对一个不存在的文件或者目录创建</li>
</ul>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>最后说一下文件的类型主要有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d ：目录   </span><br><span class="line">- ：文件   </span><br><span class="line">l ：链接   </span><br><span class="line">s ：socket   </span><br><span class="line">p ：named pipe   </span><br><span class="line">b ：block device   </span><br><span class="line">c  ：character device  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 系统下远程连接和远程拷贝命令</title>
    <url>/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在平常开发部署中，我们可能经常需要远程连接到服务器上执行一些操作，有时还需要拷贝相应的文件过去，这里记录下平常自己用的比较多的远程连接命令以及远程拷贝文件的命令。</p>
<a id="more"></a>
<h3 id="远程连接-ssh-命令"><a href="#远程连接-ssh-命令" class="headerlink" title="远程连接 ssh 命令"></a>远程连接 ssh 命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh zhouxh@192.168.0.134</span><br></pre></td></tr></table></figure>
<p>上面是通过默认 22 端口连接，如果需要指定端口连接，加上 -p 参数指定相应端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 33109 zhouxh@192.168.0.134</span><br></pre></td></tr></table></figure>

<h3 id="远程拷贝-scp-命令"><a href="#远程拷贝-scp-命令" class="headerlink" title="远程拷贝 scp 命令"></a>远程拷贝 scp 命令</h3><p>将本地文件 file1 拷贝到另一台主机用户名为 zhouxh 的家目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;zhouxh&#x2F;file1 zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;</span><br></pre></td></tr></table></figure>
<p>将本地目录 dir1 拷贝到另一台主机用户名为 zhouxh 的家目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;zhouxh&#x2F;dir1 zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;</span><br></pre></td></tr></table></figure>
<p>将另一台主机用户名为 zhouxh 的家目录下的文件 file1 拷贝到本地家目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;file1 &#x2F;home&#x2F;zhouxh&#x2F;</span><br></pre></td></tr></table></figure>
<p>将另一台主机用户名为 zhouxh 的家目录下的 dir1 目录拷贝到本地家目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;dir1 &#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>
<p>以上拷贝命令都是通过默认 22 端口拷贝，如果需要指定端口，加上 -P 参数，注意 P 大写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -P 33109 &#x2F;home&#x2F;zhouxh&#x2F;file1 zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 下 MySQL 安装以及配置远程可访问</title>
    <url>/Ubuntu-%E4%B8%8B-MySQL-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%8F%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h3 id="Ubuntu-安装-MySQL"><a href="#Ubuntu-安装-MySQL" class="headerlink" title="Ubuntu 安装 MySQL###"></a>Ubuntu 安装 MySQL###</h3><p>最好先执行一次更新操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后执行以下三条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get isntall mysql-client</span><br><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<p>安装成功后可以通过下面的命令测试是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure>

<p>出现如下信息证明 MySQL 安装成功：<br>​<img src="http://images.rookiezhou.top/mysql.png" alt="mysqld.cnf 文件"></p>
<p>对于 Ubuntu 系统下安装 MySQL 后一般都不支持远程连接，只能通过 localhost 或者 127.0.0.1 进行连接，因此需要我们自己去配置，这里介绍两种方式：</p>
<h3 id="创建一个新的访问用户，配置该用户可以远程访问。-推荐使用这种方式"><a href="#创建一个新的访问用户，配置该用户可以远程访问。-推荐使用这种方式" class="headerlink" title="创建一个新的访问用户，配置该用户可以远程访问。(推荐使用这种方式)"></a>创建一个新的访问用户，配置该用户可以远程访问。(推荐使用这种方式)</h3><p>(1) 在安装好了 MySQL 数据库之后，由于 MySQL 数据库安装好之后出于安全考虑默认就是只允许通过本机访问，即只能通过 127.0.0.1 或者 localhost 去访问，所以首先需要修改 MySQL 的配置文件，在 Ubuntu 系统下, MySQL 的配置文件在路径 /etc/mysql/mysql.conf.d/ 下,找到该路径下的 mysqld.cnf 文件打开找到如下位置:<br>​<img src="http://images.rookiezhou.top/mysqld.cnf.png" alt="mysqld.cnf 文件"></p>
<p>红色标注部分这里就是 MySQL 默认只能由本机访问，我们将其注释掉。注释之后最好将服务重启，之后再进行创建用户以及赋予相应权限的操作。</p>
<p>(2) 在本机使用 root 用户登录到 MySQL 数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>回车后输入密码登录。<br>(3) 创建用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user username identified by &#39;password&#39;; </span><br></pre></td></tr></table></figure>

<p>username 是你要创建的用户名，password 为密码。</p>
<p>(4) 给创建的用户添加权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to &#39;username&#39;@&#39;%&#39; identified by &#39;password&#39; with grant option;</span><br></pre></td></tr></table></figure>

<p>上面的 all 代表接受所有操作，比如 select,insert,delete….;  <em>.</em> 代表所有数据库下面的所有表，也就是所有权限;而 % 代表这个用户允许从任何地方登录；为了安全期间，这个 % 可以替换为你允许的 ip 地址。username  表示你要赋予权限的用户名，password 表示该用户名对应的密码。</p>
<p>(5) 修改后刷新权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>(6) 执行完上面的操作后，输入 quit 命令退出数据库将 MySQL 服务重启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>

<p>(7) 重启之后用刚才创建好的用户并且使用本机的 IP 地址进行测试，输入如下命令登录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h 192.168.0.161 -u username -p</span><br></pre></td></tr></table></figure>

<p>192.168.0.161 表示 MySQL 服务所在机器的 IP 地址，username 为刚才新创建的用户名，回车后输入密码，再回车登录成功表示配置已经生效了。否则需要再检查一遍其他哪里没有配置好。</p>
<h3 id="修改当前-root-用户的配置，使该用户可以远程访问"><a href="#修改当前-root-用户的配置，使该用户可以远程访问" class="headerlink" title="修改当前 root 用户的配置，使该用户可以远程访问"></a>修改当前 root 用户的配置，使该用户可以远程访问</h3><p>同样的先执行第一种方式中步骤一和步骤二，然后执行以下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39; with grant option;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>之后将 MySQL 服务重启，重启之后用 root 用户通过 IP 地址登录测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h 192.168.0.161 -u root -p</span><br></pre></td></tr></table></figure>
<p>两种方式本质是一样的，只不过第二种更省事，直接在已有的 root 用户上进行更改，但这样不是很安全，所以推荐第一种方式，配置权限时可以指定一些权限，也可以指定 IP 地址可远程访问。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 执行命令时报错 unable to resolve host</title>
    <url>/Ubuntu-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%97%B6%E6%8A%A5%E9%94%99-unable-to-resolve-host/</url>
    <content><![CDATA[<h2 id="记录一下今天遇到的一个问题"><a href="#记录一下今天遇到的一个问题" class="headerlink" title="记录一下今天遇到的一个问题"></a>记录一下今天遇到的一个问题</h2><p>今天在阿里云服务器上部署应用时遇到一个小问题，每次执行完 sudo 命令都会出现一行错误信息，刚开始还以为执行命令出错了，但仔细一看不像是执行命令的报错信息，而且还发现命令其实已经执行成功了。</p>
<a id="more"></a>

<p>执行命令之后的报错信息如下：</p>
<p><img src="http://images.rookiezhou.top/resolve-host3.png" alt="hosts 文件"></p>
<p>于是去百度了一波，发现原来是**<em>因为 /etc/ 路径下 hosts 文件中的主机名和 hostname 文件中的主机名不一致**</em>所导致的错误。</p>
<p>经查看 hostname 文件中的主机名如下：</p>
<p><img src="http://images.rookiezhou.top/resolve-host5.png" alt="hosts 文件"></p>
<p>知道原因了之后就知道如何解决了，方式如下:</p>
<p>在 /etc/ 路径下 hosts 文件中添加一行，将 /etc/ 路径下 hostname 文件中的主机名称拷贝过来即可，hosts 文件修改之后如下：</p>
<p><img src="http://images.rookiezhou.top/resolve-host4.png" alt="hosts 文件"></p>
<p>以下则分别是我电脑上 /etc 路径下 hosts 文件和 hostname 文件中的内容</p>
<p><img src="http://images.rookiezhou.top/resolve-host.png" alt="hosts 文件"></p>
<p><img src="http://images.rookiezhou.top/resolve-host2.png" alt="hostname 文件"></p>
<p>比如上面我电脑上 hostname 文件中内容是 zhouoxh-X550VC ，只要在 hosts 文件中添加一行 127.0.1.1       zhouxh-X550VC，如果不加这一行执行 sudo 命令就会报错。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 系统安装以及一些开发中必要的安装配置</title>
    <url>/Ubuntu-%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BF%85%E8%A6%81%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>对于开发人员来说，个人强烈推荐使用 Linux 系统进行开发，至于为什么，这里贴出自己刚开始尝试使用 Linux 系统时看的一个博主写的文章，可以说就是因为看了这位博主的文章才立即决定装上 Linux 系统，开始了我的 Linux 系统之旅，从此停不下来了。下面就是这位博主写的文章地址，里面详细阐述了为什么要使用 Linux 系统。</p>
<a id="more"></a>

<p><a href="http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/">http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/</a><br><a href="http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/">Ubuntu桌面生存指南 (1) — 选择 Linux</a></p>
<p>这位博主写了 5 篇文章关于 Linux 系统的，建议从第一篇开始看，一直看下去，看完之后如果还是不想进入 Linux 系统的世界，那么可能 Linux 系统与你无缘，这里并无冒犯的意思，纯属个人喜好。</p>
<p>博主从零开始全面的介绍了 Linux 系统，（当然还是要有点 Linux 系统的基础去看更好）一直到 Linux 系统的安装以及后面的维护和备份，值得去好好的看一遍，那么这里我主要是想记录下自己的安装过程以及开发中的一些必要软件安装和配置，以防以后重复去搜索资源。</p>
<h3 id="Ubuntu-系统的安装"><a href="#Ubuntu-系统的安装" class="headerlink" title="Ubuntu 系统的安装"></a>Ubuntu 系统的安装</h3><p>U 盘启动盘制作<br>对于 Linux 系统的启动盘制作很简单，只需要下载一个制作工具即可，下载链接如下：</p>
<p><a href="http://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/#button">U 盘启动盘制作软件</a></p>
<p><img src="http://images.rookiezhou.top/download.png" alt="制作工具下载网页"></p>
<p>下载完制作工具后，准备好 Linux 系统镜像文件，以 Ubuntu 镜像为例，最好去官网下载最新的，而且带有 LTS 结尾的 ISO 文件，下载好以后打开刚才下载的制作软件</p>
<p><img src="http://images.rookiezhou.top/make-usb.jpg" alt="制作工具使用"></p>
<p>图中三处标红的地方从上到下分别是制作的启动盘要安装的镜像类型，准备好的镜像文件位置，要制作的 U 盘。这里提醒记得备份 U 盘里面的重要资料，制作完成之后会全部格式化。选择好之后点击 create 按钮，等个十来分钟应该就会出现如下字样了。</p>
<p><img src="http://images.rookiezhou.top/success.jpg" alt="制作成功"></p>
<p>到这里 U 盘启动盘就已经制作好了，接下来就是插入你要安装系统的笔记本或者台式机上，设置好从 U 盘启动，进入系统后出现以下界面(有的版本不一样可能不会立马进入这个界面，会直接进入安装界面，可以点击旁边的 Try Ubuntu 按钮来进入这个界面，直接安装可能会出问题)</p>
<p><img src="http://images.rookiezhou.top/install.png" alt="Ubuntu 系统安装"></p>
<p>在从这里点击进入安装界面，接下来就是按照指示进行操作即可，实在不懂的可以百度找一下具体的安装步骤，中间分区的步骤尽量自己来进行分区，具体的分区方案以下供参考：</p>
<p>一般来说一个 Ubuntu 的系统在安装之初应该有三个分区，他们分别是挂载于根目录： /, home 目录： /home 的两个分区以及 swap 分区。swap 分区是指虚拟内存的交换区，一般设置为实际内存容量的两倍大小即可。<br>假如有一台 8G 内存，1T 磁盘的笔记本电脑，swap: 15G  15360M，/:  100G  102400M<br>/boot:    20G     20480M，/home:   剩余空间都分给 home</p>
<p><a href="https://blog.csdn.net/u012052268/article/details/77145427">安装 Ubuntu Linux 系统时硬盘分区最合理的方法</a><br><a href="https://blog.csdn.net/zzxian/article/details/25487951">win7 下制作 Ubuntu 系统安装启动盘和 U 盘安装 Ubuntu 全过程</a></p>
<h3 id="Ubuntu-系统软件源配置"><a href="#Ubuntu-系统软件源配置" class="headerlink" title="Ubuntu 系统软件源配置"></a>Ubuntu 系统软件源配置</h3><p>到这里 Ubuntu 系统应该安装完成了，接下来就可以配置日常开发中需要的工具软件了<br>软件源配置：Ctrl + Alt + T 快捷键打开终端命令行，输入 update-manager 回车打开软件更新器，这时可能会提示检查更新，可以选择稍后提醒，</p>
<h3 id="Ubuntu-系统软件后台启动"><a href="#Ubuntu-系统软件后台启动" class="headerlink" title="Ubuntu 系统软件后台启动"></a>Ubuntu 系统软件后台启动</h3><p>在 Ubuntu 系统的终端运行软件会将终端占据，这样你不得不重新启动一个终端来执行命令，这里有一个脚本配置软件从后台启动，不会占据终端。在 home 目录下创建 bin目录，然后在 bin 目录下新建一个文本文件，命名 x ，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">&quot;$@&quot; 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>并且给这个脚本文件添加可执行权限，这个脚本的大意是运行软件的时候，不输出任何标准信息和错误信息，并且在后台运行，这样就可以避免占据终端的行为。比如启动火狐浏览器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x Firefox</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-系统-vi-编辑器配置"><a href="#Ubuntu-系统-vi-编辑器配置" class="headerlink" title="Ubuntu 系统 vi 编辑器配置"></a>Ubuntu 系统 vi 编辑器配置</h3><p>在终端中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ set -o vi</span><br></pre></td></tr></table></figure>

<p>可以开启以兼容 vi 的快捷键操作 bash 命令，此时你可以在终端使用 Esc 切换到命令模式，在命令模式下，按 h，l 可以左右移动光标，按 j，k 可以切换前一条后一条命令。x可以修改字符，”$， ^”可以返回命令尾部或头部，i 可以返回编辑模式。Vi/Vim 本身不需要安装，但是如果你更乐衷于视觉效果更好，功能更丰富的 GUI 版本可以安装GVim:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure>
<p>执行以下命令进入 vi 编辑器训练教程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimtutor</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-系统终端分屏工具-Tmux"><a href="#Ubuntu-系统终端分屏工具-Tmux" class="headerlink" title="Ubuntu 系统终端分屏工具 Tmux"></a>Ubuntu 系统终端分屏工具 Tmux</h3><p> 运行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<p>安装过程中如果遇到由于包依赖问题导致安装失败的话，可以尝试下面命令进行修复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get -f install</span><br></pre></td></tr></table></figure>

<p>个性化配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">rm -rf .tmux</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gpakosz&#x2F;.tmux.git</span><br><span class="line">ln -s .tmux&#x2F;.tmux.conf</span><br><span class="line">cp .tmux&#x2F;.tmux.conf.local .</span><br></pre></td></tr></table></figure>
<p>相关链接：<br><a href="https://blog.csdn.net/u014015972/article/details/51611817">tmux 的使用</a><br><a href="http://blog.jobbole.com/87584/">Tmux 速成教程：技巧和调整</a><br><a href="http://www.cnblogs.com/chjbbs/p/5689011.html">tmux的使用方法和个性化配置</a></p>
<h3 id="Ubuntu-系统安装-Chrome-浏览器"><a href="#Ubuntu-系统安装-Chrome-浏览器" class="headerlink" title="Ubuntu 系统安装 Chrome 浏览器"></a>Ubuntu 系统安装 Chrome 浏览器</h3><p>在终端中，执行以下四条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget http:&#x2F;&#x2F;www.linuxidc.com&#x2F;files&#x2F;repo&#x2F;google-chrome.list -P &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;</span><br><span class="line">wget -q -O - https:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;linux_signing_key.pub | sudo apt-key add -</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu-系统安装-JDK"><a href="#Ubuntu-系统安装-JDK" class="headerlink" title="Ubuntu 系统安装 JDK"></a>Ubuntu 系统安装 JDK</h3><p>去官网下载 Ubuntu 系统的 JDK 开发工具压缩包，解压到某个文件夹中，然后配置环境变量，以下是我电脑上的一些环境变量配置，我这里是配置在 /etc/profile 文件中的，对所有用户有效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jdk1.8.0_144</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export ZOO_HOME&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.11</span><br><span class="line">export M2_HOME&#x3D;&#x2F;opt&#x2F;maven&#x2F;apache-maven-3.5.0</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;M2_HOME&#125;&#x2F;bin:$&#123;ZOO_HOME&#125;&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;curl&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<p>配置好后要想环境变量立即生效可以执行以下命令,或者重启生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu-系统安装截图工具-deepin-scrot-并且配置快捷键"><a href="#Ubuntu-系统安装截图工具-deepin-scrot-并且配置快捷键" class="headerlink" title="Ubuntu 系统安装截图工具 deepin-scrot 并且配置快捷键###"></a>Ubuntu 系统安装截图工具 deepin-scrot 并且配置快捷键###</h3><p>执行以下命令下载截图工具：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;packages.linuxdeepin.com&#x2F;deepin&#x2F;pool&#x2F;main&#x2F;d&#x2F;deepin-scrot&#x2F;deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure>
<p>截图工具安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-xlib</span><br><span class="line">sudo dpkg -i deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure>
<p>当安装失败时可能是由于依赖问题，执行下面命令进行修复之后继续安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get -f install</span><br><span class="line">sudo dpkg -i deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure>
<p>deepin-scrot 截图快捷键设置：<br><img src="http://images.rookiezhou.top/deepin-scrot-key.png" alt="截图快捷键设置"></p>
<p>xkill 快捷键配置， 关闭无响应的程序：<br><img src="http://images.rookiezhou.top/xkill-key.png" alt="xkill 快捷键设置"></p>
<p>返回桌面快键键配置，换回 window 系统下熟悉的 super + d 快捷键：<br><img src="http://images.rookiezhou.top/super-d.png" alt="返回桌面快捷键设置"></p>
<p>可能有时返回桌面的快捷键配置后还是没用，super + d 无法返回到桌面，这时需要做以下设置：<br>首先安装 compizconfig-settings-manager：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install compizconfig-settings-manager</span><br></pre></td></tr></table></figure>

<p>然后在终端输入 compizconfig-settings-manager 命令打开该软件，找到 Ubuntu Unity plugin，General 里面有个 Show Desktop，设置一下相应快捷键就可以了。</p>
<h3 id="Ubuntu-系统微信、QQ、Listen-安装"><a href="#Ubuntu-系统微信、QQ、Listen-安装" class="headerlink" title="Ubuntu 系统微信、QQ、Listen 安装###"></a>Ubuntu 系统微信、QQ、Listen 安装###</h3><p>微信安装参考 GitHub 上面的一个项目，里面有已经发布好了的，直接下载解压后即可使用，链接如下：</p>
<p><a href="https://github.com/geeeeeeeeek/electronic-wechat/releases">GitHub 微信项目链接</a></p>
<p>QQ 安装参考下面博主写的教程：</p>
<p><a href="https://blog.csdn.net/ysy950803/article/details/80215101">Ubuntu 18.04安装最新版QQ（9.0）</a><br><a href="https://blog.csdn.net/qq_36428171/article/details/78244730">在ubuntu17.04下安装最新版QQ教程</a></p>
<p>Listen 是一款听音乐的 App，集成了网易，虾米，QQ 音乐，你想听的里面基本上能够搜到，而且界面也很符合我们开发者的风格，可以说很良心了，网站链接：</p>
<p><a href="http://listen1.github.io/listen1/">Listen 网站链接</a><br>打开该网站下载 Linux 版本即可，他还有浏览器插件版，不想安装的话也可以直接下载浏览器插件版。</p>
<p>最后如果必须要用到 Windows 系统下面的软件的话，那就只能推荐一款软件给你了：Virtual Box 安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install virtualbox</span><br><span class="line">sudo apt-get install virtualbox-guest-additions</span><br><span class="line">sudo apt-get install virtualbox-guest-additions-iso</span><br></pre></td></tr></table></figure>
<p>使 Virtualbox 辨认出物理 USB 外设</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-system-tools</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>macOS 下使用 Docker 运行 MySQL 服务遇到的问题说明</title>
    <url>/macOS-%E4%B8%8B%E4%BD%BF%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-MySQL-%E6%9C%8D%E5%8A%A1%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>在之前的使用 Docker 运行 MySQL 服务的这篇文章中，有个问题没有描述清楚，这里我纠正下当时的说法，并且详细解释下缘由。</p>
<p>当时我做的测试是在 macOS 系统下完成的，当时使用 Docker 启动服务的时候报错了，报错信息如下:</p>
<a id="more"></a>

<p><img src="http://images.rookiezhou.top/blog/images/docker_run_error.png" alt="docker run error"></p>
<p>当时我没太在意为什么会出现这种情况，我以为是跟我的目录包含大写字母的目录有关系，就直接去查了下解决办法，当时找到的解决方法是就是加上 mysqld –lower_case_table_names=0 这一串参数。</p>
<p>但其实不是这样的，首先先说明跟我指定的数据存储的目录包含大写路径无关。出现这个错误的原因其实错误信息里面已经提示了，”lower_case_table_names” 设置不一致，server 上该参数的值是 2，数据目录是 0。</p>
<p>首先我们先明白 lower_case_table_names 这个参数的作用，它的值可能有三种: 0，1，2.</p>
<ul>
<li>0: 表名和数据库名使用 CREATE TABLE 或 CREATE DATABASE 语句中指定的字母大小写存储在磁盘上，名称比较区分大小写</li>
<li>1: 表名以小写形式存储在磁盘上，名称比较不区分大小写，MySQL 在存储和查找时将所有表名转换为小写，此行为也适用于数据库名称和表别名。</li>
<li>2: 表名和数据库名使用 CREATE TABLE 或 CREATE DATABASE 语句中指定的字母大小写存储在磁盘上，但 MySQL 在查找时将它们转换为小写，名称比较不区分大小写，仅适用于不区分大小写的文件系统。</li>
</ul>
<p>上面是设置不同值下的作用，那么默认值是多少呢？这取决于我们运行 MySQL 所在的系统，在 Unix 上，lower_case_table_names 的默认值为 0。在 Windows 上，默认值为 1。在 macOS 上，默认值为 2。</p>
<p>而且还有值得注意的一点是: 仅在初始化服务器时才能配置 lower_case_table_names，禁止在服务器初始化后更改 lower_case_table_names 设置。</p>
<p>好了，在介绍完 lower_case_table_names 参数的作用以及注意事项之后，我们再回到之前的启动报错问题，这个就是 MySQL 初始化的时候数据目录挂在 macOS 下，该值的默认值是 2，而数据库启动的时候在 docker 容器中，容器中系统是 Unix，默认值是 0，这就是尝试在服务器初始化后更改 lower_case_table_names 设置，这是被禁止的，启动的时候和初始化时不一致所以报错了。</p>
<p>知道原因之后，那我们就尝试在初始化的时候就指定，加上 mysqld –lower_case_table_names=0 这一串参数来指定 lower_case_table_names 的值为 0，所以我们启动成功了。</p>
<p>但是我们一般都希望数据库名称或表名称在比较时不区分大小写，而且官方也有说明: “如果您在具有不区分大小写的文件名（例如 Windows 或 macOS）的系统上运行 MySQL，则不应将此变量设置为 0。如果在不区分大小写的文件系统上使用 –lower-case-table-names = 0 将此变量强制为 0，并使用不同的字母大小写访问 MyISAM 表名，则可能导致索引损坏”。</p>
<p>所以我们还是将 lower_case_table_names 的值设置成 1。同时我们在创建数据库名或表名的时候也尽量不要大小写混用，这也是为了避免出现意外情况。其实在阿里的 Java 开发手册中是强制约束表名、字段名必须使用小写字母，也是为了避免节外生枝。</p>
<p><img src="http://images.rookiezhou.top/blog/images/table_name_rule.png" alt="table name rule"></p>
<p>好了，如果我们想要将 lower_case_table_names 的值设置成 1 该怎么做呢。是不是直接将参数改成 1 就可以了呢，我们可以试下，看看效果。试之前记得将挂载的数据库数据目录删除再做测试，不然会影响测试效果，或者重新挂载另一个目录也行，做完测试删掉就好了。</p>
<p>我们执行下面命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d run -d -p 3307:3307 -v /Users/rookiedev/docker/mysql/data1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql8.0-test mysql/mysql-server:8.0 mysqld --lower_case_table_names=1</span><br></pre></td></tr></table></figure>

<p>这里要注意，不同的数据库版本测试效果不一样的，这里我测试的效果是启动成功了，也验证确实将 lower_case_table_names 参数设置为 1 了，我通过以下命令进入连接 mysql 服务并且查看该参数的值确实是 1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it a9 mysql -uroot -p</span><br><span class="line">show variables like &quot;%case_table%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="http://images.rookiezhou.top/blog/images/mysql_case_table.png" alt="mysql case table"></p>
<p>但有的版本是会失败的，我遇到过，但我没找出其中失败的规律，如果刚好你也碰到了，感兴趣的话可以研究看看，但我觉得大概率是不同版本的 mysql 启动配置文件可能不一样导致的，接下来我们就来介绍一下通过配置文件的方式来指定该参数值的方式。</p>
<p>之前我们只是通过 -v 参数挂载了数据目录，我们也可以通过 -v 参数来挂载 mysql 的配置文件, -v /Users/rookiedev/docker/mysql/conf:/etc/mysql，完整启动命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d run -d -p 3307:3307 -v /Users/rookiedev/docker/mysql/data1:/var/lib/mysql -v /Users/rookiedev/docker/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql8.0-test mysql/mysql-server:8.0</span><br></pre></td></tr></table></figure>

<p>/Users/rookiedev/docker/mysql/conf 目录下包含一个 my.cnf 配置文件，文件内容是:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># datadir=/home/data</span><br><span class="line"># log-error=/home/logs/error.log</span><br><span class="line">lower_case_table_names=1</span><br></pre></td></tr></table></figure>

<p>上面的命令如果启动还是失败的话，可以加上 –restart=always 参数看看，参数的意思就是容器启动失败时会自动重启容器，同时 docker 重启时容器也会自动重启。同样启动成功之后可以进入容器连接 mysql 后看看是否设置成功了。</p>
<p>总的来说，我说的通过 mysqld 参数指定还是通过配置文件的方式指定，可能不一定适合你，具体问题具体分析吧。但我觉得这里我们需要知道的是 lower_case_table_names 这个参数的含义，在我们遇到数据库名字或表名是大写的或大小写混合时，我们可能会碰到一些问题，这时注意下当前数据库 lower_case_table_names 的值，还是有利于排查问题的。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>nginx location 路径匹配规则</title>
    <url>/nginx-location-%E8%B7%AF%E5%BE%84%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>之前每次配置 nginx 中的 location 这个路径时都会很头疼，基本上每次都是靠碰运气，一个个去试，直到访问路径通了为止，这样一来到最后还是不知道怎么配置成功的，下次再配置时又需要一个个去试，既浪费时间又很没有效率，所以这次特意花了点时间去学习了一番，特此记录一下，也记录一下自己在测试的过程中踩过的一些坑。</p>
<a id="more"></a>

<h2 id="location-匹配模式"><a href="#location-匹配模式" class="headerlink" title="location 匹配模式"></a>location 匹配模式</h2><p>主要有以下几种匹配模式：</p>
<ul>
<li>= 绝对匹配，如果匹配到了这个将停止匹配并处理该请求</li>
<li>~ 区分大小写的正则匹配</li>
<li>~* 不区分大小写的正则匹配</li>
<li>^~ 如果把这个前缀用于一个常规字符串,那么告诉 nginx 如果路径匹配那么不再去匹配正则</li>
<li>/ 通用匹配，任何请求都会匹配到</li>
</ul>
<p>它们之间的匹配顺序为：<br>1.先匹配普通字符串，然后再匹配正则表达式。<br>2.一般情况下，匹配成功了普通字符串 location 后还会进行正则表达式的 location 匹配。当然有两种方法能够改变这种方式，一个是使用 = 进行绝对匹配，另一个则是使用 ^~ 前缀匹配，它在匹配到了普通字符 location 之后不会再去寻找正则匹配。<br>3.普通字符串匹配顺序是根据配置中的字符长度从长到短，也就是使用普通字符串的匹配顺序和 location 之间的先后顺序是无关的，最后 nginx 都会根据配置的字符长短来进行匹配。<br>4.正则表达式则是按照配置文件里的顺序来匹配，找到第一个匹配的正则表达式将停止搜索。</p>
<p>下面列举常见的几个匹配模式，在测试的过程中注意缓存的原因导致测试结果不正确，优先使用 Firefox 浏览器测试，Chrome 浏览器的缓存更严重。最好的还是每次测试访问时先清除一下缓存，这样才能保证我们的测试结果是正确的。还一个就是注意地址是否填写正确，不要在地址栏最后多出一个斜杠。最后就是我们所编辑的 nginx 配置文件一定要和我们启动的 nginx 配置文件一致。</p>
<h2 id="绝对匹配"><a href="#绝对匹配" class="headerlink" title="绝对匹配"></a>绝对匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;192.168.0.234:10080&#x2F;index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的绝对匹配只是简单的配置了一个代理，将当前路径代理到另外一个服务的首页。</p>
<h2 id="区分大小写的正则匹配"><a href="#区分大小写的正则匹配" class="headerlink" title="区分大小写的正则匹配"></a>区分大小写的正则匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ image &#123;</span><br><span class="line">    root &#x2F;home&#x2F;zhouxh&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置表示当用户访问 <a href="http://192.168.0.234:10080/image/test.jpg">http://192.168.0.234:10080/image/test.jpg</a> 时，将会转到当前服务的 /home/zhouxh/image/ 目录下去查找 test.jpg，也就是 <a href="http://192.168.0.234:10080/home/zhouxh/image/test.jpg%E3%80%82">http://192.168.0.234:10080/home/zhouxh/image/test.jpg。</a></p>
<h2 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line">    root &#x2F;home&#x2F;zhouxh&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于配置比较简单，上面的配置和上一个正则匹配的结果是一样的，只不过这里是通过普通的匹配方式匹配到 /image 这个 location。</p>
<h2 id="location-中的-root-和-alias-的区别"><a href="#location-中的-root-和-alias-的区别" class="headerlink" title="location 中的 root 和 alias 的区别"></a>location 中的 root 和 alias 的区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line">    root &#x2F;home&#x2F;zhouxh&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line">    alias &#x2F;home&#x2F;zhouxh&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个配置当用户访问 <a href="http://192.168.0.234:10080/image/test.jpg">http://192.168.0.234:10080/image/test.jpg</a> 时，访问的文件路径是不一样的，当使用 root 时路径为 <a href="http://192.168.0.234:10080/home/zhouxh/image/test.jpg%EF%BC%8C%E5%BD%93%E4%BD%BF%E7%94%A8">http://192.168.0.234:10080/home/zhouxh/image/test.jpg，当使用</a> alias 时路径为 <a href="http://192.168.0.234:10080/home/zhouxh/test.jpg%EF%BC%8C%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E">http://192.168.0.234:10080/home/zhouxh/test.jpg，两者的区别在于</a> root 是将实际访问文件路径即 root 后面的路径拼接 URL 中的路径，而 alias 是实际访问文件路径即 alias 后面的路径不去拼接 URL 中的路径。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 实现 TCP 代理及其负载均衡之 stream 模块</title>
    <url>/nginx-%E5%AE%9E%E7%8E%B0-TCP-%E4%BB%A3%E7%90%86%E5%8F%8A%E5%85%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8B-stream-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>前面所说的 nginx 负载均衡都是基于 HTTP 七层代理，有时候我们可能需要基于 TCP 四层代理以及负载均衡，在之前我们可能需要编译安装第三方的一个模块 nginx_tcp_proxy_module，并且需要打上一个补丁，具体安装方式可以去参考项目中的描述。</p>
<a id="more"></a>

<p>项目地址如下，不过需要注意的是安装这个模块存在兼容性问题，最好使用较低版本的 nginx 去安装，否则很容易出错，所以现在不推荐使用这个进行 TCP 代理。在 nginx 1.9.0 的版本以及更高的版本中，nginx 默认将 ngx_stream_core_module 模块编译进来了，该模块支持 TCP 代理及其负载均衡。下面就主要来介绍一下如何使用它来进行 TCP 代理和负载均衡。</p>
<p><a href="https://github.com/yaoweibin/nginx_tcp_proxy_module">nginx_tcp_proxy_module 项目地址</a></p>
<h2 id="ngx-stream-core-module-编译安装"><a href="#ngx-stream-core-module-编译安装" class="headerlink" title="ngx_stream_core_module 编译安装"></a>ngx_stream_core_module 编译安装</h2><p>由于 nginx 1.9.0 版本以及之后的版本默认将该模块集成进来了，所以我们不需要额外添加，我们只需要在配置时加上 –with-stream 参数来激活这个模块。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --with-stream</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="TCP-代理"><a href="#TCP-代理" class="headerlink" title="TCP 代理"></a>TCP 代理</h2><p>将 nginx 配置安装好了之后就可以在 nginx.conf 的配置文件中配置 TCP 代理了，其实也就是在配置文件在加一个和 http 模块平级的 stream 模块，其他配置大部分和 http 代理中的一样，下面是一个简单的 TCP 代理配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 50001;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass 192.168.1.110:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 50002;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是监听本机的 50001 和 50002 端口，并且将其分别代理到 192.168.1.110 和 192.168.1.111 的 10080 端口，而 10080 这个端口 分别是 192.168.1.110 和 192.168.1.111 的 nginx 访问端口，测试情况如下图：</p>
<p><img src="http://images.rookiezhou.top/tcp_proxy.png" alt="测试结果"></p>
<h2 id="TCP-负载均衡"><a href="#TCP-负载均衡" class="headerlink" title="TCP 负载均衡"></a>TCP 负载均衡</h2><p>基于 TCP 的负载均衡和 HTTP 的负载均衡配置大致一样，只不过负载均衡策略没有那么多，主要有默认的轮询，加权轮询，最少连接数，最低平均延时，hash 这五种方式，先声明以下测试是在 nginx 版本 1.12.0 上测试的。这里简单说一下我所遇到的坑，我刚开始是在 chrome 浏览器上测试的，发现测试这些策略都是不对的，而且始终访问到后台同一台服务，只是偶尔会变一下，然后使用 Firefox 浏览器测试，发现按 F5 刷新还是始终访问到同一后台服务，然后尝试着按 Ctrl + F5 进行刷新这才按照我们配置的策略进行负载，而回到 chrome 浏览器上也试着按 Ctrl + F5 刷新还是一直访问的后台同一台服务，暂时还不知道是什么原因。有知道的可以告诉我一下，不甚感激。</p>
<p>1.默认配置 ( 轮询 )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的配置就是不加任何负载策略，采用默认的方式，默认的方式就是轮询的方式。</p>
<p>2.加权轮询配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        server 192.168.1.110:10080 weight&#x3D;3;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在轮询策略的基础上给每个后台服务加上权重，权重越大，访问的概率越大，像上面的配置的话就是每访问三次 192.168.1.110 这台服务就会访问一次 192.168.1.111 这台服务。</p>
<p>3.最少连接数配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是采用一种固定的负载策略，最少连接数策略，也就是选择连接数最少的后台服务。</p>
<p>4.最低平均延时配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        least_time connect;</span><br><span class="line">        #least_time first_byte;</span><br><span class="line">        #least_time last_byte;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面策略配置表示的是对于每个请求，可通过最低平均延时来选择后台服务，而这个最低平均延时则是看 least_time 指令中指定的参数计算出来的，主要有下面三个参数：</p>
<ul>
<li>connect：连接到后台服务花的时间</li>
<li>first_byte：接收到第一个字节花的时间</li>
<li>last_byte：接收到最后一个字节花的时间，也就是全部接收完的时间</li>
</ul>
<p>值得注意的是该策略现在是作为 nginx 商业订阅的一部分提供，也就是需要花钱才能够实现这个功能。</p>
<p>5.hash 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        hash $remote_addr consistent;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面采用的是 hash 算法策略，对客户端的 IP 进行 hash，让每台客户端固定访问到后台的一台服务。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 的正向代理和反向代理</title>
    <url>/nginx-%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>nginx 服务器在我们平常的软件开发中可能还是用到的比较多的，那么有一个问题我们就应该明白，也许让你去实现轻而易举，但说到其中的原理就有点不是很清楚了。下面就谈谈我自己对正向代理和反向代理的理解：首先有一个用户 C，三台服务器 S1，S2 和 S3，S1，S2，S3 在同一局域网内互相可访问，但 S1 对外网开放，S2 和 S3 不对外网开放，还有一份数据资源 D，资源 D 放在服务器 S2 和 S3 上。</p>
<a id="more"></a>

<h2 id="nginx-正向代理"><a href="#nginx-正向代理" class="headerlink" title="nginx 正向代理"></a>nginx 正向代理</h2><p>这时用户 C 明确知道自己想访问的数据资源 D 在服务器 S2 上，用户 C 想要访问这份资源但是没办法直接访问服务器 S2，用户 C 想到服务器 S1 和 S2 在同一局域网并且互相可访问，而自己能够访问服务器 S1，所以用户 C 就通过服务器 S1 去访问服务器 S2 上的资源 D。那么正向代理就是对于用户 C 来说他是明确知道他要访问的数据资源 D 在哪个服务器上；对于服务器 S1 来说他只充当了用户 C 的中间代理角色；而对于服务器 S2 来说他只知道访问他的资源的是服务器 S1，根本不知道用户 C 的存在。</p>
<p>正向代理的整个流程就是用户 C 访问服务器 S2 上的数据资源 D，但是是通过借助服务器 S1 来进行访问，服务器 S1 得到数据资源后再返回给用户 C。</p>
<h2 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h2><p>还是刚开始上面说的这些：用户 C，服务器 S1，S2 和 S3，以及服务器 S2 和 S3 上的数据资源 D。这时用户 C 并不知道数据资源 D 在服务器 S2 和 S3 上面，他只知道访问服务器 S1 可以得到自己想要的内容，于是他每次都是直接访问服务器 S1，只不过提供给用户 C 数据资源的都是服务器 S2 或者 S3。那么反向代理就是对于用户 C 来说他是不知道数据资源 D 具体在哪里，是由谁提供的；对于服务器 S1 来说每次都接收用户的请求，然后再把请求交给真正能提供资源的服务器 S2 或 S3；对于服务器 S2 和 S3 来说同样也都不知道访问这份资源的真实用户是谁，只是和服务器 S1 进行交互。</p>
<p>反向代理的整个流程就是用户 C 访问服务器 S1 获取数据资源 D，服务器 S1 将请求转交给服务器 S2 或 S3，然后得到相应的资源后再返回给用户 C。</p>
<p>总之，正向代理就是客户端知道服务器端，带过代理连接服务器端。反向代理就是客户端不知道服务器端，通过代理连接服务器端，具体是由哪个服务器端提供服务取决于代理的调度方式，即 nginx 中的负载均衡策略。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 负载均衡策略之内置策略</title>
    <url>/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B9%8B%E5%86%85%E7%BD%AE%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>nginx 服务器在开发中我们用的比较多的有 nginx 的负载均衡，nginx 负载均衡主要是利用反向代理来实现，也就是表面上我们访问的是这个服务，其实访问的是该服务背后支撑的众多服务器中的其中一台。比如说全世界同一时间有这么多人同时在访问百度这个网站，它是怎么能够承受的住这么大的访问量呢，这时我们就应该知道其实百度这个网站的背后有很多的服务器在支撑着众多的用户的访问。</p>
<a id="more"></a>

<p>但是这里就引出一个问题，用户访问的这个服务是如何分发给它背后的众多的服务器呢，于是就出现了满足各种需求的负载均衡策略，其中有 nginx 自己内置的负载均衡策略，也有第三方提供的一些负载均衡策略。今天主要谈一下 nginx 内置的负载均衡策略，主要有四种：轮询（默认）、加权轮询、最少连接 least_conn、IP 哈希 ip_hash，下面将一一进行介绍。</p>
<p>首先我们先安装好 nginx 服务器，下面是在 Ubuntu 16.04 系统测试的，采用的 nginx 版本是 nginx/1.12.0。</p>
<h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p>下载基于 Linux 系统的 nginx/1.12.0 版的 nginx 服务器进行解压编译安装，下面是安装命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.12.0.tar.gz</span><br><span class="line">sudo tar xzf nginx-1.12.0.tar.gz</span><br><span class="line">cd nginx-1.12.0</span><br><span class="line">sudo .&#x2F;configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>上面安装成功后，nginx 默认安装在目录 /usr/local/nginx/ 下面，当然你也可以自定义安装目录，不过一般不建议这么做，以防以后都不知道到哪里去找配置文件，默认就好，安装成功后可以在 /usr/sbin/ 目录下创建一个软链接指向 /usr/local/nginx/sbin/nginx 文件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>这样我们就不用每次启动 nginx 服务都切换到 /usr/local/nginx/sbin/ 目录下去执行 nginx 的启动命令，配置好了这些后就可以启动 nginx 服务器进行测试了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf </span><br></pre></td></tr></table></figure>

<p>执行上面的启动命令后在浏览器中输入 localhost 后回车出现对应的 nginx 服务器的欢迎页面就表示 nginx 服务器安装成功了，这里我们为了更好的测试首先将 nginx.conf 配置文件中 http 的默认端口 80 改成 10080，改了之后重新启动 nginx 服务器后接着在浏览器中输入 localhost:10080 后回车应该又会出现刚才的欢迎页面了。接下来就开始我们的 nginx 的负载均衡策略之旅吧。</p>
<h2 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h2><p>轮询这个策略是 nginx 进行负载均衡时默认采用的策略，也就是最基本的负载均衡配置，打开 /usr/local/nginx/conf/ 目录下的 nginx.conf 配置文件，我们配置一个最简单的负载均衡方式，在配置文件中 http 模块里面也就是和 http 模块里面的 server 模块同级加上以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 http 模块里面的 server 模块下面的 location 模块加上一行配置，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;loadserver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>部分配置文件截图如下：</p>
<p><img src="http://images.rookiezhou.top/polling.png" alt="轮询策略配置"></p>
<p>这样也就配置好了最基本的负载均衡，默认采用轮询的策略将请求分发给后台服务器，当我们访问 localhost:10080 这个地址时页面轮流的展示 192.168.1.110 和 192.168.1.111 这两台主机的 nginx 服务器的欢迎页面，这里为了区分这两个欢迎页面需要修改一下这两台主机的 nginx 服务器的欢迎页面信息，欢迎页面默认存放在 /usr/local/nginx/html/ 目录下的 index.html 页面。我们只要稍微修改一下这两台主机的 nginx 欢迎页面使得每次访问的页面都是不同的，便于我们区分访问的是哪台主机的 nginx 服务器。</p>
<h2 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h2><p>加权轮询则是在第一种轮询的基础上对后台的每台服务赋予权重，服务器的权重比例越大，被分发到的概率也就越大，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    server 192.168.1.110:10080 weight&#x3D;3;</span><br><span class="line">    server 192.168.1.111:10080 weight&#x3D;1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是给每个后台服务加上了一个权重比例，拿上面的配置举例：用户将会每访问三次 192.168.1.110 这个服务访问一次 192.168.1.111 这个服务。这种适合后台的各个服务的性能不一样，这时我们就可以将性能好的服务器权重设置大一些，减轻一些性能不怎么样的服务器的压力。</p>
<h2 id="最少连接-least-conn"><a href="#最少连接-least-conn" class="headerlink" title="最少连接 least_conn"></a>最少连接 least_conn</h2><p>最少连接是每次请求都将请求分发给后台服务连接数最少的那台服务上，当然如果每台服务还配置了权重，那么这时会取连接数和权重比值最小的那台服务，如果连接数和权重的比值都相同的话就会采取轮询的方式进行分发，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置只是加了一个调度策略 least_conn，其他和轮询的方式一样，当然你也可以给每台服务加上权重比例，分发时就会选择 conn / weight 值最小的那台服务，这种方式适合请求处理时间长短不一造成服务器过载的情况。</p>
<h2 id="IP-哈希-ip-hash"><a href="#IP-哈希-ip-hash" class="headerlink" title="IP 哈希 ip_hash"></a>IP 哈希 ip_hash</h2><p>ip_hash 这种负载策略是根据客户端的 IP 地址的 hash 结果来进行分发，这样的话能够确保每个访客访问后端固定的一台服务器，这种情况对于需要保存用户的 session 信息的应用就很方便了，它避免了同一个用户访问到不同的服务器上产生 session 共享的问题。配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置只是加了一个调度策略 ip_hash，其他也和轮询的方式一样，这里你也可以给每台服务加上权重比例，分发时在该客户端 IP 第一次访问时就会优先选择 weight 值最大的那台服务。</p>
<h2 id="其他配置说明"><a href="#其他配置说明" class="headerlink" title="其他配置说明"></a>其他配置说明</h2><p>其实每个后台服务器的配置除了权重 weight 还有一些配置，比如说下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.1.110:10080 weight&#x3D;5 ;</span><br><span class="line">    server 192.168.1.111:10080 weight&#x3D;1;</span><br><span class="line">    server 192.168.1.112:10080 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;</span><br><span class="line">    server 192.168.1.113:10080 down;</span><br><span class="line">    server 192.168.1.114:10080 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置说明：<br>1.weight 的值默认为1，weight 越大，服务器负载的权重就越大，访问的概率越高。<br>2.down 表示当前服务器暂时不参与负载。<br>3.backup 表示其它所有的非 backup 服务器 down 或者忙的时候才会请求 backup 服务器，所以这台服务器压力最轻，一般这台服务器当做是备用服务器。<br>3.max_fails 表示允许请求失败的次数，默认为 1，当超过最大次数时，返回proxy_next_upstream 模块定义错误。<br>4.fail_timeout 表示每次失败后暂停的时间。</p>
<p>到这里就全部介绍完了 nginx 负载均衡内置的一些策略，还有第三方扩展的一些策略，未完待续………</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>zookeeper 单机模式以及伪集群模式搭建</title>
    <url>/zookeeper-%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>首先说一下我对 <code>zookeeper</code> 的学习，在刚开始听的时候觉得很高大上，但又觉得很陌生，也不知道是干嘛的，然后就网上查各种资料开始慢慢对 <code>zookeeper</code> 好像有点感觉了，又好像还是似懂非懂的样子，然后还看到网上都在告诉我们 <code>zookeeper</code> 的安装以及 <code>zookeeper</code> 集群的搭建，又尝试着去搭建了一遍。到最后还是有点晕乎乎的样子，总觉得好像不是很理解，包括网上说的 <code>zookeeper</code> 一些使用场景。</p>
<a id="more"></a>

<p>通过这些过程下来，我有点觉得刚开始既然不是很理解，那么就先不去理解它，不要尝试着钻牛角尖，为何不先试着在实践中动手接触它，感受它，在这之后有点感觉之后我们再去理解 <code>zookeeper</code> 背后的那些原理会不会更好一点呢？当然这只是个人看法，因人而异，如果有类似感觉的不防这样试试。那么接下来我就先说说 <code>zookeeper</code> 的安装以及搭建过程。</p>
<h2 id="zookeeper-下载解压"><a href="#zookeeper-下载解压" class="headerlink" title="zookeeper 下载解压"></a>zookeeper 下载解压</h2><p>在测试之前先说一下，zookeeper 的运行需要依赖 Java 运行环境，所以先要保证你安装好了 Java 环境。接下来下载 zookeeper 的最新稳定版 <code>zookeeper-3.4.12</code> 进行测试，下载链接如下：</p>
<p><a href="http://mirrors.shu.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz">zookeeper-3.4.12 下载链接</a></p>
<p>由于本人使用的是 Ubuntu 16.04 系统版本，所以下面的测试也是基于该系统下进行测试的，当然在 Window 系统下步骤也是一样的，只是执行的方式不一样而已。将上面下载好的文件进行解压，最好解压到你常用的安装软件目录下，以便后面查找 zookeeper 配置文件的位置，当然如果说你知道你自己所放的位置那也无所谓了，当然我还是比较推荐把我们平常开发中常用的软件单独建一个文件夹保存，这样可以让我们的电脑文件不会显得很乱，后面的查找效率也会高很多。回到正题，下面是 zookeeper 的解压命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzvf zookeeper-3.4.12.tar.gz -C &#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="zookeeper-单机搭建"><a href="#zookeeper-单机搭建" class="headerlink" title="zookeeper 单机搭建"></a>zookeeper 单机搭建</h2><p>解压好之后，记住你解压之后存放的位置，比如我上面，我存放在 /home/zhouxh/software/ 目录下面，接下来就切到该目录下的 zookeeper-3.4.12 目录下，里面有一个 conf 的目录，继续 cd 到 conf 目录下，这个目录存放的就是 zookeeper 运行时需要的配置文件，这里我们先将里面的 zoo_sample.cfg 文件拷贝一份并且重命名为 zoo.cfg，然后编辑 zoo.cfg 文件，这里我们先不说文件中的各项配置是什么含义，先照着做就可以了，到后面会详细解释，打开 zoo.cfg 文件，在里面修改 dataDir 配置然后再加上 dataLogDir 配置，该文件的全部配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">#dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper</span><br><span class="line">dataDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;logs</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br></pre></td></tr></table></figure>

<p>上面配置文件中修改和添加的这两项配置都有一个路径，也就是刚才解压的 zookeeper 文件所在路径，在 zookeeper 的目录下创建两个文件夹：data 和 logs，创建好之后单机模式的 zookeeper 文件配置就已经配置好了，然后我们就可以运行了，为了运行方便，最好我们把 zookeeper 命令路径配置到环境变量中去，这样我们就不用每次执行都切换到 zookeeper 目录下的 bin 目录中去，如果没配那就到 zookeeper 的 bin 目录下去执行命令，启动命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>启动完成之后再执行查看 zookeeper 的运行状态的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh status</span><br></pre></td></tr></table></figure>

<p><img src="http://images.rookiezhou.top/zk-start.png" alt="运行结果如下"></p>
<p>也可以通过客户端命令来连接 zookeeper 服务来判断是否启动成功，如果是 zookeeper 是在本机上那么直接执行以下命令就好：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh</span><br></pre></td></tr></table></figure>
<p>如果是跨机器连接的话则需要加参数，-server 后面加上要连的服务 IP 和端口，IP 是你要连的 zookeeper 服务所在机器的 IP，端口就是刚才 zoo.cfg 中的 clientPort=2181 配置的端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure>

<p><img src="http://images.rookiezhou.top/zoo-cli.png" alt="运行结果如下"></p>
<p>连接成功之后我们就可以对 zookeeper 服务上的节点以及节点中的数据进行增删改查了，这里提一下，zookeeper 中的节点结构类似于 Linux 系统下的文件路径，都是树形结构。到这里单机模式的搭建就已经完了，接下来我们再尝试着搭建 zookeeper 伪集群模式。</p>
<h2 id="zookeeper-伪集群搭建"><a href="#zookeeper-伪集群搭建" class="headerlink" title="zookeeper 伪集群搭建"></a>zookeeper 伪集群搭建</h2><p>有了之前单机模式下搭建过程，伪集群其实也差不多，之所以说是伪集群，是因为是在同一台电脑上模拟出来的多台服务，这里以三台为例进行模拟搭建，当然如果你条件够宽裕，也可以直接在三台电脑上进行搭建，当然这三台电脑需要互相可访问，因为他们之间需要通信。下面是在单台电脑上搭建伪集群的过程：</p>
<p>首先我们将之前用到的 zoo.cfg 拷贝三份放在 conf 目录下，分别命名为 zoo1.cfg，zoo2.cfg，zoo3.cfg，然后分别修改这三个文件，下面我先贴出第一个服务 zoo1.cfg 的配置内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data1</span><br><span class="line">dataLogDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log1</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line">server.1&#x3D;192.168.1.108:2881:3881</span><br><span class="line">server.2&#x3D;192.168.1.108:2882:3882</span><br><span class="line">server.3&#x3D;192.168.1.108:2883:3883</span><br></pre></td></tr></table></figure>
<p>其他两个文件只需要修改其中一个客户端端口和两个路径就好，其他的和上面配置内容一致。<br>zoo2.cfg 不同部分配置内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data2</span><br><span class="line">dataLogDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log2</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2182</span><br></pre></td></tr></table></figure>
<p>zoo3.cfg 不同部分配置内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data3</span><br><span class="line">dataLogDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log3</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2183</span><br></pre></td></tr></table></figure>

<p>看了上面三个文件的配置内容，我们应该能猜到接下来我们还需要在对应路径下创建几个文件夹，分别是：data1，data2，data3 以及 log1，log2，log3，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data1</span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data2</span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data3</span><br><span class="line"></span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log1</span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log2</span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log3</span><br></pre></td></tr></table></figure>
<p>同时我们还注意到每个配置文件都多了一小部分内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.1&#x3D;192.168.1.108:2881:3881</span><br><span class="line">server.2&#x3D;192.168.1.108:2882:3882</span><br><span class="line">server.3&#x3D;192.168.1.108:2883:3883</span><br></pre></td></tr></table></figure>
<p>这部分内容中 server 后面的那个数字是区分各个不同服务的，这个数字还需要在我们刚才新建的那三个文件夹 data1，data2，data3 下面分别新建三个文件，文件名为 myid，这个文件就只写入这个数字就好，也就是 data1 目录下的文件 myid 内容为 1，data2 目录下的文件 myid 内容为 2，data3 目录下的文件 myid 内容为 3，当然如果是三台不同的机器的话，就是把刚才创建三份的文件夹以及文件在每台机器上配置一份就好，内容可以不变，端口那些可以自己定，也可以完全按照上面的方式配置。到这里配置部分就结束了，接下来我们就可以测试我们的配置是否正确了。</p>
<p>首先我们依次将三个 zookeeper 服务分别启动起来，每启动一台查看一下当前启动的 zookeeper 的运行状态，切换到 zookeeper 的 bin 目录下进行启动，启动命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh start ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo1.cfg</span><br><span class="line">.&#x2F;zkServer.sh status ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo1.cfg</span><br></pre></td></tr></table></figure>
<p>上面将第一台 zookeeper 服务先启动，启动后紧接着查看其运行状态发现会报如下一个错。</p>
<p><img src="http://images.rookiezhou.top/zoo1-start.png" alt="运行结果如下"></p>
<p>这是由于其他两台还没启动，所以我们先不管，继续启动另外两台服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh start ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo2.cfg</span><br><span class="line">.&#x2F;zkServer.sh status ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo1.cfg</span><br><span class="line"></span><br><span class="line">.&#x2F;zkServer.sh start ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo3.cfg</span><br><span class="line">.&#x2F;zkServer.sh status ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo3.cfg</span><br></pre></td></tr></table></figure>
<p>不出意外的话，当启动第二台后再查看第一台服务状态时会打印如下信息：</p>
<p><img src="http://images.rookiezhou.top/zoo2-start.png" alt="运行结果如下"></p>
<p>这表明我们已经启动成功了，继续启动第三台就好，当三台全部启动成功后说明我们的伪集群搭建成功了。</p>
<p>我们也可以尝试用 zkCli.sh 命令去连接这个集群看看能不能连上，由于这三台已经是集群模式，我们任意连接其中一台都是一样的，以连接第一台为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<p>出现如下信息表示连接成功:</p>
<p><img src="http://images.rookiezhou.top/zoo-client.png" alt="运行结果如下"></p>
<p>上面就是我们搭建的整个过程，搭建完成后最好回顾一下，如果中间遇到什么问题可以直接网上搜索，肯定能找到的，现在我们只是初步了解了 zookeeper 服务的搭建过程，具体这些配置文件中的含义以及为什么要搭建集群，为什么选择三台进行模拟集群，这样做有什么好处；还有就是 zookeeper 到底应该怎么用，哪些情况下需要用到 zookeeper，下一篇将会详细介绍。</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 负载均衡策略之第三方扩展策略</title>
    <url>/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>之前已经将 nginx 负载均衡中的内置策略介绍完了，下面我们来看一下第三方的扩展策略，所谓的内置策略其实就是 nginx 安装后就已经自带了，对于第三方的一些策略则是需要我们在安装时要额外添加第三方的模块才能实现。下面就一一进行介绍：</p>
<a id="more"></a>

<h2 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h2><p>该策略将前端请求的 url 地址进行 hash，根据 hash 结果将请求定向到同一后端服务器节点上，这种适合后台服务器为缓存时比较有效，一般也会配合缓冲命中来使用。</p>
<p>刚才也说了第三方策略需要额外添加第三方模块才能实现，所以我们需要对我们的 nginx 进行重新编译安装，下面是添加第三方模块编译安装的命令，但要注意的是这个第三方模块需要我们提前下载好，下面命令中的路径就是我下载的模块所在路径。url_hash 策略需要的第三方模块是 ngx_http_consistent_hash，这个可以在 nginx 第三方模块网站中找到该项目的 github 地址，这里贴出地址：</p>
<p><a href="https://www.nginx.com/resources/wiki/modules/">nginx 第三方模块网站</a><br><a href="https://github.com/replay/ngx_http_consistent_hash">ngx_http_consistent_hash 项目地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;ngx_http_consistent_hash</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>然后还是在之前我们添加的 upstream 中加上对应的策略，配置如下，不清楚的可以参考上一篇的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    consistent_hash $request_uri;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置加了一个调度策略：一致性哈希 consistent_hash，对客户端请求的 url 进行哈希，既然这里采用 url_hash 的策略来进行负载，那么对于后面再进行权重配置就没有多大意义了，所以后面就不必再添加 weight 权重配置了。</p>
<h2 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h2><p>这个策略按后端服务器的响应时间来分配请求，响应时间短的优先分配，但在实际项目中，响应时间受很多的因素所影响，所以真正采用这种方式进行负载需慎重。同样的先下载 fair 策略对应的第三方模块 nginx-upstream-fair，再对我们的 nginx 进行重新编译安装，nginx-upstream-fair 项目地址如下：</p>
<p><a href="https://github.com/itoffshore/nginx-upstream-fair">nginx-upstream-fair 项目地址</a></p>
<p>这个项目其实并不是第三方模块网站中找到的那个 nginx-upstream-fair 项目，那个项目我使用 nginx-1.12.0 版本的 nginx 编译出错，于是看到那个项目中也有人遇到这个问题，他推荐的是另一个 nginx-upstream-fair 项目，也就是上面贴出来的那个，编译正常通过，基于 nginx-1.12.0 版本的 nginx 亲测可用。<br>编译安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;ngx_http_consistent_hash --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;nginx-upstream-fair</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>配置也是一样的，只是需要改变一下策略名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    fair;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>该策略是在多台服务器的环境下，确保一个客户端只和一台服务器通讯，它会保持长连接，并在结束会话后再次选择一个服务器，保证了压力均衡。同样的我们先下载 fair 策略对应的第三方模块 nginx-upstream-fair，再对我们的 nginx 进行重新编译安装，nginx-upstream-fair 模块在第三方模块网站中能够找到直接下载：</p>
<p><a href="https://www.nginx.com/resources/wiki/modules/">nginx 第三方模块网站</a></p>
<p>编译安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;ngx_http_consistent_hash --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;nginx-upstream-fair --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;nginx-sticky-module-ng</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>配置也是一样的，需要改变一下策略名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    sticky;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：由于整个模块是通过 cookie 实现，如果浏览器不支持 cookie，那么 sticky 不生效。</p>
<p>到这里 nginx 负载均衡一些扩展的第三方策略也全部介绍完了 ，有点要提醒的是以上都是基于 HTTP 七层负载均衡，还有一个是 TCP 四层负载均衡，接下来会有介绍。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>你还在习惯的使用 keys * 查看 redis 中的所有数据吗</title>
    <url>/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BD%BF%E7%94%A8-keys-%E6%9F%A5%E7%9C%8B-redis-%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%90%97/</url>
    <content><![CDATA[<p>redis 在我们的日常开发中其实还是用的比较多的，常用来做缓存或者存放一些热点数据，主要为了提高系统的响应速度。在我们平常使用中，我们可能都习惯的使用 keys * 命令来查询数据库中的数据存储情况。</p>
<p>这时也许我们都是在开发环境执行，开发环境 redis 中的数据量不是很多，redis 也很快的能给我们响应。但是如果你要查询的 redis 中存储了非常大的数据量，这时候你还能愉快的使用这个命令吗？</p>
<p>首先，我们来大概了解下 keys 命令是用来干嘛的，它是用来查找所有符合给定模式 pattern 的 key ，上面的 * 表示匹配所有数据，同时还有下面几种用法:</p>
<a id="more"></a>
<ul>
<li>keys re?is 匹配 redis，recis</li>
<li>keys re*is 匹配 redis, reddddis</li>
<li>keys re[cd]is 匹配 redis，recis，不匹配 reais，reddis</li>
</ul>
<p>keys 命令的时间复杂度是 O(N)，N 是 redis 库中的数据量，也就是说这个命令的执行时间是随着库中的数据量增多呈正比的，数据量越大，执行时间越长。所以尽管这个命令的速度很快，但如果是一个数据量很大的库，还是会造成性能问题的。</p>
<p>我之前就在一次项目上线演练时，当时在一个 redis 库中初始化一批数据，当时我为了验证数据库中是否已经初始化过了这些数据，我顺手就敲了一个 keys abc*，其中 abc 是我要初始化的这批数据的 key 前缀(当然不是真的就是 abc，这里是随便起的一个)。</p>
<p>然后并没有像往常开发中一样很快给我响应，我立马就意识到不对了，这个 redis 库数据量很大，不能使用 keys 命令去查询，我随即立马按下 command + c 尝试终止，但其实已经没什么用了，因为 redis 已经在执行我刚才发送的命令，终端已经没响应，我记得我我当时还索性把终端都给关了，这纯属病急乱投医了。</p>
<p>随后呢我另起一个终端，尝试连接 redis，看看刚才的命令是否执行完了，但不幸的是我连都连不上，连接命令敲完没反应，当时这会心里真的慌了。</p>
<p>不过幸运的是这只是一次新系统正式上线前的演练，而且并没有用户在使用。至于为什么没有用户在用怎么有这么多数据在里面，那是因为在我初始化我这批数据之前，我同事已经将老系统中的数据迁移过来了。</p>
<p>但我还是很慌的原因是我具体不知道老系统迁移过来有多少数据，只知道数据量很大，不知道要执行多久。然后虽然说那只是新系统正式上线前一次演练而已，但是我们这次上线是有很多流程，所以才有了这次演练。</p>
<p>对于流程中的每个环节都要记录操作时间，下次正式上线时需要按之前演练上线的流程来执行，正式上线时如果某一环节出问题了，就要采取回滚流程进行回滚，下次上线要是因为我这个数据初始化环节出问题了，那这锅岂不背定了。</p>
<p>所以说当时真的是慌的一匹，但最后还是过了两三分钟之后我重新连上了，此时应该是将我刚才的命令执行完了，随后我也不管里面是不是已经初始化了，直接初始化数据，大不了覆盖好了，反正 key 是相同的，因为这部分数据只有我的程序要用到，所以没什么问题。后面正式上线时有了演练的教训，也就没有出啥问题，也没有再作死去敲 keys 命令了。</p>
<p>如果我们真的要在大数据量的 redis 库中查询匹配的数据怎么办呢？其实 redis 是有相应的替代命令的，就是 scan 命令，以及对应的数据类型的 sscan，hscan 和 zscan，他们都用于增量地迭代库中的元素。</p>
<ul>
<li>scan 命令用于迭代当前库中的所有 key</li>
<li>sscan 命令用于迭代集合键中的元素</li>
<li>hscan 命令用于哈希键中的键值对</li>
<li>zscan 命令用于迭代有序集合中的元素(包括元素成员和元素分值)</li>
</ul>
<p>上面的命令都是支持增量式迭代，每次执行都只会返回少量元素，这些命令每次执行的时间复杂度是 O(1)，完整的一次迭代过程才是 O(N)，因此它是可以在生产环境中执行的，而不会像 keys 命令一样，如果正在处理的是一个大数据量的库，会阻塞 redis 服务很久。</p>
<p>scan 命令它是一个基于游标的迭代器(cursor based iterator)，scan 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 scan 命令的游标参数， 以此来延续之前的迭代过程。当 scan 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示一次完整的迭代过程结束。</p>
<p>scan 命令是迭代库中所有的 key，基本使用方式是: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count] </span><br></pre></td></tr></table></figure>

<p>而 sscan 命令、 hscan 命令和 zscan 命令的第一个参数是一个数据库键:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SSCAN/HSCAN/ZSCAN key cursor [MATCH pattern] [COUNT count] </span><br></pre></td></tr></table></figure>

<p>cursor 就是游标参数，初始我们可以设置 0，开始一次迭代过程，一次迭代后的返回值作为下次迭代的游标值，当我们看到 redis 的返回值是 0 时，意味着完整的迭代过程结束。</p>
<p>看到这里你应该能发现，如果在迭代的中间过程中，redis 的数据发生了变化，那么我们得到的数据可能是不正确的，这是无法得到保证的。</p>
<p>而 scan 命令只会给我们保证在整个遍历过程中，一直存在于数据集中的元素都会被遍历返回，也就是说，如果一个元素如果在遍历开始到结束都存在于要遍历的数据集中，那么这个元素肯定会在某一次迭代过程中得到返回。</p>
<p>后面两个中括号中的参数是可选的，可通过 match 来指定只返回匹配对应模式的元素，而 count 可以指定每次迭代返回的元素最大数量，默认值是 10。</p>
<p>但要注意虽然指定了返回的元素最大数量，这个 count 参数只是用户给 scan 迭代命令的一种提示，尽管这种提示在很多情况下是有效的，但也要注意不一定每次都是返回指定的数量，有可能会比指定的要多一些。</p>
<p>对于 scan 以及其相关的 sscan，hscan，zscan 命令都会返回两个元素，第一个元素是下次迭代的初始游标，第二个元素是本次迭代返回的结果。</p>
<ul>
<li>scan 得到的结果是库中键元素 key</li>
<li>sscan 得到的结果是集合中的成员</li>
<li>hscan 得到的结果是键值对</li>
<li>zscan 得到的结果是有序元素集合，集合中元素由一个成员和一个分值组成。</li>
</ul>
<p>上面就是 scan 命令的大体介绍，我是觉得这个命令其实很适合清理 redis 中无效数据，通过 scan 命令扫一遍 redis 库，很容易就做到数据清理的工作。</p>
<p>后来想想那次小事故其实就是因为自己平时用 keys 命令用习惯了，也没多想不假思索随手就敲下去了。所以说我们在日常 redis 的使用中，不能只是简单的就想也不想的就直接 keys 命令敲下去，长期以往会出事故的，我还好不是在线上使用的系统中执行的这个命令，不然后果真的很严重。</p>
<p>试想如果是在线上，在 redis 阻塞的那段时间，系统的访问请求继续打到 redis 服务器上，导致 redis 服务器 CPU 直接飙涨，很有可能服务器就直接宕机了，再进一步的话，程序无法从 redis 中获取数据，所有的请求都直接一下全到数据库去了，也有可能造成数据库直接挂了。</p>
<p>所以说我们应该养成这样的习惯，在需要用 keys 查询 redis 中的数据时，脑海里先确认下当时的环境以及库中的数据量大小。</p>
<p>当然 redis 不仅仅是只有 keys 这一个比较危险的命令，还有 hgetall，lrange，smembers，zrange 等命令，这些命令的时间复杂度都是 O(N)，使用这些命令都需要注意 N 的大小。当然其实线上对于 keys，flushdb，flushall 这几个命令最好是通过配置文件 redis.conf 来直接禁用它，以防万一。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Docker 运行 MySQL 服务</title>
    <url>/%E4%BD%BF%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-MySQL-%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>对于 MySQL 数据库，我们基本上都用得到，在工作上有些情况下不太想连云上的库，比如说网络比较慢，或者我们只是刚开始开发，还没来得及在云上建立数据库，这时候在本地跑一下 MySQL 服务也许比较方便，但是呢 MySQL 安装下来占的内存还是比较大的，像我们不是经常连本地的库开发的在本地电脑安装一个 MySQL 确实有点浪费空间了，再加上可能本来笔记本电脑内存就不是非常富余的情况下再去安装，实在是有些肉疼。</p>
<a id="more"></a>

<p>这时候我们就可以通过 Docker 启动一个 MySQL 容器来运行 MySQL 服务，在我们需要的时候启动容器就好，不需要的时候直接关了，这样就不用在本机上安装 MySQL，而且在需要别的软件的时候也可以通过 Docker 启动容器的方式去运行，这样我们自己的电脑就会看起来非常清爽，不会有各种软件充斥着你的电脑，专注我们正在做的事情。</p>
<p>首先，我们需要在本地安装 Docker，Docker 的安装很简单，可以在这里 <a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a> 下载对应系统的 Docker 软件进行安装，安装完毕之后，就可以从 Docker Hub 上拉取相应的镜像了。Docker Hub 网站是 Docker 提供的一项服务，主要用于查找和共享容器镜像，有点类似于 GitHub，不同的是 GitHub 维护的主要是代码，而 Docker Hub 维护的是主要是容器镜像。<br>声明: 由于我本地环境是 Mac 环境，下面命令和软件都是基于 Mac 下运行的。<br>安装好了之后可以在终端运行下面的命令看看是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>

<p>如果打印出了 Docker 的版本信息就可以了。接下来继续执行 docker images 命令查看本地有哪些镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>如果刚安装，之前没有从网站拉过镜像的话，打印出来的镜像应该是空的，我这里是已经拉过一些镜像了。由于我们要运行 MySQL，我们需要从 Docker Hub 上拉取 mysql-server 镜像, 执行一下命令拉取 mysql-server 的最新版镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql/mysql-server</span><br></pre></td></tr></table></figure>

<p>这时候如果你们没有配置镜像源地址的话，默认是国外的地址，会觉得很慢，这个我们可以通过配置国内的镜像源来解决。<br>打开 preferences -&gt; Docker Engine， 在右边配置框里面加上国内镜像源的配置，然后 Apply &amp; Restart ，待重启完毕后，可以执行下面的 docker info 命令验证是否添加成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>上面的第一行是我在阿里云里面申请的一个镜像地址，这个自己注册了阿里云账号的话也可以去申请一个，后面两个分别是国内的科大和网易的镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://docker.mirrors.ustc.edu.cn/</span><br><span class="line">https://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure>

<p>添加成功之后再去终端执行 docker pull mysql/mysql-serve 命令会感觉拉取速度快了许多。待镜像下载完毕之后就可以根据镜像来启动容器了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3307:3306 --name mysql-service mysql/mysql-server</span><br></pre></td></tr></table></figure>

<p>执行完命令之后，如果执行成功应该会有很长一串的 ID 打印出来，这是启动的容器 ID，后期可以通过这个 ID 来对容器执行启动，停止，重启，删除，查看日志，进入容器等一些列操作。我们可以通过 docker ps 命令来查看本地正在运行的容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>可以看到 STATUS 那一栏，health 状态处于 starting 状态，待状态变成 healthy 之后，说明容器启动完成，接下来就可以使用了，不过我们是不是还不知道 mysql 的 root 连接密码，我们需要通过查看容器的启动日志得到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 1d0da81a71ec 2&gt;&amp;1 | grep GENERATED</span><br></pre></td></tr></table></figure>

<p>执行命令之后可以看到容器启动的日志中生成了一个密码，不过这个密码只是一个临时的密码，通过这个密码连接到数据库之后，还是需要修改密码之后才能继续操作数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 1d0da81a71ec mysql -uroot -p</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;root&#x27;;</span><br></pre></td></tr></table></figure>

<p>上面我们是通过进入到容器内执行 mysql 命令连接 MySQL 服务，如果想要在宿主机上连接容器内的 MySQL 服务，首先需要配置 root 用户能够通过 IP 进行远程连接，连上数据库修改 root 用户的 host 字段。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select user, host from mysql.user;</span><br><span class="line">update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>修改成功之后就可以在宿主机上通过 IP 以及映射到宿主机的端口号连接容器内的 MySQL 数据库了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3307 -uroot -p</span><br></pre></td></tr></table></figure>

<p>到这里我们发现有个问题就是，每次启动之后需要查看日志获取密码，其实我们可以通过参数 -e MYSQL_ROOT_PASSWORD=password 来指定 root 用户的密码，这样我们就不用启动后再去查看日志获取密码，以及需要修改密码之后才能继续操作数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root --name mysql-service mysql/mysql-server</span><br></pre></td></tr></table></figure>

<p>这时候如果我们使用完了停掉了容器或者删除了容器，下次如果还想启动，就会发现之前创建的数据库结构都没了，我们又得重新执行一遍数据库的创建脚本，再次构造数据，如果一次两次还好，如果经常要用的话，每次都这样做的话就显得太傻了。</p>
<p>有一种办法就是我们把容器内的保存数据的目录挂载到宿主机上，这样就可以避免容器删除了，容器内的数据也随着没了，只要在启动的时候加上 -v 参数指定要挂载的目录即可，这里注意我在末尾添加的 mysqld –lower_case_table_name=0 这一串参数，这是我在挂载数据目录后运行报错了，应该是跟我的目录包含大写字母的目录有关，和配置文件里面指定的不一样，需要加上后面那一串指定 mysql 区分表名大小写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -v /Users/zhouxh/docker/mysql/data:/var/lib/mysql --name mysql-container mysql/mysql-server mysqld --lower_case_table_names=0</span><br></pre></td></tr></table></figure>

<p>这样执行完之后再连上数据库创建的数据库表结构就会保存到宿主机上，不会随着容器的销毁而销毁。这样就实现了在我们想要连本地库时，启动容器即可，不想用了，停止或者删除容器都没关系，库里面的数据都已经保存在宿主机上了，下次启动时只要挂载对应的目录即可。</p>
<p>到这里，就基本上实现了通过 Docker 来运行 MySQL 服务的功能了，和本地安装一个 MySQL 使用的区别不是很大，并且也很方便。类似的，nginx 服务，各种队列(rabbitMq，rocketMq，kafka)，或者我们只是想做一个临时的测试，需要用到某个环境，我们都可以通过指定相应环境的镜像来启动容器的方式来做。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>使用 JdbcTemplate 的 queryForObject 方法时需注意的地方(二)</title>
    <url>/%E4%BD%BF%E7%94%A8-JdbcTemplate-%E7%9A%84-queryForObject-%E6%96%B9%E6%B3%95%E6%97%B6%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9-%E4%BA%8C/</url>
    <content><![CDATA[<p>上一篇文章中提到了 JdbcTemplate 的 queryForObject 方法在使用时需要注意的地方，其实这里还有一个地方也是我们在使用时容易忽略的，为了避免踩坑，这里我也一并提出来。</p>
<p>同样的，继续用活动的状态表来举例，在上次的例子中我们是通过活动 id 查询活动的浏览量这一列数据，但是如果我们想要一并查出活动的浏览量，作品数和用户数。先让我们同样使用 queryForObject 方法，然后把 SQL 改成查询所有列的数据,返回类型改成实体类。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">findByActivityId</span><span class="params">(String activityId)</span> </span>&#123;</span><br><span class="line">   String selectSql = <span class="string">&quot;select * from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">   ActivityStat activityStat = <span class="keyword">this</span>.jdbcTemplate.queryForObject(selectSql, ActivityStat.class,</span><br><span class="line">            activityId);</span><br><span class="line">   <span class="keyword">return</span> timesViewed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后会发现报错了，错误信息如下:</p>
<p><img src="http://images.rookiezhou.top/execute_error.png" alt="execute error"></p>
<p>从字面意思看是提示查询结果列的数量不正确，期望值是 1，但实际是 4。</p>
<p>是不是感觉有点奇怪，看代码好像也没啥问题，我们找到报错的位置看看为什么会出现这种结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        <span class="keyword">int</span> nrOfColumns = rsmd.getColumnCount();</span><br><span class="line">        <span class="keyword">if</span> (nrOfColumns != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectResultSetColumnCountException(<span class="number">1</span>, nrOfColumns);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object result = <span class="keyword">this</span>.getColumnValue(rs, <span class="number">1</span>, <span class="keyword">this</span>.requiredType);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.requiredType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.requiredType.isInstance(result)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.convertValueToRequiredType(result, <span class="keyword">this</span>.requiredType);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var7) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TypeMismatchDataAccessException(<span class="string">&quot;Type mismatch affecting row number &quot;</span> + rowNum + <span class="string">&quot; and column type &#x27;&quot;</span> + rsmd.getColumnTypeName(<span class="number">1</span>) + <span class="string">&quot;&#x27;: &quot;</span> + var7.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以看到在将结果集映射到我们指定的实体类型的时候有个对结果集的 column count 的判断，当 column count 不等于 1 的时候就会抛出 IncorrectResultSetColumnCountException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">queryForObject</span><span class="params">(String sql, Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queryForObject(sql, args, <span class="keyword">this</span>.getSingleColumnRowMapper(requiredType));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实从 queryForObject 方法的方法体也可以看出，里面调用了一个叫 getSingleColumnRowMapper 的方法，然后将我们指定的返回数据类型传进去，而方法的名字就是体现了方法的含义，返回一个单列的 row mapper。也就是 SingleColumnRowMapper 这个类，它实现了 RowMapper 接口，实现了接口里面的 mapRow 方法，也就是上面我们看到的报错的地方。</p>
<p>这时我们应该可以知道对于 queryForObject 方法当我们指定返回值类型的时候，它只适合用来查单列结果，也就是类似于下面的 SQL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select column1 from table;</span><br><span class="line">select count(*) from table;</span><br></pre></td></tr></table></figure>

<p> 再回到 queryForObject 方法，间接也说明我们设置返回类型的时候只能指定基本数据类型，而不能指定我们自定义的复杂数据类型。</p>
<p> 但如果我们依然需要查询结果并返回我们自定义的数据类型的时候，我们可以使用 queryForObject 重载的方法，自定义 RowMapper，自己实现 mapRow 方法，在方法里面取出结果映射到实体类就可以了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityStat <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> Object[]&#123;id&#125;, (rs, i) -&gt; &#123;</span><br><span class="line">            ActivityStat activityStat = <span class="keyword">new</span> ActivityStat();</span><br><span class="line">            activityStat.setActivityId(rs.getLong(<span class="string">&quot;activity_id&quot;</span>));</span><br><span class="line">            activityStat.setTimesViewed(rs.getLong(<span class="string">&quot;times_viewed&quot;</span>));</span><br><span class="line">            activityStat.setWorksCount(rs.getLong(<span class="string">&quot;works_count&quot;</span>));</span><br><span class="line">            activityStat.setUserCount(rs.getLong(<span class="string">&quot;user_count&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> activityStat;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里其实就是一个坑，稍不注意就会觉得代码好像也没啥问题，怎么会报错呢，同样的对于 queryForList 方法也会有这个问题，如果我们使用指定返回类型的话也是只能查询单列结果，需要返回多列时也需要我们自定义 RowMapper，感兴趣的可以自己去试试看。</p>
]]></content>
      <categories>
        <category>JdbcTemplate</category>
      </categories>
  </entry>
  <entry>
    <title>关于批量插入的数据重复问题</title>
    <url>/%E5%85%B3%E4%BA%8E%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在上一篇文章中我们谈到了数据库批量插入，如果你已经亲自实践过了的话你会发现有个问题，就是我们在第一次执行完测试之后，再次执行的话会报错，除非你删掉数据库中的数据再执行。</p>
<p>那是因为 activity_stats 表中 activity_id 是表的主键，第二次执行的话就会因为主键重复而报错了，当然你也可以选择去掉这个主键的限制来进行测试。</p>
<p>但真正在项目中可就不能这么做了，项目中我们可能就是想要 activity_id 字段作为主键，不允许插入重复数据。</p>
<a id="more"></a>

<p>虽然说一般情况下不会有重复的，但毕竟是一般情况下，对于特殊情况我们也是需要考虑的。比如说 excel 中就是因为运营人员粗心弄了多条相同的数据，或者再次将同样的 excel 文件拿来上传，这时候就会有问题了。</p>
<p>所以对于这种情况我们需要做到兼容，尽量给用户好的体验，不然说因为几条重复的数据就让用户去修改再次上传。对于这种普通的数据，可能就需要系统自动去重了，当然如果是涉及到金钱方面的数据那还是需要人工再次确认过的。</p>
<p>下面我们就讨论下 key 重复的几种不同处理方式:<br>1.忽略重复 key 的数据，由于主键或者唯一键重复的记录，数据库自动忽略，在 insert 后面加上 ignore 关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> activity_stats (activity_id, times_viewed, works_count, user_count)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>上面的 SQL 执行时，如果主键重复或者唯一键重复，会忽略掉新插入的数据，受影响行数为0，表数据不变，这是比较简单暴力的方式，但对于大部分情况下都是适用的，具体看业务情况而定。</p>
<p>2.使用最新数据，<br>对于 key 重复的数据，我们希望插入最新的数据到数据库中。要做到这个有两种方式: 一种是对重复数据进行更新，另一种是先删掉旧数据，然后再插入新数据。</p>
<p>先看第一种: ON DUPLICATE KEY UPDATE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats (activity_id, times_viewed, works_count, user_count)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> </span><br><span class="line"><span class="keyword">UPDATE</span> times_viewed = <span class="keyword">values</span>(times_viewed), works_count = <span class="keyword">values</span>(works_count), user_count = <span class="keyword">values</span>(user_count);</span><br></pre></td></tr></table></figure>
<p>这种方式就是对于有重复的数据采取更新操作，要更新的字段跟在 UPDATE 关键字后面。</p>
<p>这里要注意一个受影响的行数的问题:</p>
<ul>
<li>没有重复 key 数据，直接插入新数据，受影响的行数为 1。</li>
<li>有重复 key 数据并且要更新的新数据和已经存在的旧数据不一样，受影响的行数为 2(???)，这里可能有点不好理解为什么是 2，这里我们先暂时记下是 2，待会我会详细说明。</li>
<li>有重复 key 数据并且要更新的新数据和已经存在的旧数据一致，受影响的行数为 1(???)，这个可能也不是很好理解，同样暂时先记下，马上为你娓娓道来。</li>
</ul>
<p>好了，现在看上面有两个地方打上了问号，这两个地方都是和我们正常所想的有点不一样。先看第一个打了问号的地方，也就是上面的第二点，按我们所想，key 重复，然后进行数据更新，这里只是进行了更新操作，受影响的行数应该是 1 才对，刚开始我对这个也是不太理解，后来通过查资料发现在 MySQL 的文档中关于 ON DUPLICATE KEY UPDATE 的使用中有下面这样一句话:<br>文档链接:<br><a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html">https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if the row is inserted as a new row, 2 if an existing row is updated, and 0 if an existing row is set to its current values.If you specify the CLIENT_FOUND_ROWS flag to the mysql_real_connect() C API function when connecting to mysqld, the affected-rows value is 1 (not 0) if an existing row is set to its current values.</span><br></pre></td></tr></table></figure>

<p>上面这句话前半句就能为我解答为什么我们在第二点中提到的疑惑，前半句的大概意思就是:<br>对于 ON DUPLICATE KEY UPDATE 的使用，如果没有 key 重复的新数据插入，每行受影响的行数是 1，如果有 key 重复的新数据更新，返回受影响的行数是 2，如果有 key 重复的数据并且存在的旧数据和要更新的数据一致，受影响的行数是 0。</p>
<p>看到这里我们应该就能明白为什么受影响的行数是 2 了，我们可以理解为是 MySQL 为了在 ON DUPLICATE KEY UPDATE 的使用中区分插入和更新，所以对于插入返回 1，更新返回 2。</p>
<p>但是不是说 “如果是有 key 重复的数据并且存在的旧数据和要更新的数据一致，受影响的行数是 0” 吗？可是我们在上面第三点中 MySQL 返回的受影响的行数是 1，而这也正是我们第三点所疑惑的地方，我们再去看上面那句话的后半句，大概意思是:<br>在连接 mysqld 的时候如果你为 mysql_real_connect() API 函数指定了 CLIENT_FOUND_ROWS 标志，那么对于已经存在的旧数据和要更新的数据一致时，受影响的数值为 1 而不是 0。</p>
<p>对于第二个疑问，我们也大概明白为什么受影响的行数是 1 了，是因为我们使用的 MySQL 指定了 CLIENT_FOUND_ROWS 标志，而 mysql_real_connect 函数指定 CLIENT_FOUND_ROWS 标志的意思就是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLIENT_FOUND_ROWS: Return the number of found (matched) rows, not the number of changed rows.</span><br></pre></td></tr></table></figure>
<p>这段文字在上面文档链接中可以点击 mysql_real_connect 跳转到对 mysql_real_connect 函数的描述页面，里面有 CLIENT_FOUND_ROWS 相应介绍。感兴趣的可以去研究研究。</p>
<hr>
<p>再回到使用最新数据方式上，上面已经描述了对 key 重复的数据进行更新的方式，接下来我们看第二种:<br>对于 key 重复，先删掉旧数据，然后再插入新数据:  REPLACE INTO </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> activity_stats (activity_id, times_viewed, works_count, user_count)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这种方式就是如果没有重复 key，直接插入，效果和 insert into 一样，但如果有重复 key，它会先删除旧数据，再插入新数据。同样这种方式受影响的行数也有以下几种情况:</p>
<ul>
<li>没有重复 key 数据，直接插入新数据，受影响的行数为 1。</li>
<li>有重复 key 数据并且要更新的新数据和已经存在的旧数据不一样，受影响的行数为 2。这个很好理解，先删除旧数据，然后再插入新数据，所以受影响的行数为 2。</li>
<li>有重复 key 数据并且要更新的新数据和已经存在的旧数据一致，受影响的行数为 1。这里应该是数据没有发生变化，至于返回 1，我的理解是和上面一样的，返回匹配到的行数，并不是发生改变的行数(暂时没找到有关文档描述)。</li>
</ul>
<p>关于重复 key 数据的处理方式主要有上面提到的三种，忽略重复数据的 INSERT IGNORE，使用更新的方式插入最新数据的 ON DUPLICATE KEY UPDATE，还有先删除再插入最新数据的 REPLACE INTO。</p>
<p>在我们使用这三种方式来避免插入重复数据的过程中，我们还需要注意下面几个问题:<br>首先，使用这三种方式的前提都是表中需要存在主键冲突或唯一键冲突，不然这三种都跟直接 INSERT INTO 没什么区别。</p>
<p>第二，要注意存在多个键冲突(插入的数据既可能存在主键冲突，也可能存在其他唯一键冲突或者存在多个唯一键冲突)的情况，在这种情况下使用可能会出现其他结果(可以自己测试看看)，所以这种情况下不太建议使用。</p>
<p>第三，这点比较重要，上面我的 activity_stats 表是有一个 activity_id 字段作为主键，这是存在主键冲突的情况。但如果我把 activity_id 字段改成唯一键并且新增一个字段 id 作为主键自增长，插入语句不变，这里因为 id 是自增长的，不存在冲突，所以这里是满足单一键冲突的情况，但是这里有个坑要注意，这种情况下使用上面三种方式都会产生主键 id 自增长不连续的问题。</p>
<p>目前的 SQL 语句是这样的: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> activity_stat (<span class="keyword">id</span>, activity_id, times_viewed, works_count, user_count)</span><br><span class="line"><span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">或者</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于 INSERT IGNORE 和 ON DUPLICATE KEY UPDATE，在存在 unique key 重复时，前者虽然重复的记录被忽略了没有执行插入操作，但是 id 还是会 +1。而后者是在 key 重复时执行更新操作，但 id 同样也会 +1，也就是说在存在 unique key 重复的情况下这两种方式不管有没有插入数据，自增长 id 都会增加。</p>
<p>这样的话在主从库的场景下就会出现主从的 auto_increment 不一致，因为 slave 并不会同步 master 的 auto_increment，一旦当前 master 挂了，任意一个 slave 被选举为 master，再次执行 insert 语句就可能导致主键冲突。</p>
<p>至于这里为什么会出现没有插入记录 auto_increment 却依然 +1 的情况，和 innodb_autoinc_lock_mode 的值有关。可以通过下面的 SQL 语句查看:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@innodb_autoinc_lock_mode;</span><br></pre></td></tr></table></figure>

<p>它的值可能是 0，1，2 其中一种，默认是 1，具体各个值的特征可以参看官方文档中的描述，下面是文档地址:<br><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-modes">https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-modes</a></p>
<p>而对于 REPLACE INTO，那是因为在存在 unique key 重复时，会先删除再插入，执行了插入操作，id 肯定会增加。问题就在于重新插入了一条数据 id 发生了变化。如果别的表关联了这个表的主键 id 的话就会出现数据查找不到的情况。</p>
<p>总之就是对于这三种避免插入重复数据的方式，如果是由于主键冲突的情况，基本上没什么问题，但如果是唯一键冲突的情况，都会导致 master 和 slave 的 auto_increment 不一致的问题，一旦主从的 auto_increment 不一致(这里是 master 的 auto_increment 要大于 slave)，只要 master 出现问题，任意一个 slave 升级成 master，由于当前新的 master 的 auto_increment 是小于数据中的 id 的值，所以再进行插入时就可能发生主键冲突。</p>
]]></content>
      <categories>
        <category>JdbcTemplate</category>
      </categories>
  </entry>
  <entry>
    <title>使用 JdbcTemplate 的 queryForObject 方法时需注意的地方(一)</title>
    <url>/%E4%BD%BF%E7%94%A8-JdbcTemplate-%E7%9A%84-queryForObject-%E6%96%B9%E6%B3%95%E6%97%B6%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    <content><![CDATA[<p>我们应该都使用过 JdbcTemplate 来查询数据库，一般用在配置了多数据源的情况下，在一个服务里面需要简单查询多个数据库的数据，这时通过 JdbcTemplate 来构建 SQL 查询数据库往往比较方便快捷些，不需要用封装的 repository 那一套东西。</p>
<p>举一个简单的例子，比如查询一个活动的浏览量。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">findByActivityId</span><span class="params">(String activityId)</span> </span>&#123;</span><br><span class="line">   String selectSql = <span class="string">&quot;select times_viewed from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">   Long timesViewed = <span class="keyword">this</span>.jdbcTemplate.queryForObject(selectSql, Long.class,</span><br><span class="line">            activityId);</span><br><span class="line">   <span class="keyword">return</span> timesViewed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我们咋一看上面这段代码，好像也没多大问题，只是一个普通的查询而已。在有数据的情况下，经过测试，程序也运行正常。但是如果你把你要查询的那个活动 id 的那条数据删除，这时再去测试会发现程序抛异常了，抛的异常类是 EmptyResultDataAccessException，从类的名字我们就可以看出，查询结果为空异常。</p>
<p>这里为什么会产生这种情况呢，我们深入查看下源码就知道了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">queryForObject</span><span class="params">(String sql, SqlParameterSource paramSource, RowMapper&lt;T&gt; rowMapper)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; results = getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rowMapper);</span><br><span class="line">        <span class="keyword">return</span> DataAccessUtils.nullableSingleResult(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们点进去查看 queryForObject 的方法体可以看到，在返回查询结果前调用了 DataAccessUtils 类的 nullableSingleResult 方法，那么再继续点进去查看 nullableSingleResult 的方法体:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">nullableSingleResult</span><span class="params">(<span class="meta">@Nullable</span> Collection&lt;T&gt; results)</span> <span class="keyword">throws</span> IncorrectResultSizeDataAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(results)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyResultDataAccessException(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (results.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectResultSizeDataAccessException(<span class="number">1</span>, results.size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> results.iterator().next();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 nullableSingleResult 的方法体中可以看到，当查询的结果为空的时候，手动抛了一个 EmptyResultDataAccessException 异常，同时我们还可以看到当查询结果记录数大于 1 时，手动抛了一个 IncorrectResultSizeDataAccessException 异常，这时候我们就要注意了，如果当前我们要执行的 SQL 的查询结果可能为空，或者结果集可能大于 1 时就需要根据我们的业务需求来进行手动处理这两个异常，不然程序会由于异常无法进行下去。</p>
<p>在这里个人觉得结果大于 1 的情况抛出异常还能理解，但是结果为空，其实在很多情况下我们都是希望代码正常运行下去，而不是直接抛出异常，有可能我们还有别的业务需要执行。所以不太清楚这里为什么需要做这个处理。</p>
<p>对于结果为空时抛出异常的情况，处理方式也很简单，在调用 queryForObject 方法的地方用 try catch 包起来，对 EmptyResultDataAccessException 异常进行捕获，同时忽略异常信息就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">queryByActivityId</span><span class="params">(String activityId)</span> </span>&#123;</span><br><span class="line">    String selectSql = <span class="string">&quot;select times_viewed from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">    Long timesViewed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        timesViewed = <span class="keyword">this</span>.jdbcTemplate.queryForObject(selectSql, Long.class,</span><br><span class="line">                activityId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (EmptyResultDataAccessException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> timesViewed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，如果对结果集可能大于 1 的情况也要特殊处理的话，我们就直接捕获 IncorrectResultSizeDataAccessException 异常就好，因为你可以看到 EmptyResultDataAccessException 是继承 IncorrectResultSizeDataAccessException 的。所以就直接捕获 IncorrectResultSizeDataAccessException 就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">queryByActivityId</span><span class="params">(String activityId)</span> </span>&#123;</span><br><span class="line">    String selectSql = <span class="string">&quot;select times_viewed from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">    Long timesViewed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        timesViewed = <span class="keyword">this</span>.jdbcTemplate.queryForObject(selectSql, Long.class,</span><br><span class="line">                activityId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IncorrectResultSizeDataAccessException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> timesViewed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里再提下 JdbcTemplate 和 NamedParmeterJdbcTemplate 的主要区别:<br>对于 JdbcTemplate，sql 的查询条件参数是使用占位符 ? 表示，受到了顺序的限制，如果是需要多个参数，在传入数组参数的时候，必须按照占位符的顺序传入参数，一旦传入的顺序错误就可能会造成非预期的结果。</p>
<p>而 NamedParmeterJdbcTemplate，在 sprintJdbc 框架中，通过这个 NameParameterJdbcTemplate 使用具名参数的方式来绑定 Sql 参数。具名参数的格式为 “ :parameterName”，多个具名参数通过 Map key value 的方式传入，key 和 parameterName 保持一致，这种情况下就和参数的顺序没有关系了，主要是通过 Map 的 key 来取值。</p>
]]></content>
      <categories>
        <category>JdbcTemplate</category>
      </categories>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="好的开始是成功的一半"><a href="#好的开始是成功的一半" class="headerlink" title="好的开始是成功的一半"></a><center>好的开始是成功的一半</center></h2><h1 id="欢迎使用Markdown编辑器写博客"><a href="#欢迎使用Markdown编辑器写博客" class="headerlink" title="欢迎使用Markdown编辑器写博客"></a>欢迎使用Markdown编辑器写博客</h1><p>本Markdown编辑器使用<a href="https://github.com/benweet/stackedit">StackEdit</a>修改而来，用它写博客，将会带来全新的体验哦：</p>
<a id="more"></a>

<ul>
<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>
<li><strong>代码块高亮</strong></li>
<li><strong>图片链接和图片上传</strong></li>
<li><strong><em>LaTex</em>数学公式</strong></li>
<li><strong>UML序列图和流程图</strong></li>
<li><strong>离线写博客</strong></li>
<li><strong>导入导出Markdown文件</strong></li>
<li><strong>丰富的快捷键</strong></li>
</ul>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>加粗    <code>Ctrl + B</code> </li>
<li>斜体    <code>Ctrl + I</code> </li>
<li>引用    <code>Ctrl + Q</code></li>
<li>插入链接    <code>Ctrl + L</code></li>
<li>插入代码    <code>Ctrl + K</code></li>
<li>插入图片    <code>Ctrl + G</code></li>
<li>提升标题    <code>Ctrl + H</code></li>
<li>有序列表    <code>Ctrl + O</code></li>
<li>无序列表    <code>Ctrl + U</code></li>
<li>横线    <code>Ctrl + R</code></li>
<li>撤销    <code>Ctrl + Z</code></li>
<li>重做    <code>Ctrl + Y</code></li>
</ul>
<h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</p>
</blockquote>
<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net/">链接</a>等，详细语法参考帮助？。</p>
<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href="https://github.com/jmcmanus/pagedown-extra" title="Pagedown Extra">Github</a>.  </p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>Computer</td>
<td>$1600</td>
</tr>
<tr>
<td>Phone</td>
<td>$12</td>
</tr>
<tr>
<td>Pipe</td>
<td>$1</td>
</tr>
</tbody></table>
<p>可以使用冒号来定义对齐方式：</p>
<table>
<thead>
<tr>
<th align="left">项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Computer</td>
<td align="right">1600 元</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left">Phone</td>
<td align="right">12 元</td>
<td align="center">12</td>
</tr>
<tr>
<td align="left">Pipe</td>
<td align="right">1 元</td>
<td align="center">234</td>
</tr>
</tbody></table>
<p>###定义列表</p>
<dl><dt><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A</dt><dd>定义 B</dd></dl><dl><dt>项目３</dt><dd>定义 C</dd></dl><p>:   定义 D</p>
<pre><code>&gt; 定义D内容</code></pre>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>
<p>[TOC]</p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/">math.stackexchange.com</a>.</p>
<ul>
<li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li>
<li>块级公式：</li>
</ul>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">这儿</a>.</p>
<h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure>

<p>或者流程图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

<ul>
<li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/">这儿</a>,</li>
<li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li>
</ul>
<h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>
<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>
<p>博客发表后，本地缓存将被删除。　</p>
<p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>
</blockquote>
<p>##浏览器兼容</p>
<ol>
<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>
<li>IE９以下不支持</li>
<li>IE９，１０，１１存在以下问题<ol>
<li>不支持离线功能</li>
<li>IE9不支持文件导入导出</li>
<li>IE10不支持拖拽文件导入</li>
</ol>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式的基本运用</title>
    <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>正则表达式，听起来就很高大上，用起来其实挺复杂的，毕竟人家也算是一门语言，但我们在日常开发中如果会一点正则，你会发现有意想不到的效果，对我们开发的效率还是有一定的提高的。刚开始我一直想学习一下一些简单的正则，但每次看完一些资料当时好像明白怎么回事了，但过一段时间没用又忘了，其实说到底就是自己就根本没掌握好，加上又没去实践，当时理解了，长时间不用自然就忘了。所以说学到的知识需要用起来，这样才能加深理解，也不容易忘记。下面主要说一下正则表达式的简单运用，更加高深的正则可能需要花好些时间去系统的学习一番。</p>
<a id="more"></a>

<p>测试正则表达式是否正确可以去这个网址，下面的测试都是基于它测试出来的，地址如下：</p>
<p><a href="https://regex101.com/">正则测试</a></p>
<h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>这是最简单的正则，也就是平常我们习惯的搜索，根据指定字符去文本中搜索完全匹配的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“dee”        ==&gt;    Regular expressions are a <code>dee</code>p language.<br>“deep”    ==&gt;    Regular expressions are a <code>deep</code> language.</p>
</blockquote>
<h2 id="正则中的元字符"><a href="#正则中的元字符" class="headerlink" title="正则中的元字符"></a>正则中的元字符</h2><table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>点号匹配任意单个字符除了换行符</td>
</tr>
<tr>
<td>[ ]</td>
<td>字符种类，匹配方括号内的任意字符</td>
</tr>
<tr>
<td>[^]</td>
<td>否定的字符种类，匹配除了方括号里的字符外其他任意字符</td>
</tr>
<tr>
<td>*</td>
<td>量词符号，表示 &gt;= 0,即匹配 &gt;=0 个在 * 号前的字符</td>
</tr>
<tr>
<td>+</td>
<td>量词符号，表示 &gt;= 1,即匹配 &gt;=1 个在 + 号前的字符</td>
</tr>
<tr>
<td>?</td>
<td>量词符号，表示 &gt;=0,&lt;=1,即 + 号前的字符可出现可不出现</td>
</tr>
<tr>
<td>{n,m}</td>
<td>大括号之前的字符出现 n 到 m 次</td>
</tr>
<tr>
<td>(abc)</td>
<td>字符集, 匹配与 xyz 完全相等的字符串</td>
</tr>
<tr>
<td>&#124;</td>
<td>或运算符,匹配符号前或后的字符</td>
</tr>
<tr>
<td>\</td>
<td>转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \ &#124;</td>
</tr>
<tr>
<td>^</td>
<td>从文本的头部开始匹配</td>
</tr>
<tr>
<td>$</td>
<td>匹配到文本的结尾</td>
</tr>
</tbody></table>
<p>以下面这句话为例，大致说明一下上面表格中的元字符的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<p>1.匹配 e 字符后面接上任意一个字符，包括空格。</p>
<blockquote>
<p>“e.”  ==&gt;  R<code>eg</code>ular <code>ex</code>pr<code>es</code>sions ar<code>e</code> a d<code>ee</code>p languag<code>e.</code>  </p>
</blockquote>
<p>2.匹配 e 字符后面接上包含在中括号中的任意一个字符。</p>
<blockquote>
<p>“e[g,x,e]”  ==&gt;  R<code>eg</code>ular <code>ex</code>pressions are a d<code>ee</code>p language.  </p>
</blockquote>
<p>3.匹配 e 字符后面接上不包含在中括号中的任意一个字符，这里需要注意的是中括号中不能既加上包含字符，又加上不包含的字符，也就是不能这样写：”e[g,^x,^e]” 这样匹配出来的结果和上面匹配的结果一致，如果是把不包含的字符写在前面的话：”e[^g,x,e]” 这样匹配的结果则和下面的结果一致。</p>
<blockquote>
<p>“e[^g,^x,^e]”  ==&gt;  Regular expr<code>es</code>sions ar<code>e</code> a de<code>ep</code> languag<code>e.</code>  </p>
</blockquote>
<p>4.匹配 e 字符后面接上包含中括号中 s 字符任意次，包括 0 次，就是也可以没有字符。</p>
<blockquote>
<p>“e[s]*”  ==&gt;  R<code>e</code>gular <code>e</code>xpr<code>ess</code>ions ar<code>e</code> a d<code>e</code> <code>e</code>p languag<code>e</code>.</p>
</blockquote>
<p>5.匹配 e 字符后面接上包含中括号中 s 字符 1次或多次，就是最少要出现一次。</p>
<blockquote>
<p>“e[s]+”  ==&gt;  Regular expr<code>ess</code>ions are a deep language.</p>
</blockquote>
<p>6.匹配 e 字符后面接上包含中括号中 s 字符 0 次或 1 次，就是可有可无，注意和第 4 个的区别。</p>
<blockquote>
<p>“e[s]?”  ==&gt;  R<code>e</code>gular <code>e</code>xpr<code>es</code>sions ar<code>e</code> a d<code>e</code> <code>e</code>p languag<code>e</code>.</p>
</blockquote>
<p>7.匹配 e 字符后面接上包含中括号中 s 字符指定次数，次数在大括号中指定，可以是一个固定数字，也可以是一个范围。</p>
<blockquote>
<p>“e[s]{1}”  ==&gt;  Regular expr<code>es</code>sions are a deep language.<br>“e[s]{2,3}”  ==&gt;  Regular expr<code>ess</code>ions are a deep language.</p>
</blockquote>
<p>8.匹配 ee 这个字符集出现 1 次到 2 次。</p>
<blockquote>
<p>“(ee){1,2}”  ==&gt;  Regular expressions are a d<code>ee</code>p language.</p>
</blockquote>
<p>9.匹配 ee 这个字符集出现 1 次到 2 次或者匹配 ss 这个字符集出现 1 次到 2 次。</p>
<blockquote>
<p>“(ee){1,2}|ss{1,2}”  ==&gt;  Regular expre<code>ss</code>ions are a d<code>ee</code>p language.</p>
</blockquote>
<p>10.匹配 e. 这两个字符，注意这里的点号并不是表示任意字符，经过转义后只是单纯的一个点号。</p>
<blockquote>
<p>“e\.”  ==&gt;  Regular expressions are a deep languag<code>e.</code></p>
</blockquote>
<p>11.下面第一个表示忽略大小写全局匹配 Re 这个两个字符，第二个表示忽略大小写全局匹配以 Re 开头的字符串。</p>
<blockquote>
<p>“Re/gi”  ==&gt;  <code>Re</code>gular exp<code>re</code>ssions a<code>re</code> a deep language.<br> “^Re/gi”  ==&gt;  <code>Re</code>gular expressions are a deep language.</p>
</blockquote>
<p>12.下面第一个表示忽略大小写全局匹配 re 加上任意字符，第二个表示忽略大小写全局匹配以 re 加上任意字符结尾的字符串。</p>
<blockquote>
<p>“[r,g]e./gi”  ==&gt;  <code>Reg</code>ular exp<code>res</code>sions a<code>re</code> a deep langua<code>ge.</code><br> “[r,g]e.$/gi”  ==&gt;  Regular expressions are a deep langua<code>ge.</code></p>
</blockquote>
<h2 id="正则中的简写字符集"><a href="#正则中的简写字符集" class="headerlink" title="正则中的简写字符集"></a>正则中的简写字符集</h2><table>
<thead>
<tr>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有字母数字, 等同于 [a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配所有非字母数字, 即符号, 等同于: [^\w]</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字: [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字: [^\d]</td>
</tr>
<tr>
<td>\s</td>
<td>匹配所有空格字符, 等同于: [\t\n\f\r\p{Z}]</td>
</tr>
<tr>
<td>\S</td>
<td>匹配所有非空格字符: [^\s]</td>
</tr>
</tbody></table>
<h2 id="前后关联约束"><a href="#前后关联约束" class="headerlink" title="前后关联约束"></a>前后关联约束</h2><p>1.前置约束存在和前置约束排除：(?=…) 和 (?!…)</p>
<p>通俗点说就是对指定格式的前面的元素进行约束，前者是匹配到的元素后面跟着指定格式，后者是匹配到的元素后面不是跟着指定格式。结合例子可能更好理解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“ar(?=\s)” ==&gt;  Regul<code>ar</code> expressions are a deep language //匹配 ar 字符串后面跟着的是空格。<br>“ar(?!\s)” ==&gt;  Regular expressions <code>ar</code>e a deep language//匹配 ar 字符串后面跟着的不是空格。</p>
</blockquote>
<p>上面两个正则都是对匹配到的 ar 字符串进行约束，前者是跟着的是空格，后者跟着的不是空格；前者约束存在，书写格式为 (?=…)，后者约束不存在，书写格式为 (?!…)。</p>
<p>2.后置约束存在和后置约束排除：(?&lt;=…) 和 (?&lt;!…)</p>
<p>和上面的相对应，对指定格式的后面的元素进行约束，前者是匹配到的元素前面跟着指定格式，后者是匹配到的元素前面不是跟着指定格式。同样结合例子理解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“(?&lt;=\s)ar”  ==&gt;  Regular expressions <code>ar</code>e a deep language //匹配 ar 字符串前面跟着的是空格。<br>“(?&lt;!\s)ar”  ==&gt;  Regul<code>ar</code> expressions are a deep language//匹配 ar 字符串前面跟着的不是空格。</p>
</blockquote>
<p>上面两个正则同样都是对匹配到的 ar 字符串进行约束，前者的前面要是空格，后者的前面要不是空格，同样的前者约束存在，书写格式为 (?&lt;=…)，后者约束不存在，书写格式为 (?&lt;!…)，相比上面多了个小于号。</p>
<h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫修饰语, 它是用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是正则表达式的一部分，常用的标志有三种：g，i，m，分别表示全局搜索，忽略大小写，多行匹配。</p>
<p>1.全局搜索 g</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<p>匹配测试结果如下：</p>
<blockquote>
<p>“ar”  ==&gt;  Regul<code>ar</code> expressions are a deep language<br>“ar/g”  ==&gt;  Regul<code>ar</code> expressions <code>ar</code>e a deep language</p>
</blockquote>
<p>上面两者的区别在于第一个是只搜索匹配到的第一个结果，第二个是全局搜索，将所有匹配的结果全部搜索出来。</p>
<p>2.忽略大小写 i</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<p>匹配测试结果如下：</p>
<blockquote>
<p>“Reg”  ==&gt; <code>Reg</code>ular expressions are a deep language<br>“REG/i”  ==&gt; <code>Reg</code>ular expressions are a deep language</p>
</blockquote>
<p>上面两者的区别在于第一个是只搜索字符完全匹配的结果，第二个是搜索忽略大小写的匹配结果。</p>
<p>3.多行匹配 m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language,</span><br><span class="line">Regular expressions are a deep language,</span><br><span class="line">Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<p>“^Reg/g” 匹配结果如下：</p>
<blockquote>
<p><code>Reg</code>ular expressions are a deep language,<br>Regular expressions are a deep language,<br>Regular expressions are a deep language.</p>
</blockquote>
<p>“^Reg/gm” 匹配结果如下：</p>
<blockquote>
<p><code>Reg</code>ular expressions are a deep language,<br><code>Reg</code>ular expressions are a deep language,<br><code>Reg</code>ular expressions are a deep language.</p>
</blockquote>
<p>这样一对比两者的区别其实就已经出来了，第一个是全局搜索匹配到的结果，匹配的是第一行的开头，而第二个也是全局搜索匹配到的结果，只不过它是匹配每一行的开头。</p>
<p>以上就是正则表达式的一些基础运用，有了上面的基础，然后在平常开发中积极去尝试写出一些稍微复杂的正则，加强练习，不然只会像我刚开始一样，看完之后过一段时间就忘了，只有不断练习，慢慢的才会对正则有一些感觉。这些正则的基础也是我在 github 上找到一个关于学习正则的项目，然后通过这个项目的学习所掌握的，下面就是这个项目的地址：</p>
<p><a href="https://github.com/zeeshanu/learn-regex">学习正则表达式</a></p>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">整数: ^-?\d+$</span><br><span class="line">正整数: ^\d+$</span><br><span class="line">负整数: ^-\d+$&#96;</span><br><span class="line">纯小写字母: ^([a-z])*$</span><br><span class="line">纯大写字母: ^([A-Z])*$</span><br><span class="line">用户名: ^[\w\d_.]&#123;4,16&#125;$</span><br><span class="line">数字和英文字母: ^[a-zA-Z0-9]*$</span><br><span class="line">数字和英文字母和空格: ^[a-zA-Z0-9 ]*$</span><br><span class="line">密码: ^(?&#x3D;^.&#123;6,&#125;$)((?&#x3D;.*[A-Za-z0-9])(?&#x3D;.*[A-Z])(?&#x3D;.*[a-z]))^.*$</span><br><span class="line">邮箱: ^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;)*$</span><br><span class="line">IP4 地址: ^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</span><br><span class="line">URL: ^(((http|https|ftp):\&#x2F;\&#x2F;)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\&#x2F;+&#x3D;%&amp;_\.~?\-]*))*$</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
  </entry>
  <entry>
    <title>极力推荐的博文排版指南</title>
    <url>/%E6%9E%81%E5%8A%9B%E6%8E%A8%E8%8D%90%E7%9A%84%E5%8D%9A%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>作为程序员来说，养成写博客的习惯真的是一件值得去做的事，尽管刚开始可能没有那么高质量的知识输出，但是不是有这样一句话吗？「知识的输入应转化为输出」，也就是说你应该把你所学到的都转化为输出，只有这样你才能更好的掌握你所学的知识，并且在这个过程中你也会对你所学的知识点进行很好的补充。既然要写博文，是不是刚开始就随便写写呢？当然不是，一篇排版好内容不是很好的博文相比于内容好排版很乱的博文能够让人更乐于看下去，尤其是那些对代码有洁癖的程序员我相信你更看不下去，那么以下便是我极力推荐的博客排版指南：</p>
<a id="more"></a>

<h3 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h3><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。」</p>
<ol>
<li><p>中英文之间加空格<br>eg. 相信每个程序员都会去全球最大的同性交友网站 GitHub 上逛逛。</p>
</li>
<li><p>中文和数字之间加空格<br>eg. 那些排版很乱的博文估计你连 1 分钟都看不下去。</p>
</li>
<li><p>数字和单位之间不加空格<br>eg. 现在的安卓手机运行内存没有 6G 都装不了几个应用了。<br>eg. 今天的气温又超过了 40°。<br>eg. 之前买的基金昨天一天跌了 5%。</p>
</li>
<li><p>推荐在链接前后加一个空格<br>eg.  我的公众号和博客名称都是 rookiezhou，搜索 rookiezhou 关注我，点击这里 <a href="http://www.rookiezhou.top/">rookiezhou</a> 访问个人博客。</p>
</li>
</ol>
<h3 id="标点符号的细节"><a href="#标点符号的细节" class="headerlink" title="标点符号的细节"></a>标点符号的细节</h3><ol>
<li><p>不用为了夸张重复使用标点符号<br>eg. 今年法国夺冠了，华帝刚开始打的一手好牌到最后却变成了一副烂牌，你敢信吗？</p>
</li>
<li><p>中文段落中尽量使用中文标点符号<br>eg. 一篇好的博文绝对离不开好的排版，所以这篇博文应该算是好文了吧。</p>
</li>
<li><p>推荐将引号换成直角引号<br>eg. 你竟然没看过「Java 编程思想」这本书。</p>
</li>
<li><p>推荐引号中还有引号替换成直角双引号<br>eg. 经常有人带着疑惑的目光对我说「你竟然没看过『Java 编程思想』这本书？」</p>
</li>
<li><p>完整的英文整句使用英文标点符号<br>eg. 引用乔布斯说的那句话：「Stay hungry, stay foolish.」</p>
</li>
</ol>
<h3 id="专有名词大小写尽量规范"><a href="#专有名词大小写尽量规范" class="headerlink" title="专有名词大小写尽量规范"></a>专有名词大小写尽量规范</h3><p>eg. Java、MySQL 都是后端开发人员必须要会的，当然也要会一些前端的技术，比如说：HTML5、CSS、JavaScript、jQuery。</p>
<p>还有就是对于一些博文可能存在一篇博文下来就只有一段，看起来很紧凑，如果说在每写完一个知识点隔开一行看起来是不是会更好看些呢，这样一来对于我们从小养成的每一段首行空两格的习惯是不是也可以改了呢，其实你去注意一下那些排版比较好的博文，应该大部分都是这么做的，当然这取决于个人，不喜勿喷。</p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/538faa30b17d">https://www.jianshu.com/p/538faa30b17d</a><br><a href="https://github.com/mzlogin/chinese-copywriting-guidelines">https://github.com/mzlogin/chinese-copywriting-guidelines</a></p>
]]></content>
      <categories>
        <category>写作</category>
      </categories>
  </entry>
</search>
