<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dubbo 框架整体介绍</title>
    <url>/Dubbo-%E6%A1%86%E6%9E%B6%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="Dubbo-是什么"><a href="#Dubbo-是什么" class="headerlink" title="Dubbo 是什么"></a>Dubbo 是什么</h3><p>官方术语是这样来定义 Dubbo 的：</p>
<p>Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下的服务治理与通信问题，使用 Dubbo 开发的微服务原生具备相互之间的远程地址发现与通信能力， 利用 Dubbo 提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。Dubbo 被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑，以改变框架的默认行为来满足自己的业务需求。</p>
<a id="more"></a> 

<p>虽然说 Dubbo 具备的能力很强大，但往往我们一开始来使用 Dubbo 基本上都是使用 Dubbo 的远程服务调用的能力，Dubbo 能够为我们做到：</p>
<ol>
<li>只需简单配置就能实现透明化的远程方法调用，就像调用本地方法一样来调用远程方法</li>
<li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点</li>
<li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者</li>
</ol>
<h3 id="框架整体设计："><a href="#框架整体设计：" class="headerlink" title="框架整体设计："></a>框架整体设计：</h3><p><img src="/images/dubbo-framework.jpg" alt="dubbo-framework.jpg"></p>
<p>上面图例来自官方文档，这张图基本上把 Dubbo 的整个框架核心内容都囊括进去了，左边淡蓝色部分属于消费方 Consumer 使用到的接口和类，右边淡绿色是提供方 Provider 使用到的接口和类，中轴线是双方都会用到的接口和类。</p>
<p>需要注意的是对于 Consumer 和 Provider，它只是个抽象的概念，目的是能够更直观的说明哪些类分属于客户端与服务器端，不用 Client 和 Server 的原因是 Dubbo 在很多场景下都使用 Provider, Consumer, Registry, Monitor 划分逻辑拓扑节点，保持统一概念。</p>
<ul>
<li><strong>config 配置层</strong>：对外配置接口，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 <code>ServiceProxy</code> 为中心，扩展接口为 <code>ProxyFactory</code>。Proxy 层封装了所有接口的透明化代理，而在其它层都以 Invoker 为中心，只有到了暴露给用户使用时，才用 Proxy 将 Invoker 转成接口，或将接口实现转成 Invoker，也就是去掉 Proxy 层 RPC 是可以 Run 的，只是不那么透明，不那么看起来像调本地服务一样调远程服务。</li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <code>RegistryFactory</code>, <code>Registry</code>, <code>RegistryService</code>。Registry 实际上并不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起</li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心，扩展接口为 <code>Cluster</code>, <code>Directory</code>, <code>Router</code>, <code>LoadBalance</code>。Cluster 是外围概念，目的是将多个 Invoker 伪装成一个 Invoker，这样其它人只要关注 Protocol 层 Invoker 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</li>
<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心，扩展接口为 <code>MonitorFactory</code>, <code>Monitor</code>, <code>MonitorService</code>。实际上并不算一层，而是一个独立的节点，只是为了全局概览，用层的方式画在一起</li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心，扩展接口为 <code>Protocol</code>, <code>Invoker</code>, <code>Exporter</code>。Protocol 是核心层，也就是只要有 Protocol + Invoker + Exporter 就可以完成非透明的 RPC 调用，然后在 Invoker 的主过程上 Filter 拦截点</li>
<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心，扩展接口为 <code>Exchanger</code>, <code>ExchangeChannel</code>, <code>ExchangeClient</code>, <code>ExchangeServer</code>。Exchange 层是在传输层之上封装了 Request-Response 语义</li>
<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心，扩展接口为 <code>Channel</code>, <code>Transporter</code>, <code>Client</code>, <code>Server</code>, <code>Codec</code>。Transport 层只负责单向消息传输，是对 Mina, Netty, Grizzly 的抽象，它也可以扩展 UDP 传输</li>
<li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 <code>Serialization</code>, <code>ObjectInput</code>, <code>ObjectOutput</code>, <code>ThreadPool</code></li>
</ul>
<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p><img src="/images/dubbo-relation.jpg" alt="dubbo-relation.jpg"></p>
<p>图例说明：</p>
<ul>
<li>图中小方块 Protocol, Cluster, Proxy, Service, Container, Registry, Monitor 代表层或模块，蓝色的表示与业务有交互，绿色的表示只对 Dubbo 内部交互。</li>
<li>图中背景方块 Consumer, Provider, Registry, Monitor 代表部署逻辑拓扑节点。</li>
<li>图中蓝色虚线为初始化时调用，红色虚线为运行时异步调用，红色实线为运行时同步调用。</li>
<li>图中只包含 RPC 的层，不包含 Remoting 的层，Remoting 整体都隐含在 Protocol 中。</li>
</ul>
<p>Consumer、Provider，Register，Monitor 间调用关系说明：</p>
<ol>
<li>服务提供者 Provider 启动时向注册中心 Register 注册自己提供的服务。</li>
<li>服务消费者 Consumer 在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 Monitor(异步)。</li>
</ol>
<h3 id="远程调用细节"><a href="#远程调用细节" class="headerlink" title="远程调用细节"></a>远程调用细节</h3><ul>
<li><h3 id="Provider-暴露一个服务的详细过程"><a href="#Provider-暴露一个服务的详细过程" class="headerlink" title="Provider 暴露一个服务的详细过程"></a>Provider 暴露一个服务的详细过程</h3></li>
</ul>
<p><img src="/images/dubbo_rpc_export.jpg" alt="dubbo_rpc_export.jpg"></p>
<p>首先 <code>ServiceConfig</code> 类拿到对外提供服务的实际类 ref，然后通过 <code>ProxyFactory</code> 类的 <code>getInvoker</code> 方法使用 ref 生成一个 <code>AbstractProxyInvoker</code> 实例，到这一步就完成具体服务到 <code>Invoker</code> 的转化。接下来就是 <code>Invoker</code> 转换到 <code>Exporter</code> 的过程(上图中的红色部分)，这一过程对于有不同的实现有不同的方式，如果是 Dubbo 实现，主要发生在<code>DubboProtocol</code> 类的 <code>export</code> 方法，它主要是打开 socket 侦听服务，并接收客户端发来的各种请求，通讯细节由 Dubbo 自己实现。</p>
<ul>
<li><h3 id="Consumer-消费一个服务的详细过程"><a href="#Consumer-消费一个服务的详细过程" class="headerlink" title="Consumer 消费一个服务的详细过程"></a>Consumer 消费一个服务的详细过程</h3></li>
</ul>
<p><img src="/images/dubbo_rpc_refer.jpg" alt="dubbo_rpc_refer.jpg"></p>
<p>首先 <code>ReferenceConfig</code> 类的 <code>init</code> 方法调用 <code>Protocol</code> 的 <code>refer</code> 方法生成 <code>Invoker</code> 实例(上图中的红色部分)，这是服务消费的关键。接下来把 <code>Invoker</code> 转换为客户端需要的接口。</p>
<h3 id="Invoker-是什么"><a href="#Invoker-是什么" class="headerlink" title="Invoker 是什么"></a>Invoker 是什么</h3><p>由于 <code>Invoker</code> 是 Dubbo 领域模型中非常重要的一个概念，很多设计思路都是向它靠拢。从上面暴露服务和消费服务的过程中也可以看出来， <code>Invoker</code> 渗透在整个实现代码里，对于刚开始接触 Dubbo 的人很容易就给搞混了。 Invoker 是 Dubbo 中的实体域，也就是真实存在的。其他模型都向它靠拢或转换成它，它也就代表一个可执行体，可向它发起 invoke 调用。在服务提供方，Invoker 用于调用服务提供类，在服务消费方，Invoker 用于执行远程调用。</p>
<p><img src="/images/dubbo_rpc_invoke.jpg" alt="dubbo_rpc_invoke.jpg"></p>
<h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p>在 Dubbo 的核心领域模型中：</p>
<ul>
<li>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</li>
<li>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</li>
<li>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。</li>
</ul>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
  </entry>
  <entry>
    <title>Effective Java - 创建和销毁对象</title>
    <url>/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h2><p>当我们的类的一些属性是必须的，有些属性是可选的，参数较多的情况下我们可以适当考虑使用构建器，其实在 Java 开发中我们也经常遇到这种通过构建器来创建类实例的情况，然后再结合链式调用写出来的代码还是比较美观的。下面结合一个简单的例子来说明：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String phone;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可选参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Integer sex;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可选参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String birthday;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 可选参数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String[] hobby;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String username;</span><br><span class="line">        private String password;</span><br><span class="line">        private String phone;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private Integer sex &#x3D; 1;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private String birthday &#x3D; &quot;0-0-0-0&quot;;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private String[] hobby &#x3D; new String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        public Builder(String username, String password, String phone) &#123;</span><br><span class="line">            this.username &#x3D; username;</span><br><span class="line">            this.password &#x3D; password;</span><br><span class="line">            this.phone &#x3D; phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder sex(Integer sex) &#123;</span><br><span class="line">            sex &#x3D; sex;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder birthday(String birthday) &#123;</span><br><span class="line">            birthday &#x3D; birthday;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder hobby(String[] hobby) &#123;</span><br><span class="line">            hobby &#x3D; hobby;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public User build() &#123;</span><br><span class="line">            return new User(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private User(Builder builder) &#123;</span><br><span class="line">        username &#x3D; builder.username;</span><br><span class="line">        password &#x3D; builder.password;</span><br><span class="line">        phone &#x3D; builder.phone;</span><br><span class="line">        sex &#x3D; builder.sex;</span><br><span class="line">        birthday &#x3D; builder.birthday;</span><br><span class="line">        hobby &#x3D; builder.hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;username&#x3D;&#39;&quot; + username + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, password&#x3D;&#39;&quot; + password + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, phone&#x3D;&#39;&quot; + phone + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, sex&#x3D;&quot; + sex +</span><br><span class="line">                &quot;, birthday&#x3D;&#39;&quot; + birthday + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, hobby&#x3D;&quot; + Arrays.toString(hobby) +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>User 对象的创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user &#x3D; new User.Builder(&quot;admin&quot;, &quot;123456&quot;, &quot;13999999999&quot;).sex(0).build();</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这里只是一个简单的小例子，开发中一般不会用这种方式来创建实体类，可能还是需要看个人开发时具体情况决定是否采用这种方式，这里只对这种创建方式做一个简单的介绍。</p>
<h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>一般来说，最好能重用对象而不是在每次需要时都去频繁的创建，重用的方式快，而且能够避免频繁创建浪费资源。像下面这种情况就推荐重用对象,可以对比以下两种方式的差别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.TimeZone;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 不推荐这样做</span><br><span class="line"> *</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Person1 &#123;</span><br><span class="line"></span><br><span class="line">    private final Date birthDate &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">    public boolean isBabyBoomer() &#123;</span><br><span class="line">        Calendar calendar &#x3D; Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class="line">        calendar.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        Date boomStart &#x3D; calendar.getTime();</span><br><span class="line">        calendar.set(1965, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        Date boomEnd &#x3D; calendar.getTime();</span><br><span class="line">        return birthDate.compareTo(boomStart) &gt;&#x3D; 0 &amp;&amp; birthDate.compareTo(boomEnd) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.TimeZone;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 推荐这样做</span><br><span class="line"> *</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Person2 &#123;</span><br><span class="line"></span><br><span class="line">    private final Date birthDate &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">    private static final Date BOOM_START;</span><br><span class="line">    private static final Date BOOM_END;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Calendar calendar &#x3D; Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class="line">        calendar.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        BOOM_START &#x3D; calendar.getTime();</span><br><span class="line">        calendar.set(1965, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        BOOM_END &#x3D; calendar.getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isBabyBoomer() &#123;</span><br><span class="line">        return birthDate.compareTo(BOOM_START) &gt;&#x3D; 0 &amp;&amp; birthDate.compareTo(BOOM_END) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><p>我们在日常开发中可能稍有不慎就会遇到内存泄漏的问题，这需要我们从细节去防止这种情况的发生，一般而言，只要类是自己管理内存，就应该警惕内存泄漏的问题。下面展示一种可能会发生内存泄漏的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Stack &#123;</span><br><span class="line"></span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size &#x3D; 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements &#x3D; new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object object) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop1() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop2() &#123;</span><br><span class="line">        if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object result &#x3D; elements[--size];</span><br><span class="line">        &#x2F;*</span><br><span class="line">        将弹出的值赋空，以便 jvm 回收，如果不赋空将不会被 jvm 回收，因为栈内部依然维护着这些对象的过期引用。</span><br><span class="line">        过期引用是指永远不会被解除的引用，在这里就是指在 elements 数组活动之外的引用，即元素下标小于 size 的那些元素。</span><br><span class="line">        所以一旦数组元素变成了非活动部分的一部分就应该手动清空这些数组元素。</span><br><span class="line">        *&#x2F;</span><br><span class="line">        elements[size] &#x3D; null;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length &#x3D;&#x3D; size) &#123;</span><br><span class="line">            elements &#x3D; Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个随着栈的不断的弹栈和压栈，每次弹出如果不清空该引用，随着量的增加就可能造成内存泄漏的情况。</p>
]]></content>
      <categories>
        <category>Effective Java</category>
      </categories>
  </entry>
  <entry>
    <title>Explain 的使用实践</title>
    <url>/Explain-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>上篇文章中从整体上介绍了 explain 的使用以及 explain 执行得到的这些字段含义和常见的值，那得到这些字段信息后，对于这个 SQL 要不要优化，又该怎么优化，这个似乎没有什么固定的标准，但总体来说的话，要尽量让我们的查询使用上索引，然后在使用上索引之后再进一步看有没有优化的空间，当然对于实在没法用上索引或者说业务上能接受没必要多建一个索引的查询，我们也可以尝试在用不上索引的情况下去看看还有没有进一步优化的空间。</p>
<a id="more"></a>

<p>explain 执行的结果中，id，table 这两列有助于帮助我们理解 SQL 的执行顺序，select_type 更多的是告诉我们 SQL 的查询类型, partitions 只在查询分区表的时候有意义，key_len 表示使用索引的长度，更多的是一些 SQL 层面的基本信息，在进行 SQL 优化的时候可以不去看</p>
<p>rows 表示查询过程中预估需要扫描的行数，但这是一个估算的值，并不是具体的值，当然如果是在已经能使用上索引的情况，可以去考虑让扫描的行数尽可能的少，因此不是首先要关注的字段</p>
<p>filtered 表示通过索引查询之后匹配到的数据量再经过 server 层 where 条件判断过滤之后剩余数据比例，当然比例越大越好，但如果是一个没有走索引的全表扫描之后得到值再经过 where 条件判断都满足条件，filtered 值 100%，相比于一个走索引查询之后经过 where 条件判断只剩下 50% 的比例满足条件，我们依然会选择后者，因此这个相比于索引优化的情况基本可以忽略不计</p>
<p>因此在进行 SQL 优化的时候需要重点去看 type，possible_keys， key 以及 Extra 这几列的值，通过这几列就能够大概知道 SQL 是否有优化的空间，通常我们说加索引是最直接的优化方式，如果都没有使用索引那么就可以优先考虑是否有必要增加一个索引，在增加索引后再通过 possible_keys 和 key 字段来看看是否已经用上了，用的是哪个索引。在增加索引之后没有用上那可以考虑为什么 MySQL 评估之后不走索引，是因为数据量太小了或数据分布的问题，还是说 MySQL 判定走索引需要回表得到其他字段信息，还不如直接全表扫描来的划算所以直接全表扫描。</p>
<p>如果增加索引之后通过 key 字段也看到已经使用上索引了，这时同样也要考虑是否当时的数据分布使得使用了索引，随着数据的增加会不会后面又回到全表扫描的情况，这种情况可能很多人都在建表的时候想着增加索引肯定会使用上索引，往后一段时间也确实使用上了，然而随着数据的慢慢增加，反而不再使用索引了，导致线上一大堆慢 SQL，从而导致一系列其他的问题。下面就以一个时间范围的 SQL 查询和一个模糊查询为例，来看看在优化的过程中所遇到的问题。</p>
<p>针对时间范围查询的优化</p>
<p>这里以之前新建的 activities 表为例，刚开始这张表除了主键索引之外，没有建任何其他的索引，建表语句如下:</p>
<p>1<br>create table activities<br>2<br>(<br>3<br>  id bigint unsigned auto_increment comment ‘主键’ primary key,<br>4<br>  name varchar(255) default ‘’ not null comment ‘活动名称’,<br>5<br>  city_code varchar(64) default ‘’ not null comment ‘城市编码’,<br>6<br>  start_time timestamp default CURRENT_TIMESTAMP not null comment ‘开始时间’,<br>7<br>  end_time timestamp default CURRENT_TIMESTAMP not null comment ‘结束时间’,<br>8<br>  status tinyint unsigned default ‘0’ not null comment ‘状态:0-待启用,1-待生效,2-生效中,3-已结束,4-已禁用’,<br>9<br>  create_time timestamp default CURRENT_TIMESTAMP not null comment ‘创建时间’,<br>10<br>  update_time timestamp default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment ‘更新时间’<br>11<br>) comment ‘活动表’ CHARSET=utf8mb4;<br>现在我们的业务中有这样一个需求，需要为每一个用户匹配当时能够参加的活动，这里声明下这里的活动都是短期活动，而不是要举行好多年的那种活动。</p>
<p>从表结构来看筛选的条件主要有城市编码，时间段以及活动的状态，对应的查询 SQL 如下：</p>
<p>1<br>select * from activities where city_code = ‘用户所在城市编码’ and start_time &lt; now() and end_time &gt; now() and status = 2;<br>如果直接这样去执行，肯定是全表扫描，explain 的执行结果 type 列的值是 all，刚开始数据量不大，当然也是可以接受的，但随着活动创建的越来越多直接全表扫描肯定就不行了，所以在一开始我们就要考虑好该怎么去建索引，从上面的查询 SQL 来看第一反应是在时间字段上建立索引，因为随着这张表的数据量在慢慢增加，城市编码和状态字段不会增加，还是大致分布在经常举办的城市，状态字段就更不用说了，一直都是那几个状态，它们的区分度都不如时间字段，所以我们可以考虑在时间字段上建立索引。</p>
<p>现在时间字段有两个，一个是开始时间，一个是结束时间，我们先在开始时间这个字段上建索引看看，下面是建立索引前后 explain 执行的结果:</p>
<p>image-20220503154047423</p>
<p>image-20220503154136064</p>
<p>上面 activities1 是没建索引的表结构，activities2 是建了索引的表结构，里面的数据是一样的，可以看到建了索引之后的查询也确实使用了索引 idx_start_time，同时 Extra 里面还出现了 Using index condition; Using where 的信息， 说明这里还使用了索引下推的优化，为什么会使用上索引下推的优化呢，这里由于 type 里面是 range，说明是范围查询，范围查询里面会涉及到 Index Key 的提取规则，用于确定 SQL 查询在索引中的连续范围的查询条件，我想是因为这个原因才会利用到索引下推的优化，具体我还没有深入研究过，感兴趣的可以去试着研究看看。</p>
<p>上面的 SQL 我们还可以进一步的进行优化，由于每次查询都会将开始结束字段都作为条件，因此可以建立一个联合索引来进一步达到索引下推的效果，idx_start_end_time(start_time, end_time)，一切看起来好像都没什么问题，但随着时间的推移，活动越办越多之后，我们可能会发现上面的 SQL 执行的越来越慢了，这是为什么呢？于是通过 explain 一看发现没有走索引而是直接全表扫描去查询。</p>
<p>image-20220503174457289</p>
<p>那么这又是为什么呢，通过分析其实也不难发现，首先可以看到 possible_keys 字段里面确实有出现 idx_start_end_time，说明 MySQL 知道有这个索引的存在，但在评估之后没有去使用，再一个可以看到 rows 字段中预估要扫描的行数多达 11 万多，目前这个表有 100 万数据，按理来说通过索引来查会更快一些，但是别忘了通过索引查询还有一个回表的过程，于是 MySQL 评估直接走全表扫描会更划算，全表扫描也就是直接扫描主键索引树，主键索引树包含了全部字段数据，可以直接进行判断和读取数据，那这么评估是否准确呢？我们尝试强制走索引看看</p>
<p>image-20220503180509420</p>
<p>可以看到强制走索引确实也使用了索引，预估扫描行数从 11 万多降到 5 万多，但回表次数也要达到接近 5 万多或者少一点，这样看起来好像也没好多少，这还只是 100 万的数据，但随着时间推移活动越办越多，数据量越大就会发现走索引扫描的行数也越来越多，因为从联合索引 idx_start_end_time(start_time,end_time) 来看，start_time &lt; now() 的条件只能用上联合索引的前缀 start_time 部分，通过 start_time &lt; now() 判断会发现满足的数据行越来越多，因为活动表里除了还未开始的活动基本上所有活动都是满足 start_time &lt; now()，因此这个条件几乎没怎么为我们过滤数据，所以 MySQL 评估下来还不如直接全表扫描来的快。</p>
<p>那怎么优化呢，其实很简单，将上面联合索引的两个字段换个顺序就好了， idx_start_end_time(start_time,end_time) 换成  idx_end_start_time(end_time, start_time)，这样就能利用上 end_time &gt; now() 的条件了，针对活动表，越往后肯定大部分活动都已经结束了，已经结束的活动不可能满足 end_time &gt; now() 的条件，因此经过 end_time &gt; now() 的条件筛选之后剩下的也就没有多少数据了。</p>
<p>image-20220503181832129</p>
<p>从执行结果来看就算我们没有强制 SQL 使用索引，MySQL 评估之后也会使用 idx_end_start_time 的索引，同时由于我的 activities 表中所有活动都已经结束了，所以 SQL 的预估扫描行数只有 1，仅仅一个索引字段顺序的问题就能有如此差别，所以在日常开发中，我们不要想当然的以为建个索引就会走索引查询了，其实不然，MySQL 在评估的时候会综合考虑多方面的因素，其中数据的分布尤其重要，而范围查询的过滤效果更是依赖于数据的分布，很可能由于数据分布的问题就导致 SQL 没有使用索引，直接全表扫描。</p>
<p>索引扫描和索引搜索</p>
<p>对于 type 列，上篇文章中提到了它表示查询所执行的类型，通过它可以看出 SQL 是如何执行的，是等值查询还是范围查询，是遍历索引还是直接全表扫描，同时在查看 key 这一列就可以看出当前的 SQL 查询有没有使用索引，但是否看到使用了索引就足够了呢？</p>
<p>其实一个 SQL 查询过程中都会使用索引，就算 type 列里面的值是 all 也是使用了索引的，只不过我们通常都会说成是全表扫描，但其实它扫描的是主键索引树，这不过这种方式被我们认为是比较低效的，相当于需要遍历整个索引树才能得到结果，还有一个就是扫描二级索引树，也是一样的要遍历整个二级索引树，因此我们对于索引的使用需要注意区分，到底是索引扫描还是索引搜索。</p>
<p>同样还是以 activities 表为例，然后在 name 字段上建立索引，现在有下面五个 SQL 语句:</p>
<p>1<br>select id, name from activities where name = ‘活动1’;<br>2<br>select id, name from activities where name like ‘活动1’;<br>3<br>select id, name from activities where name like ‘活动1%’;<br>4<br>select id, name from activities where name like ‘%活动1’;<br>5<br>select id, name from activities where name like ‘%活动1%’;<br>如果问你上面五个 SQL 语句里面哪几个会使用索引，哪几个不会？你觉得是怎样的呢？其中第一个 SQL 和第二个 SQL 效果是一样的，只不过第一个 SQL explain 的结果 type 是 ref，而第二个是 range，剩下三个在日常开发中或多或少见过，并且说的最多的是第三个 SQL 查询以什么开头的 SQL 会使用索引，第四个和第五个都不会使用上索引，那事实真的是这样的吗？下面我分别贴出这五个 SQL explain 出来的结果。</p>
<p>image-20220504114521004</p>
<p>从执行结果可以看出，第一个 SQL 的查询 type 类型是 ref，使用的索引是 idx_name，预估扫描行数为 1，同时 Extra 里面有 Using index 的信息，表示使用上了索引覆盖的优化，因为我们只查询了 id 和 name 两个字段，直接通过 idx_name 索引树就可以得到，因此可以达到索引覆盖的优化条件。</p>
<p>image-20220504114636205</p>
<p>第二个 SQL 的查询和第一个不同的是 type 类型是 range，使用的索引是 idx_name，预估扫描行数也是 1，同时 Extra 里面也有 Using index 的信息，同样使用上了索引覆盖的优化，同时还有 Using where 的信息，和上面我提到的范围查询涉及到 Index Key 的提取规则场景应该是一样的。</p>
<p>image-20220504114832942</p>
<p>image-20220504115704922</p>
<p>image-20220504115907002</p>
<p>后面三个 SQL 的执行计划，这三个 SQL 看起来都是用上了索引 idx_name，也都使用上了索引覆盖的优化，但可以看到后面两个 SQL 的 type 类型是 index，预估扫描行数都是 11 万多，而第三个 SQL 的 type 是 range，预估扫描行数只有 1，从结果来看这五个 SQL 其实都使用了索引，但查询效果却并不是一样的。</p>
<p>前三个 SQL 查询使用的是索引搜索，而后两个使用的索引扫描，它只比全表扫描快一些，但也还是很慢的，这种查询还需要进行优化，因此在评估查询是否走索引时需要注意采用的是索引搜索还是索引扫描，如果是索引扫描的话还需要再进一步优化，要么从业务层面进行优化，要么增加其他索引条件进行查询。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Explain 的使用解析</title>
    <url>/Explain-%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h4 id="SQL-执行速度评估"><a href="#SQL-执行速度评估" class="headerlink" title="SQL 执行速度评估"></a>SQL 执行速度评估</h4><p>假如现在有一张活动表，表结构如下:</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table activities</span><br><span class="line">(</span><br><span class="line">    id bigint unsigned auto_increment comment &#39;主键&#39; primary key,</span><br><span class="line">    name varchar(255) default &#39;&#39; not null comment &#39;活动名称&#39;,</span><br><span class="line">    city_code varchar(64) default &#39;&#39; not null comment &#39;城市编码&#39;,</span><br><span class="line">    start_time timestamp default CURRENT_TIMESTAMP not null comment &#39;开始时间&#39;,</span><br><span class="line">    end_time timestamp default CURRENT_TIMESTAMP not null comment &#39;结束时间&#39;,</span><br><span class="line">    status tinyint unsigned default &#39;0&#39; not null comment &#39;状态:0-待启用,1-待生效,2-生效中,3-已结束,4-已禁用&#39;,</span><br><span class="line">    create_time timestamp default CURRENT_TIMESTAMP not null comment &#39;创建时间&#39;,</span><br><span class="line">    update_time timestamp default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment &#39;更新时间&#39;</span><br><span class="line">) comment &#39;活动表&#39; CHARSET&#x3D;utf8mb4;</span><br><span class="line">create index idx_city_code on activities(city_code);</span><br><span class="line">create index idx_create_time on activities (create_time);</span><br><span class="line">create index idx_start_end_time on activities (start_time, end_time);</span><br></pre></td></tr></table></figure>

<p>业务中需要查询目前正在生效中的活动有哪些，查询SQL 是下面这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from activities where start_time &lt; now() and now() &lt; end_time;</span><br></pre></td></tr></table></figure>

<p>以我们对索引的了解，活动表上已经建了 start_time 和 end_time 的联合索引 idx_start_end_time，上面的 SQL 肯定会通过 idx_start_end_time 索引去查询，因此上面的 SQL 执行速度应该不会慢的，但事实上真的是这样吗，如果不是这样的话，我们该如何去评估这个 SQL 的执行速度呢，那就是通过 EXPLAIN 指令，也是我们今天要重点介绍的内容，通过 explain 的执行结果我们可以看到以下内容：</p>
<p>1.SQL 语句中表的查询顺序</p>
<p>2.SQL 的查询类型</p>
<p>3.查询的是哪个分区表</p>
<p>4.走的是哪个索引</p>
<p>5.查询扫描行数</p>
<p>6.SQL 的执行方式</p>
<p>通过对这些内容进行分析之后我们就可以优化我们的 SQL 语句或者表的索引结构，进一步提高我们的查询效率</p>
<h4 id="EXPLAIN-语法介绍"><a href="#EXPLAIN-语法介绍" class="headerlink" title="EXPLAIN 语法介绍"></a>EXPLAIN 语法介绍</h4><p>对于 explain 的使用，其实很简单，只要在要执行的 SQL 语句前面加上 explain 关键字就可以，以上面的 SQL 为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from activities where start_time &lt; now() and now() &lt; end_time;</span><br></pre></td></tr></table></figure>

<p>执行结果如下:<br><img src="/images/explain_intro.png" alt="image-20220423230701278"></p>
<p>从执行结果来看，有点类似于在查询一张包含上面输出结果中的这些字段的表一样，这些字段包括 id，select_type, table,partitions, type, possible_keys, key, key_len, ref, rows, filtered, Extra，这些字段当中有些我们稍微了解一下就可以，有些字段对于我们优化 SQL 有很大的帮助，需要重点关注</p>
<p>针对下面的示例，这里先准备一些表作为测试使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table cities</span><br><span class="line">(</span><br><span class="line">    id bigint unsigned auto_increment comment &#39;主键&#39; primary key,</span><br><span class="line">    name varchar(255) default &#39;&#39; comment &#39;城市名称&#39;,</span><br><span class="line">    code varchar(64) default &#39;&#39; not null comment &#39;城市编码&#39;</span><br><span class="line">) comment &#39;城市编码表&#39;;</span><br><span class="line">create index idx_name on cities(name);</span><br><span class="line">create unique index uk_code on cities (code);</span><br></pre></td></tr></table></figure>

<h4 id="EXPLAIN-各字段含义"><a href="#EXPLAIN-各字段含义" class="headerlink" title="EXPLAIN 各字段含义"></a>EXPLAIN 各字段含义</h4><p>上面我们提到通过 explain 的执行结果我们可以看到 SQL 执行过程中的一些关键信息，执行结果中每个字段都代表着不同的含义，在理解了这些字段的含义后，对我们优化 SQL 或索引都会起到很大的作用，我们来依次介绍这些字段的含义</p>
<p>id，table: id 和 table 两个字段可以放在一起来看，id 的值代表了 SQL 语句中表的读取顺序，值越大读取顺序越靠前，当 id 值相同时，table 列按照从上往下的读取顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from activities where city_code &#x3D; (select code from cities limit 1);</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_table_sequence.png" alt="image-20220425204607073"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from activities t1 join cities t2 on t1.city_code &#x3D; t2.code;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_id_sequence.png" alt="image-20220425204446829"></p>
<p>select_type: 表示 SQL 语句的查询类型，常见的值有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SIMPLE：简单查询，不包含 UNION 或者子查询</span><br><span class="line">PRIMARY：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY</span><br><span class="line">SUBQUERY：子查询中的第一个 SELECT 查询</span><br><span class="line">UNION：在 UNION 语句中，UNION 之后出现的 SELECT</span><br><span class="line">DERIVED：在 FROM 中出现的子查询将被标记为 DERIVED</span><br><span class="line">UNION RESULT：UNION 查询的结果</span><br></pre></td></tr></table></figure>

<p>partitions: 如果查询的表是分区表，表示命中的数据记录所在的分区，对于不是分区表，值为 NULL</p>
<p>type: 表示查询所执行的类型，通过它可以看出查询是如何执行的，这一列可以说是我们要重点优化的对象，它的值比较重要，主要有以下类型:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure>

<p>上面这些类型从左到右，查询性能依次降低，这里先不详细介绍每种类型的执行效果，先知道有这些类型即可，后面和 Extra 字段一起统一重点介绍。</p>
<p>possible_keys: 表示查询可能使用到的索引，也有可能里面的索引一个都没用到，取决于优化器分析之后的结果，也就是有可能该列上存在索引，但优化器分析之后决定不使用该索引</p>
<p>key: 表示查询过程中使用的索引，如果为 null 则表示该查询没有使用索引，该列的值有可能存在 possible_key 列中没有出现的索引，同时当查询满足覆盖索引的条件时，possible_keys 列为 NULL，索引仅在 key 列显示</p>
<p>key_len: 表示查询过程中使用的索引字节数</p>
<p>ref: 表示在查询索引时，哪些列或者常量被用来和索引的值进行比较</p>
<p>rows: 表示查询过程中预估需要扫描的行数，注意这是一个估算的值，并不是具体的值</p>
<p>filtered: 表示通过索引查询之后匹配到的数据量再经过 server 层 where 条件判断过滤之后剩余数据比例，比如说根据索引条件查询满足条件的数量是 100，经过其他条件过滤之后返回的结果数剩 60，filtered 的值就是 60%，通常这个值越大越好，直接经过索引条件查询得到的结果数就是最终查询的结果数肯定效率是更高的，但也不用过多的关注这个值，这个值对 SQL 性能的整体提升相比其他更重要的字段(type, Extra)来说并不是非常明显</p>
<p>Extra: 表示 SQL 语句执行过程中一些额外的关键信息，常见的值有:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Using where，Using index，Using index condition，Using index for group-by，Using join buffer (Block Nested Loop)，Using join buffer (hash join)，Using join buffer (Batched Key Access)，Using filesort，Using temporary</span><br></pre></td></tr></table></figure>

<h4 id="Type-列解析"><a href="#Type-列解析" class="headerlink" title="Type 列解析"></a>Type 列解析</h4><p>对于一个 SQL 的优化，我们重点应该关注的是 Type 和 Extra 这两个字段，或者说这两个字段展示出来的信息几乎关系着整个 SQL 执行效率，先来看 Type 字段常见的值的含义:</p>
<p>const: 主要是在通过主键或者唯一键等值查询的时候，type 字段的值是 const</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from cities where code &#x3D; &#39;330100&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_type_const.png" alt="image-20220426192431443"></p>
<p>eq_ref: 在联表查询查询时，A 表 join B 表，B 表是通过主键或者唯一键进行关联时，也就是在 A 表中只有唯一一条记录和 B 表中数据相匹配，那 B 表的 type 字段值就是 eq_ref 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from activities t1 join cities t2 on t1.city_code &#x3D; t2.code;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_type_eq_ref.png" alt="image-20220426193145085"></p>
<p>ref: 通过普通索引进行等值查询，也就是表中可能有多条数据记录匹配，那 type 字段值就是 ref 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from cities where name &#x3D; &#39;杭州&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_type_ref.png" alt="image-20220426195602499"></p>
<p>ref_or_null: 通过普通索引进行等值查询，或者该字段为 null 的情况，注意该字段不能设置为 not null，那 type 字段值就是 ref_or_null 类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from cities where name &#x3D; &#39;杭州&#39; or name is null;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_type_ref_or_null.png" alt="image-20220426200127808"></p>
<p>index_merge: 在 where 条件中的字段需要利用多个索引进行查询，这时 type 字段值就是 index_merge 类型，常见于多个索引字段进行 or 查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from cities where code &#x3D; &#39;330100&#39; or name &#x3D; &#39;杭州&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_type_index_merge.png" alt="image-20220426201022049"></p>
<p>range: 索引范围查询，这个可能见的相对比较多一点，常见于带 &lt;&gt;，&gt;，&gt;=，&lt;，&lt;=，between，in，like 等这些查询条件语句中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from activities where start_time &gt;&#x3D; now();</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_type_range.png" alt="image-20220426234344870"></p>
<p>index: 通过遍历索引树就能够得到相应的数据，相比下面的 All 类型来说要好一些，索引文件大小肯定要比数据文件大小要小，而且索引的根节点和第二层节点大概率处于内存当中，相对来说会更快一些，但注意这是索引树扫描，相比其他索引定位查询还是要慢很多的，所以不要看到使用上了索引就以为查询不慢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select id, name from cities;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_type_index.png" alt="image-20220427000036479"></p>
<p>All: 这个就是通常我们所说的没有可用的索引可以利用，直接全表扫描，相对来说性能是最差的，最直接的方法就是通过加索引来避免全表扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from activities where name &#x3D; &#39;活动一&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_type_all.png" alt="image-20220426235124506"></p>
<h4 id="Extra-列解析"><a href="#Extra-列解析" class="headerlink" title="Extra 列解析"></a>Extra 列解析</h4><p>上面已经介绍了 Type 字段常见的一些值的含义，但有时还需要配合 Extra 一起来看才能更好的进行优化，接下来我们一起来看 Extra 字段常见值含义:</p>
<p>no matching row in const table: 通常根据主键查询的数据在表中不存在，Extra 列的值是这个</p>
<p><img src="/images/explain_extra_no_matching.png" alt="image-20220430181005220"></p>
<p>Using index: 表示利用到了我们在之前文章里面提到的索引覆盖优化功能，通常是要查询的字段以及条件字段都已经在索引中存在，也就是说通过索引树就可以满足查询条件以及结果，不需要再到主键索引树中查询该记录完整的数据，减少回表的过程</p>
<p><img src="/images/explain_extra_using_index.png" alt="image-20220430182906088"></p>
<p>Using index for group-by: 和 Using index 意思差不多，不过就是查询语句中如果包含了 distinct 和 group by 关键字的时候 Extra 里面的内容就是 Using index for group-by 了</p>
<p><img src="/images/explain_extra_using_index_for_group_by.png" alt="image-20220430204616024"></p>
<p><img src="/images/explain_extra_using_index_for_group_by1.png" alt="image-20220430204709766"></p>
<p>Using index condition: 表示利用到了在我们在之前文章里面同样提到过的索引下推优化功能，在 “仅能利用最左前缀索引的场景” 下(无法能利用全部联合索引)，对不在最左前缀索引中的其他联合索引字段加以利用，在遍历索引时，由只传入可以利用到的字段值，改成了多传入下推字段值进行过滤，过滤会减少遍历索引查出的主键条数，从而减少回表次数，提升整体性能，对于 Using index 和 Using index condition 不是很熟悉的话建议去看之前的文章 &lt;&lt;深入索引二&gt;&gt;</p>
<p><img src="/images/explain_extra_using_index_condition.png" alt="image-20220430183309242"></p>
<p><img src="/images/explain_extra_using_index_condition1.png" alt="image-20220502110908831"></p>
<p>Using where: 表示该查询需要在 Server 层得到存储引擎返回的结果之后需要再次进行过滤，这种情况可能使用了索引，只不过存在其他条件不在索引字段中，也有可能就完全没有使用索引</p>
<p><img src="/images/explain_extra_using_where.png" alt="image-20220430202912973"></p>
<p><img src="/images/explain_extra_using_where1.png" alt="image-20220430203040134"></p>
<p>Using join buffer (Block Nested Loop): 表示在 join 联表查询的时候，当被驱动表的联表字段上没有索引的时候，Extra 里面就会出现这个值，但注意的是在 MySQL 8.0 版本之后 Extra 里面的值是 Using join buffer (hash join)，当出现不管是 Using join buffer (Block Nested Loop) 还是 Using join buffer (hash join) 我们都应该想办法进行优化，简单的做法就是在被驱动表的关联字段上建索引</p>
<p><img src="/images/explain_extra_using_join_buffer_bnl.png" alt="image-20220502132957893"></p>
<p><img src="/images/explain_extra_using_join_buffer_hash.png" alt="image-20220502122513317"></p>
<p>Using join buffer (Batched Key Access): 表示在 join 联表查询的时，当被驱动表的联表字段上有索引，Extra 里面就会出现这个值，但注意的是需要将下面的优化开关设置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set optimizer_switch&#x3D;&#39;mrr&#x3D;on,mrr_cost_based&#x3D;off,batched_key_access&#x3D;on&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/explain_extra_using_join_buffer_bka.png" alt="image-20220502121822919"></p>
<p>Using temporary: 表示该查询需要借助临时表来存储中间查询结果才能进一步得到最终的查询结果，通常存在于 group by 的查询语句，同时又没有使用到索引的情况，这种 SQL 一般都需要优化</p>
<p><img src="/images/explain_extra_using_temporary.png" alt="image-20220430210911712"></p>
<p>Using filesort: 表示该查询没办法利用现有的索引对结果进行排序，而需要借助第三方存储空间来进行排序才能得到最终的排序结果，通常存在于包含 order by 的查询语句中，同时又没有使用到索引的情况，这种 SQL 一般都需要优化</p>
<p><img src="/images/explain_extra_using_filesort.png" alt="image-20220430211338265"></p>
<p>好了，上面主要介绍了 explain 执行结果中的一些字段含义，type 字段和 Extra 字段里面常见的一些值以及这些值的含义，通过熟悉这些我们可以大概知道 SQL 是怎么执行的，执行的速度怎么样，是否还有优化空间，下篇文章就来看两个常见的 SQL 优化案例。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 中垃圾收集器简单介绍</title>
    <url>/JVM-%E4%B8%AD%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>之前我们简单提到了 JVM 中的垃圾收集算法，比较常见的包含有标记-清除算法，标记-复制算法，标记-整理算法，那么针对这些算法的各种具体实现也就有了 JVM 中使用的各种垃圾收集器，对于这些垃圾收集器，简单一点可以直接按照新生代和老年代来进行划分，<strong>针对新生代中使用的垃圾收集器有: Serial，Parallel New，Parallel Scavenge，针对老年代中使用的收集器有：Serial Old，Parallel Old，CMS(Concurrent Mark Sweep)。</strong>正是因为没有一款收集器能够适用于所有场景，所以才有了各种场景下的收集器出现。</p>
<a id="more"></a>

<p>目前随着 JVM 版本的不断迭代更新，同时也对垃圾收集器的不断优化，最新的已经出现了一些更为优秀的垃圾收集器，比如说 **G1(Garbage First)**，它是一个横跨新生代和老年代的的垃圾回收器；同时还有宣称能够将暂停时间控制在 10ms 以内的 **ZGC(Z Garbage Collector)**，这些都是随着我们内存越来越大，然后对于低延迟的不断追求而产生的一系列优秀的收集器。</p>
<h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial 收集器它算是最古老，也是最基础的新生代垃圾收集器，基于标记-复制算法实现，同时它是工作在单线程模式下，但这里单线程模式需要注意下，它不仅仅是说明它只是采用单条线程来进行垃圾收集工作，同时也强调垃圾收集线程和用户的工作线程不能同时进行工作，垃圾线程工作时需要暂停用户的工作线程，这也就是臭名昭著的“Stop The World”状态，而后来的垃圾收集器也一直在为缩短这个状态的停留时间而努力优化改进。</p>
<p>正因为 Serial 收集器是单线程工作，实现简单，不需要复杂的数据结构来存储额外的数据，因此它也一直是工作在 Client 模式下的 JVM 垃圾收集器的首选项。</p>
<h3 id="Parallel-New-收集器"><a href="#Parallel-New-收集器" class="headerlink" title="Parallel New 收集器"></a>Parallel New 收集器</h3><p>Parallel New 收集器是 Serial 收集器的多线程版，也就是说它采用多线程的方式来完成垃圾收集工作，但不可避免的在垃圾收集线程工作时还是要暂停用户的工作线程，其他的则和 Serial 收集器差不多，也是新生代收集器，基于标记-复制算法实现。常见的应用场景是配合老年代的 CMS 收集器一起工作，但随着垃圾收集器的不断优化迭代，更为优秀的垃圾收集器 G1 出现之后，它打乱了堆中新生代和老年代的划分结构，因此自从 G1 出现之后，Parallel New 收集器也就开始慢慢退出历史的舞台了。</p>
<h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器则和 Parallel New 收集器差不多，都是新生代收集器，使用多线程的方式完成垃圾收集工作，基于标记-复制算法实现，但它特殊的地方在于它更加注重吞吐率，这里的吞吐率表示的是用户线程工作时长与垃圾收集线程工作时长加上用户线程工作时长之和的比值，Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，一个是控制最大垃圾收集停顿时间 -XX: MaxGCPauseMillis，还一个是直接设置垃圾收集时间占总时间的比值 -XX:GCTimeRatio，前者是一个大于 0 的毫秒数，当然 JVM 也只是会尽力去控制这个垃圾收集时间接近于设置的值，后者是一个大于 0 小于 100 的整数百分比，相当于吞吐率的倒数。</p>
<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><h3 id="Serial-Old，Parallel-Old-收集器"><a href="#Serial-Old，Parallel-Old-收集器" class="headerlink" title="Serial Old，Parallel Old 收集器"></a>Serial Old，Parallel Old 收集器</h3><p>Serial Old 收集器是 Serial 收集器的老年代版本，同样是单线程的，但它是基于标记-整理算法实现。</p>
<p>Parallel Old 收集器则是 Parallel Scavenge 收集器的老年代版本，采用多线程的方式进行收集，基于标记-整理算法实现。</p>
<h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS 收集器是基于标记-清除算法实现，并且是并发的，目标是尽量减少停顿时间，它只有少数几个操作需要 Stop The World，大部分是可以在用户程序运行过程中并发进行垃圾回收，当并发收集失败之后则会使用上面两个整理型垃圾回收器进行回收。</p>
<p>由于是基于标记-清除算法实现，这意味着会存在内存碎片问题，因此在长时间运行之后会产生 Full GC，既然发生了 Full GC 自然就会导致更长时间的停顿。而且由于是并发的，那么在并发收集的过程中也就不可避免会存在垃圾收集线程和用户工作线程互相竞争资源的情况，这些都是 CMS 收集器的比较明显的缺陷。</p>
<h2 id="更多优秀收集器"><a href="#更多优秀收集器" class="headerlink" title="更多优秀收集器"></a>更多优秀收集器</h2><p><strong>G1(Garbage First)</strong></p>
<p>G1 收集器是有点打破了之前将整个堆区按照分代区域划分的常规做法，它是以 Region 为单位将堆区划分为一个一个的 Region，然后每个 Region 都可以作为 Eden 区，Survivor 区或老年代，Region 之间是基于标记-复制算法实现，而整体上则是采用标记-整理的算法，可以有效避免内存碎片。在进行垃圾回收时，以 Region 来作为最小回收单元，当然不会每次都对全部的 Region 进行回收，而是对最有回收价值的那些 Region 区域进行回收，也就是优先回收死亡对象较多的区域，这样才能获得更好的回收效果，同时这也是为什么收集器的名称要叫 Garbage First。而且随着 G1 收集器的到来，CMS 收集器也开始逐渐被舍弃，在 JDK9 里面已经被标记为废弃了。</p>
<p>随着 JVM 的优化迭代，慢慢的已经有了更多更为优秀的垃圾收集器涌现出来，比如说 Shenandoah GC，ZGC，Epsilon GC，说实话这些收集器我也没有仔细去看过他们的特性，只是听说它们在进行垃圾收集时延迟可以做到更低，尤其是对于目前随着硬件配置越来越高的情况下，内存占用以及吞吐量都可以直接得到优化，但对于延迟的影响却是相反的，内存越大，垃圾收集占用的时间越长，同时这也会间接影响到用户线程的正常工作，因此目前对于低延迟的垃圾收集器更是迫在眉睫。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于上面提到的这些收集器的工作方式我只是做了个大概的介绍，更多的细节我建议还是去仔细看看 《深入理解 Java 虚拟机》这本书，当然最终的目的是根据这些收集器的特征，然后结合我们的实际应用，给这些收集器配置合理的参数，来达到我们想要的优化效果。可能上面这些描述你看起来觉得很简单，但其实每个收集器后面的实现细节都是非常复杂的，尤其是后面不断涌现出来的收集器，它们的工作方式以及实现细节更是复杂，可能我们说起来就是那么几句话，但背后的细节原理还是需要花好些时间去深入研究的，毕竟每个收集器都是经历过那么多的服务器实践优化之后才正式进入我们的视野，感兴趣的话可以去深入研究这些细节。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 的垃圾收集算法</title>
    <url>/JVM-%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在《Java 中对象和数组的创建》一文中我们主要介绍了在 Java 虚拟机中创建一个对象的完整过程，而我们的程序在运行时可能无时无刻不在创建对象，每创建一个对象就需要在堆中进行内存分配，可是堆内存大小毕竟是有限的，总会有用完的时候，那如果用完了该怎么办呢？</p>
<a id="more"></a>

<p>在我们 Java 编码的过程中好像确实没有关注过这个问题，需要对象的时候就创建，似乎内存真的是用不完的，然而事实并非如此，这主要得益于 JVM 强大的垃圾自动回收技术，因为我们创建的对象并非所有的对象都是伴随着程序执行开始到结束的，反而大部分对象在方法执行结束或者线程执行完毕时就不再需要了，那么这部分对象的内存就可以进行回收二次利用，这才使得内存看起来用不完一样。</p>
<p>对于 JVM 的运行时数据区域，我们已经知道程序计数器，虚拟机栈，本地方法栈都是随着线程的创建而创建，随着线程结束同样也就结束了，这几个区域的回收都是相对比较确定的。而对于堆区和方法区来说是在 JVM 启动时创建，所有线程共享的区域，这部分区域的内存在程序运行过程中时刻都在变化，因此 JVM 的垃圾自动回收主要关注这两个区域，当然对于方法区的垃圾回收相对于堆区来说效率并没有那么高，它主要针对废弃常量和无用类，在该区域可回收的内存有限，那么垃圾回收的主战场自然也就落在了堆区。</p>
<h3 id="如何判定对象是否还存活"><a href="#如何判定对象是否还存活" class="headerlink" title="如何判定对象是否还存活"></a>如何判定对象是否还存活</h3><p>既然要对不再需要的对象进行回收，那么首先就需要判定哪些对象是不再需要了的，如何判定呢？目前主要有以下两种方式:</p>
<h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><p>引用计数算法通过对 Java 程序中的对象引用进行计数的方式来判定，每一个对象都有一个引用计数器，当有一个地方引用了该对象时，对象的引用计数器就加一，引用失效计数器减一，当对象的引用计数器是 0 时就认为该对象可以被回收了。这种方式看起来很简单，但是它有一个致命的问题：循环引用问题。比如说 A 对象中引用了 B 对象，B 对象也引用了 A 对象，他们之间互相引用，它们俩的引用计数器都不为 0，但是除了他们之间互相引用之外没有其他任何地方引用了这两个对象，事实上这两个对象的内存也是可以被回收的，但由于引用计数器不为 0 从而没有被回收，因此这种判定方式也没有作为 JVM 判定对象不再存活的方式，而是采用了下面的可达性分析算法。</p>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>可达性分析算法是通过一些 GC Roots 的对象来作为起点，然后往下搜索，搜索所经过的路径称为引用链，当一个对象没有任何一条引用链可达时，那就说明该对象不可达，也就间接说明该对象内存可以被回收了。这种方式就解决了上面所说的循环引用问题，比如说下图中 Object6 和 Object7 虽然相互引用，但是从 GC Roots 到这两个对象已经没有引用链可达了，因此这两个对象都可以被回收。</p>
<p><img src="/images/GC_Roots.png" alt="GC_Roots"></p>
<p>这种判定方式的关键在于如何确定 GC Roots 对象，在 Java 中下面这几种对象可作为 GC Roots 对象:</p>
<ul>
<li>虚拟机栈栈帧中本地变量表所引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量所引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ul>
<p>虽然说上面的定义看起来挺简单的，但真正实现过程中需要考虑的问题就很多了，由于在确定这些 GC Roots 对象的同时，这些区域的对象也是在实时变化的，就算确定好了这些对象之后，还要经历从这些对象开始进行搜索的过程，而这个过程对象也是在时刻变化的，这些都是在具体实现的过程中需要考虑的问题。</p>
<h3 id="分代收集思想"><a href="#分代收集思想" class="headerlink" title="分代收集思想"></a>分代收集思想</h3><p>在介绍垃圾收集算法前，我们先来了解一下堆中的分代收集的思想，也许你之前听说过新生代和老年代，新生代的对象在经历多次垃圾收集之后便会移动到老年代，那么这里面具体是怎么回事呢？首先分代收集主要是基于堆中对象的两大特性而产生的，这两大特性就是:</p>
<ol>
<li><p>堆中的大部分对象都是朝生夕死的，也就是说大部分对象往往创建完使用一次就不再需要了</p>
</li>
<li><p>在经历多次垃圾收集之后还存活的对象往往是一直有用的，这种对象存活的时间更长</p>
</li>
</ol>
<p>基于这两个特性，可以将堆区分成两块区域，每次创建对象只在其中一块区域分配内存，根据第一个特性垃圾收集可以在该区域取得很好的效果，大部分对象都可以进行回收，在经历几次回收还存活着的对象可以根据第二个特性将这类对象移至另一个区域，该区域的垃圾收集可以在内存实在紧张时再进行回收，毕竟这部分区域回收的效果有限。</p>
<p>上面就是分代收集的大致思路，在 JVM 中对上面的描述更具体的实现方式是将堆区分为新生代和老年代两个区，而新生代中又分成一块较大的 Eden 区和两块同等大小的 Survivor 区(一个称为 from，另一个称为 to)，每次创建对象在优先 Eden 区和 from 区中分配内存，在垃圾收集发生时，将 Eden 区和 from 区中还存活的对象移动到 to 区，然后清空 Eden 区和 from 区，这时将刚才 Survivor 区中的 from 区称为 to 区，to 区称为 from 区，接下来创建对象则在此时的 Eden 区和 from 区分配内存，也就是说 Survivor 区中每次都有一块区域是空着的，对于 Eden 区，from 和 to，它们的比例是 8:1:1，相当于每次只有 10% 的区域是空着的，这不至于浪费太多空间。</p>
<p>但也只是假设每次垃圾收集之后新生代存活下来的对象只有新生代内存大小的 10%，一旦超过这个大小就需要考虑将新生代的对象移至老年代中。在经历了多次垃圾收集之后就很有可能只占 10% 空间的 Survivor to 区中没有足够的内存来存放 Eden 区和 from 区中还存活的对象，这时就需要将部分年龄较大的对象移至老年代了，通常一次垃圾收集存活下来的对象年龄会加一，年龄超过一定大小(默认 15 岁)之后就会进入老年代，还有一种情况是针对大对象的分配，当新生代中无法为一个大对象进行内存分配时，这个对象也会直接在老年代分配内存。</p>
<p>当然在分代收集思想中其实存在一个”跨代引用”的问题，那就是在新生代垃圾收集判定对象是否存活时，其中有的对象可能被老年代对象所引用，那么在新生代收集时是否需要对整个老年代进行扫描呢？本来分代收集就是为了提高垃圾收集的效率，如果依然需要对老年代进行扫描，那分代收集没有多大意义了，而这种情况又该如何解决呢？常见的做法是在新生代中开辟一小块区域来存储老年代中存在跨代引用的对象的区域，在新生代发生垃圾收集时就只会扫描老年代中存在跨代引用的部分区域，从而避免了扫描整个老年代。</p>
<p>在介绍完新生代和老年代之后，根据对堆区不同区域产生的垃圾收集行为可分为部分收集(Partial GC)和完整收集(Full GC)，部分收集指只收集堆中的部分区域，其中针对新生代的收集称为 Minor GC 或 Young GC，针对老年代的收集称为 Major GC 或 Old GC。而完整收集一般是在内存比较紧张时才会触发的整个堆区和方法区的垃圾收集。</p>
<h3 id="常见的几种垃圾收集算法"><a href="#常见的几种垃圾收集算法" class="headerlink" title="常见的几种垃圾收集算法"></a>常见的几种垃圾收集算法</h3><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>标记-清除算法正如名称所描述的那样，先对存活对象进行标记，然后再统一回收未标记的对象内存。当然这里也可以反过来，标记需要回收的对象，再将标记的对象进行回收，这取决于具体的垃圾回收器采用哪种方式实现。</p>
<p>对于标记-清除算法，它有两个比较明显的缺陷，一个是当遇到大量的对象需要被回收时，标记和清除的过程就会随着加长，效率比较低。还一个就是会产生大量的碎片空间，当遇到稍大对象可能就无法满足内存分配，这时将会触发一次垃圾回收动作，其实呢也许总的剩余内存是够的，但却没有足够的连续空间来分配。根据这种收集算法的特点，同时结合上面对堆中分代收集的描述，老年代比较适合采用标记-清除算法，老年代中一般都是存活比较长的对象，可回收的对象相对较少。</p>
<p><img src="/images/Mark-Sweep.png" alt="Mark-Sweep"></p>
<h5 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h5><p>由于采用标记-清除算法在大量对象需要进行回收时效率比较低，因此就有了标记-复制算法，将可用内存区域分成 A B 两块区域，每次使用 A 区域来分配内存，当 A 区域内存用完了之后，将 A 区域中还存活着的对象复制到 B 区域，然后将 A 区域中使用过的内存一次性全部回收。</p>
<p>这种方式一个是需要避免在标记之后有大量对象还存活的情况，不然就需要执行大量对象的复制工作了。还有一个就是需要预留一半的空间出来，这就相当于浪费了一半的空间，这部分空间没办法得到利用。在上面分代收集思想中对于新生代刚好符合每次只有少量对象存活的特性，因此上面在分代收集中所提到的新生代中 Survivor from 和 Survivor to 区就是采用了这种算法，同时为了避免内存浪费，让 Eden 区和两个 Survivor 区的比例为 8:1:1，这样在新生代中就只有 10% 的内存是空着的。</p>
<p><img src="/images/Mark-Copying.png" alt="Mark-Copying"></p>
<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>同样的在标记-清除算法的基础上，由于标记-清除算法会产生大量的碎片空间，因此就有了标记整理的算法，在标记之后先对存活的对象进行移动操作，也就是将这部分对象进行整理放到内存的一边，然后再将剩下的空间进行清理，这样就防止了产生大量的碎片化空间。这种方式也有一个比较严重的问题，那就是在标记之后如果存活的对象很多，那么要移动这部分对象的过程就会变得很长，同时由于对象需要进行移动，这时必须要暂停用户线程，这就让我们的程序看起来会暂停一下，也就是著名的 “Stop The World” 现象。</p>
<p><img src="/images/Mark-Compact.png" alt="Mark-Compact"></p>
<p>好了，上面大概介绍了 JVM 中是如何判定对象是否还存活，以及非常经典的分代收集思想，同时列举了几种常见的垃圾收集算法。到这里你可能会觉得这些知识点看起来好像对我们的编码没什么影响呀，但是呢这些东西就好比是我们的内功，那些武林高手到最后比拼的不都是谁的内功更深一筹么。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>JVM 的运行时数据区域分布</title>
    <url>/JVM-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p>说到 Java 虚拟机(Java Virtual Machine, 简称 JVM)，可能对于我们大部分 Java 程序员来说都感觉望而生畏，都觉得它很高大上，毕竟我们都知道因为它我们的 Java 程序才能做到一次编写，到处运行，而且因为它我们才能够做到只专注于业务代码实现，而不用去关心内存分配和回收的事情，仅从这两点就能看出 Java 虚拟机为我们做了多少事情，但也正因为它为我们做的事情太多了，以至于我们只需要一心一意的去实现我们的需求，在大多数情况下我们都不用去关心底层如何做到的，但也因为它做了太多，导致我们在编码过程中遇到一些问题时根本不知道发生了什么，更别提如何解决了，因此我们还是有必要去了解一下 Java 虚拟机到底是怎么为我们服务的，这样在遇到问题时才不至于手足无措。</p>
<a id="more"></a>

<p>首先，让我们对 JVM 有个初步的印象，知道它是什么，然后能做什么。JVM 在维基百科上的定义如下：</p>
<p><strong>Java 虚拟机(Java Virtual Machine，JVM)，一种能够运行 Java bytecode(字节码) 的虚拟机，以堆栈结构机器来进行实现。最早由 Sun 微系统所研发并实现第一个实现版本，是 Java 平台的一部分，能够运行以 Java 语言写作的软件程序。</strong></p>
<p><strong>Java 虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 屏蔽了与具体操作系统平台相关的信息，使得 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</strong></p>
<p><strong>作为一种编程语言的虚拟机，实际上不只是专用于 Java 语言，只要生成的编译文件符合 JVM 对加载编译文件格式要求，任何语言都可以由 JVM 编译运行。</strong></p>
<p>以上是维基百科对 JVM 的有关定义，通俗一点来说就是我们编写的 Java 程序经过编译之后得到的字节码就可以放到 JVM 上去运行了，至于是怎么运行的就和 JVM 内部的实现有关了，然后由于最终在 JVM 上运行的是编译之后的字节码，所以它不仅仅是只能运行 Java 程序，只要编译之后的文件符合 JVM 的要求就能够运行。</p>
<p>下面我们就从 JVM 的运行时数据区域结构说起，其实这也是我们经常看到的一道面试题: Java 虚拟机的运行时数据区域分布是怎样的？如果你准备过面试，相信你肯定看到过这道面试题，我记得我刚毕业出来准备面试的时候就经常看到这道面试题，而当时说实话可能对 Java 虚拟机都没什么概念，所以可想而知在准备面试的时候只能是死记硬背答案了，以至于过一段时间就忘了，而现在对 Java 虚拟机不敢说非常熟悉，但起码也算是知道个一二了，下面就一起来看看回答这道题需要准备哪些知识点，看完这些知识点之后相信你也知道该怎么回答这道题了。</p>
<p>JVM 定义了在程序执行期间各种运行时数据区域，主要有<strong>堆，程序计数器，栈，方法区，运行时常量池</strong>，其中一些数据区域随着 JVM 的启动而创建，在 JVM 退出时销毁，有一些则是线程私有的，在线程创建时初始化，线程退出时销毁，每个区域承担着不同的使命，下面来简单看下每个区域主要负责的内容。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>所有的类实例以及数组在这里进行内存分配，在 JVM 启动时创建，并且所有 JVM 线程共享，即该区域的类实例和数组所有线程都能够访问，该区域大小可以是固定的，也可以根据需要弹性扩展，JVM 提供了启动参数供程序员指定堆的初始化大小，如果是弹性的需指定堆的最大值。JVM 指定堆内存的初始化大小参数为 -Xms，配置堆内存的最大值参数为 -Xmx。如果需要堆内存大小固定，只需要将 -Xms 和 -Xmx 的值配置相同即可，比如说 -Xms20m -Xmx20m。</p>
<p>由于我们的程序可能无时无刻不在创建对象和数组，而有的对象或数组在创建好用完一次可能再也不需要了，这时就需要垃圾收集器来进行内存回收，因此堆区相对来说是垃圾收集器重点关注的区域，当 JVM 在该区域进行内存分配时遇到所需要的堆内存大于该区域可用的内存时，JVM 将会抛出 OutOfMemoryError 错误。</p>
<p>至于堆区中的对象实例是如何分配以及垃圾收集器又是如何回收的，可能需要单独用好几篇文章来说明，这个先知道有这回事就行，待下回分解，今天先重点关注 JVM 的运行时内存区域分布。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>JVM 支持一次多个线程的执行，每个线程都拥有自己的程序计数器，在任意时刻，每个线程当前正在执行的方法称为该线程的当前方法，如果当前方法不是本地方法(Native Method),程序计数器中的值是当前线程正在执行的当前方法中指令的地址，如果是本地方法，它的值是 undefined。在多线程环境中，每个线程的调度执行都是通过 CPU 来分配时间片的，当一个线程分配的时间片执行完之后需要重新回到就绪状态，等待下一次调度再恢复执行，而线程的恢复执行能回到上次执行的位置继续执行靠的就是程序计数器中记录的值。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li><p>虚拟机栈</p>
<p>同样地每个线程也都拥有一个自己的虚拟机栈，随着线程的创建而创建，它里面主要存储着方法执行过程中产生的方法栈帧，栈帧中包含有局部变量表，操作数栈，动态连接，方法的出口等信息，每一个方法从被调用到执行返回的过程都对应着一个栈帧在虚拟机栈中压栈到弹栈的过程。</p>
<p>在 JVM 规范中该区域大小可以是固定的，也可以根据需要弹性扩展，JVM 提供了启动参数供程序员指定虚拟机栈的初始化大小，如果是弹性的需指定最大值。而且该区域可能有两种异常产生，一个是如果线程中请求的栈深度超过了 JVM 所允许的最大深度，将抛出 StackOVerflowError 错误，另一个是如果 JVM 的栈内存支持动态扩展的话，当栈在尝试扩展的过程中已经没有足够的内存来支持扩展，或者在创建线程的时候就已经没有足够的内存来为新创建的线程初始化栈，JVM 将抛出 OutOfMemoryError 错误。</p>
<p>而对于具体的 HotSpot 虚拟机来说，它是不支持扩展的，在创建线程初始化栈内存时就已经确定大小了，可通过 -Xss 参数指定栈容量的大小，比如说 -Xss20m 就是指定栈容量大小为 20MB。因此在 HotSpot 虚拟机中是不存在线程运行过程中由于栈的扩展而产生 OutOfMemoryError 错误，只可能在创建线程初始化栈内存的时候就已经无法初始化才会产生 OutOfMemoryError 错误。</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈(Native Method Stacks)和虚拟机栈的作用其实是一样的，只不过为了支持 Java 中的本地方法所以才有了本地方法栈的存在，相关特征可参考虚拟机栈中的内容。</p>
</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>和堆区一样同样是在 JVM 启动时就创建，所有 JVM 线程共享，但该区域主要用于存储加载完成的每个类的运行时常量池，类型信息，常量，静态变量，字段和方法以及即时编译器编译后的代码缓存等这些类的结构。方法区逻辑上来说是堆区的一部分，但有时为了将它与堆作区分从而叫它非堆。</p>
<p>JVM 规范中对方法区的规定其实是很宽泛的，对于方法区的实现方式也就由具体的虚拟机自己去定义了，在 JDK 8 以前，其中 HotSpot 虚拟机通过永久代(垃圾收集器的分代设计中的永久代)的方式来实现方法区，这样就可以直接采取垃圾收集器管理堆区的方式去管理方法区，省去了为方法区设计内存管理的工作。但是因为永久代的大小有个上限，通过 -XX:MaxPermSize=size 设置，即使不设置也会有个默认值，这就导致了 JVM 更容易遇到内存溢出的问题，因此在后来 JDK 发展的过程中开始逐步放弃永久代的实现方式，JDK 8 之后直接改成通过元空间(Metaspace)的方式实现，可通过 -XX:MaxMetaspaceSize=size 设置元空间最大值，默认是不做限制的，但由于元空间位于本地内存，也就是仅仅受限于本地内存的大小。</p>
<p>对于该区域在 JVM 规范中明确说明简单的实现可以选择不进行垃圾收集或压缩，那是因为该区域存储的是主要是类的结构数据，垃圾收集器回收的也就是类的信息，而对于类的回收，需要进行类卸载，类卸载的条件又异常严格，也就导致垃圾收集器在该区域的回收效果实在是差强人意，但不管如何还是有必要对该区域进行回收，以防该区域产生内存泄漏问题。</p>
<p>尽管 JVM 规范中描述如果方法区中的内存不能够继续满足内存分配请求的话将会抛出 OutOfMemoryError 错误，但是由于在 JDK 8 之后已经改为通过元空间(Metaspace)的方式实现该区域，因此基本上不会在该区域产生 OutOfMemoryError 错误，除非本地内存严重不够，已经无法为运行时产生的类信息分配内存了。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>在方法区中其实也提到了运行时常量池，它是方法区中的一部分，主要存储着编译期间生成的各种字面量和符号引用，这些内容在类加载后存放至该区域中。同样的在 JVM 规范描述中，创建类或接口时，如果运行时常量池构造所需的内存已经超过 Java 虚拟机方法区中可用的内存，则 Java 虚拟机将抛出 OutOfMemoryError 错误，但正如上面所说的原因已经很难在该区域产生 OutOfMemoryError 错误了。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是 JVM 运行时数据区域的一部分，在 JVM 的规范中也没有定义该内存区域，只不过由于这部分内存也是经常用到的，也可能导致 OutOfMemoryError 错误，可通过 -XX:MaxDirectMemorySize=size 参数来设置可使用的最大直接内存。其实这部分内存我也不是非常懂，可能很少接触到的原因，只是在《深入理解 Java 虚拟机》一书中看到说在 JDK 1.4 中加入的 NIO 中就利用到了这部分内存，避免了由于使用 Native 方法在 Java 堆和 Native 堆中来回复制数据的开销，显著提高了性能。</p>
<p>这部分内存虽然说不会像其他区域一样有大小限制，但最终还是会受到本机的总内存大小的限制，因此我们可能只记得设置堆的大小参数，却忘了还有这部分内存的消耗，导致各个区域的内存加起来超过了本机的总内存大小，从而产生 OutOfMemoryError 错误。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面主要介绍了 Java 虚拟机的运行时数据区域分布，以及每个区域所负责的内容，这里我强烈推荐周志明著的《深入理解Java虚拟机》这本书，书中对上面的每个知识点都有非常全面的解析，相信这本书看完之后你对 JVM 会有更加全面的认识。这里先通过上面的内容让我们对 Java 虚拟机能够有一个初步的了解，接下来我将对每个区域进行扩展，并且进行深入了解，在这个深入了解的过程中再进一步的熟悉 Java 虚拟机，这可以帮助我们在遇到诡异的问题的时候知道是怎么产生的，然后该怎么去解决，同时也会对我们的日常编码有很好地指导作用，知其然而且知其所以然。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 特性--Lambda 表达式、接口默认方法以及方法引用</title>
    <url>/Java-8-%E7%89%B9%E6%80%A7-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本，Java 8 增加了许多的新特性，在此先记录一下 Lambda 表达式，接口默认方法和方法引用这三个特性。</p>
<a id="more"></a>

<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 表达式，也可称为闭包，允许把函数作为一个方法的参数（函数作为参数传递进方法中），使用 Lambda 表达式可以使代码变的更加简洁紧凑。<br>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression  或  (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<p>主要特征：</p>
<ul>
<li>可选类型声明，不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号，一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号，如果主体只包含一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字，如果主体只有一个表达式返回值则编译器会自动返回值，大括号的话需要指明表达式返回了一个数值。</li>
</ul>
<p>下面通过一些小例子来展示，首先先定义两个函数式接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface MathOperation &#123;</span><br><span class="line">    int operate(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Greeting &#123;</span><br><span class="line">    void sayMessage(String greeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个测试类，通过 main 方法来进行测试，代码中有详细注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Java8 java8 &#x3D; new Java8();</span><br><span class="line">    &#x2F;&#x2F;参数类型可声明可不声明</span><br><span class="line">    MathOperation addition &#x3D; (int a, int b) -&gt; a + b;</span><br><span class="line">    MathOperation subtraction &#x3D; (a, b) -&gt; a - b;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;可选的参数圆括号</span><br><span class="line">    Greeting greeting &#x3D; message -&gt; System.out.println(&quot;hello &quot; + message);</span><br><span class="line">    Greeting greeting1 &#x3D; (message) -&gt; System.out.println(&quot;hello &quot; + message);</span><br><span class="line">    greeting.sayMessage(&quot;Tom&quot;);</span><br><span class="line">    greeting1.sayMessage(&quot;Jim&quot;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;可选的大括号以及可选的返回关键字，当有大括号时返回值需指定 return 语句</span><br><span class="line">    MathOperation multiplication &#x3D; (int a, int b) -&gt; &#123;</span><br><span class="line">        return a * b;</span><br><span class="line">    &#125;;</span><br><span class="line">    MathOperation division &#x3D; (a, b) -&gt; a &#x2F; b;</span><br><span class="line">    &#x2F;&#x2F;测试执行输出，将上面定义的函数传进 operate 方法中</span><br><span class="line">    System.out.println(java8.operate(1, 2, addition));</span><br><span class="line">    &#x2F;&#x2F;上面的另一种写法</span><br><span class="line">    System.out.println(addition.operate(1, 2));</span><br><span class="line">    </span><br><span class="line">    System.out.println(java8.operate(1, 2, subtraction));</span><br><span class="line">    System.out.println(java8.operate(1, 2, multiplication));</span><br><span class="line">    System.out.println(java8.operate(1, 2, division));</span><br><span class="line">    System.out.println(java8.operate(1,2, (a, b) -&gt; a + b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">    return mathOperation.operate(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h2><p>默认方法就是接口可以有实现方法，而且不需要实现类去实现这个默认方法，定义时我们只需在方法名前面加个 default 关键字即可实现默认方法。</p>
<p>至于为什么会产生这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是当需要修改接口时候，需要修改它的全部实现类，目前 java 8之前的集合框架没有 foreach 方法，通常能想到的解决办法是在 JDK 里给相关的接口添加新的方法定义及给相应实现类添加实现，然而对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现，所以才引进的默认方法。目的就是为了解决接口的修改与现有的实现不兼容的问题。</p>
<p>下面是接口默认方法和接口静态默认方法的基本实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Action1 &#123;</span><br><span class="line">    &#x2F;&#x2F;默认方法</span><br><span class="line">    default void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃东西1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;静态默认方法</span><br><span class="line">    static void fun() &#123;</span><br><span class="line">        System.out.println(&quot;玩&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Action2 &#123;</span><br><span class="line">    default void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃东西2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里接口 Action1 和 Action2 都有 eat 这个相同的默认方法，当一个实现类同时实现了这个两个接口时就需要实现类显式的覆盖两个接口中相同的 eat 方法，至于实现类中如何重写 eat 方法取决于实现类，实现类既可以完完全全由自己重写，也可以使用 super 来调用两个接口中的 eat 方法。上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Cat implements Action1, Action2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action1.super.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*@Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action2.super.eat();</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*@Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action1.super.eat();</span><br><span class="line">        Action2.super.eat();</span><br><span class="line">        Action1.fun();</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用通过方法的名字来指向一个方法，方法引用可以使语言的构造更紧凑简洁，减少冗余代码，方法引用使用一对冒号 :: 表示。当要传递给Lambda体内的操作已经有实现的方法了，就可以使用方法引用了。</p>
<p>先定义一个函数式接口和一个测试类以及类中的一些方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Say&lt;T&gt; &#123;</span><br><span class="line">    void accept(T t1, T t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private String name &#x3D; &quot;default&quot;;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Student create(Supplier&lt;Student&gt; studentSupplier) &#123;</span><br><span class="line">        return studentSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String study() &#123;</span><br><span class="line">        System.out.println(&quot;study&quot;);</span><br><span class="line">        return &quot;knowledge&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String fun() &#123;</span><br><span class="line">        System.out.println( &quot;fun&quot;);</span><br><span class="line">        return &quot;fun&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ask() &#123;</span><br><span class="line">        System.out.println(this.getName() + &quot; ask&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void say(Student student) &#123;</span><br><span class="line">        System.out.println(this.getName() + &quot; say to&quot; + student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;set get 方法已省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 main 方法测试方法引用的具体使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F;构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</span><br><span class="line">    Student student &#x3D; Student.create(Student :: new );</span><br><span class="line">    Student student1 &#x3D; Student.create(() -&gt; new Student(&quot;小红&quot;));</span><br><span class="line">    Student student2 &#x3D; Student.create(() -&gt; new Student(&quot;小绿&quot;));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;静态方法引用：它的语法是Class::static_method</span><br><span class="line">    Supplier&lt;String&gt; supplier1 &#x3D; Student :: study;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;特定类的任意对象的方法引用：它的语法是Class::method</span><br><span class="line">    Consumer&lt;Student&gt; consumer &#x3D; Student :: ask;</span><br><span class="line">    &#x2F;&#x2F;下面 student 参数是 ask 方法的调用者</span><br><span class="line">    consumer.accept(student);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;特定类的任意对象的方法引用：它的语法是Class::method</span><br><span class="line">    Say&lt;Student&gt; say &#x3D; Student :: say;</span><br><span class="line">    &#x2F;&#x2F;下面 student1 参数是 say 方法的调用者，student2 参数是 say 方法的参数</span><br><span class="line">    say.accept(student1, student2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;特定对象的方法引用：它的语法是instance::method</span><br><span class="line">    supplier1 &#x3D; student :: fun;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面静态方法引用和特定类的任意对象的方法引用的区别，前者是一个静态方法，可通过类访问，后者则是参数列表的第一个参数是实例方法的调用者，第二个参数(或无参)是实例方法的参数时才会采取这种语法。</p>
<p>在使用方法引用时一定注意：</p>
<ol>
<li>方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表完全一致。</li>
<li>方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值完全一致</li>
</ol>
]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 特性--Optional 类、时间 API 以及 Base64 编解码</title>
    <url>/Java-8-%E7%89%B9%E6%80%A7-Optional-%E7%B1%BB%E3%80%81%E6%97%B6%E9%97%B4-API-%E4%BB%A5%E5%8F%8A-Base64-%E7%BC%96%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><p>Optional 类是一个可以为 null 的容器对象，可以保存类型 T 的值，或者仅仅保存 null，它提供很多有用的方法，让我们不用再显式的进行空值检测，Optional 类的引入很好的避免了发生空指针异常，下面我们看一个简单的例子：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Integer value1 &#x3D; null;</span><br><span class="line">Integer value2 &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">Optional&lt;Integer&gt; optional1 &#x3D; Optional.ofNullable(value1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">Optional&lt;Integer&gt; optional2 &#x3D; Optional.of(value2);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;第一个参数值是否存在: &quot; + optional1.isPresent());</span><br><span class="line">System.out.println(&quot;第二个参数值是否存在: &quot; + optional2.isPresent());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">Integer result1 &#x3D; optional1.orElse(0);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Optional.get - 获取值，值需要存在</span><br><span class="line">Integer result2 &#x3D; optional2.orElse(0);</span><br><span class="line">System.out.println(result2);</span><br></pre></td></tr></table></figure>

<h2 id="Java-8-日期时间-API"><a href="#Java-8-日期时间-API" class="headerlink" title="Java 8 日期时间 API"></a>Java 8 日期时间 API</h2><p>在 Java 8 以前，我们都知道 Java 中的时间处理很繁琐，有时候还会去纠结我到底是用 java.util 包下的日期还是 java.sql 包下的日期呢。因此往往在遇到时间处理问题时都会借助于框架来实现，比如 Joda-Time。但在 Java 8 中也增加了同样的类似框架功能的时间处理 API，下面列出一些简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Clock 类使用时区来返回当前的毫秒数和日期。Clock 可以替代System.currentTimeMillis() 和 TimeZone.getDefault()。</span><br><span class="line"> </span><br><span class="line">Clock clock &#x3D; Clock.systemUTC();</span><br><span class="line">System.out.println(clock.millis());</span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取当前日期</span><br><span class="line">LocalDate currentDate &#x3D; LocalDate.now();</span><br><span class="line">System.out.println(&quot;当前日期: &quot; + currentDate);</span><br><span class="line">&#x2F;&#x2F; 获取当前时间</span><br><span class="line">LocalTime currentTime &#x3D; LocalTime.now();</span><br><span class="line">System.out.println(&quot;当前时间: &quot; + currentTime);</span><br><span class="line">&#x2F;&#x2F; 获取当前日期时间</span><br><span class="line">LocalDateTime currentDateTime &#x3D; LocalDateTime.now();</span><br><span class="line">System.out.println(&quot;当前日期时间: &quot; + currentDateTime);</span><br><span class="line">&#x2F;&#x2F; 根据当前日期时间获取当前日期</span><br><span class="line">LocalDate currentDate1 &#x3D; currentDateTime.toLocalDate();</span><br><span class="line">System.out.println(&quot;currentDate1: &quot; + currentDate1);</span><br><span class="line">&#x2F;&#x2F; 根据当前日期时间获取当前时间</span><br><span class="line">LocalTime currentTime1 &#x3D; currentDateTime.toLocalTime();</span><br><span class="line">System.out.println(&quot;currentTime1: &quot; + currentTime1);</span><br><span class="line"></span><br><span class="line">Month month &#x3D; currentDateTime.getMonth();</span><br><span class="line">int day &#x3D; currentDateTime.getDayOfMonth();</span><br><span class="line">int seconds &#x3D; currentDateTime.getSecond();</span><br><span class="line">System.out.println(&quot;月: &quot; + month +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定日期</span><br><span class="line">LocalDateTime date2 &#x3D; currentDateTime.withDayOfMonth(10).withYear(2012);</span><br><span class="line">System.out.println(&quot;date2: &quot; + date2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 12 december 2014</span><br><span class="line">LocalDate date3 &#x3D; LocalDate.of(2014, Month.DECEMBER, 12);</span><br><span class="line">System.out.println(&quot;date3: &quot; + date3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 22 小时 15 分钟</span><br><span class="line">LocalTime date4 &#x3D; LocalTime.of(22, 15);</span><br><span class="line">System.out.println(&quot;date4: &quot; + date4);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解析字符串</span><br><span class="line">LocalTime date5 &#x3D; LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">System.out.println(&quot;date5: &quot; + date5);</span><br><span class="line">&#x2F;&#x2F; 获取当前日期时间的另一个时区的日期时间</span><br><span class="line"></span><br><span class="line">System.out.println(currentDateTime.atZone(ZoneId.of(&quot;America&#x2F;New_York&quot;)));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime from &#x3D; LocalDateTime.of( 2017, Month.MAY, 16, 0, 0, 0 );</span><br><span class="line">LocalDateTime to &#x3D; LocalDateTime.of( 2018, Month.MAY, 16, 23, 59, 59 );</span><br><span class="line">Duration duration &#x3D; Duration.between( from, to );</span><br><span class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</span><br><span class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours());</span><br></pre></td></tr></table></figure>
<p>上面只是列举了一些简单的东西，其实还有一些，比如时间的加减运算，这些在用到时可以根据提示来进行我们想要的操作。</p>
<h2 id="Java8-Base64"><a href="#Java8-Base64" class="headerlink" title="Java8 Base64"></a>Java8 Base64</h2><p>Java 8 内置了 Base64 编码的编码器和解码器，并且 Base64 工具类提供了一套静态方法获取下面三种 BASE64 编解码器：</p>
<ul>
<li>基本：输出被映射到一组字符 A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持 A-Za-z0-9+/。</li>
<li>URL：输出映射到一组字符A-Za-z0-9+_，输出是 URL 和文件。</li>
<li>MIME：输出映射到 MIME 友好格式，输出每行不超过 76 字符，并且使用 ‘\r’ 并跟随 ‘\n’ 作为分割，编码输出最后没有行分割。</li>
</ul>
<p>下面也是一个简单的例子展示了如何获取这三种编解码器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 基本编码</span><br><span class="line">String base64encodedString &#x3D; Base64.getEncoder().encodeToString(&quot;java 8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line">&#x2F;&#x2F; 基本解码</span><br><span class="line">byte[] base64decodedBytes &#x3D; Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; URL 编码</span><br><span class="line">base64encodedString &#x3D; Base64.getUrlEncoder().encodeToString(&quot;url?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line">&#x2F;&#x2F; URL 解码</span><br><span class="line">byte[] base64decodedBytesUrl &#x3D; Base64.getUrlDecoder().decode(base64encodedString);</span><br><span class="line">System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytesUrl, &quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line">byte[] mimeBytes &#x3D; stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">&#x2F;&#x2F; MINE 编码</span><br><span class="line">String mimeEncodedString &#x3D; Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
  </entry>
  <entry>
    <title>Java 8 特性--Stream 流</title>
    <url>/Java-8-%E7%89%B9%E6%80%A7-Stream-%E6%B5%81/</url>
    <content><![CDATA[<p>Java 8 API 添加了一个新的抽象称为流 Stream，可以让你以一种声明的方式处理数据，Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API 可以极大提高 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation) 得到前面处理的结果。</p>
<a id="more"></a>

<h2 id="Stream-的定义"><a href="#Stream-的定义" class="headerlink" title="Stream 的定义"></a>Stream 的定义</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作，元素是特定类型的对象，形成一个队列。 Java 中的 Stream 并不会存储元素，而是按需计算。</p>
<ul>
<li>数据源：流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作：类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的 Collection 操作不同， Stream 操作还有两个基础的特征：</p>
<ul>
<li>Pipelining: 中间操作都会返回流对象本身。这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行 (laziness) 和短路 (short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过 Iterator 或者 For-Each 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式 (Visitor) 实现。</li>
</ul>
<p>在 Java 8 中，集合接口有两个方法生成流：</p>
<ul>
<li>stream() − 为集合创建串行流。</li>
<li>parallelStream() − 为集合创建并行流。</li>
</ul>
<h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 统计空字符串数量</span><br><span class="line">long count &#x3D; strings.stream().filter(String::isEmpty).count();</span><br><span class="line">System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">&#x2F;&#x2F; 流并行处理</span><br><span class="line">count &#x3D; strings.parallelStream().filter(String::isEmpty).count();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将字符串不为空的筛选出来并且以逗号分隔合并起来</span><br><span class="line">String mergedString &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure>

<h2 id="map-映射"><a href="#map-映射" class="headerlink" title="map 映射"></a>map 映射</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">&#x2F;&#x2F; 求各元素的平方</span><br><span class="line">List&lt;Integer&gt; squaresList &#x3D; numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;Squares List: &quot; + squaresList);</span><br></pre></td></tr></table></figure>

<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19);</span><br><span class="line">IntSummaryStatistics stats &#x3D; integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据景区等级分组</span><br><span class="line">List&lt;Scenic&gt; scenicList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">scenicList.add(new Scenic(1L, &quot;西湖&quot;, 5));</span><br><span class="line">scenicList.add(new Scenic(2L, &quot;千岛湖&quot;, 5));</span><br><span class="line">scenicList.add(new Scenic(3L, &quot;乌镇&quot;, 4));</span><br><span class="line">scenicList.add(new Scenic(4L, &quot;雷峰塔&quot;, 3));</span><br><span class="line">scenicList.add(new Scenic(4L, &quot;灵隐寺&quot;, 4));</span><br><span class="line">Map&lt;Integer, List&lt;Scenic&gt;&gt; mapGroup &#x3D; scenicList.stream().collect(Collectors.groupingBy(Scenic::getScenicLevel));</span><br><span class="line">System.out.println(mapGroup);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="转成-Map"><a href="#转成-Map" class="headerlink" title="转成 Map"></a>转成 Map</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* toMap 如果集合对象有重复的key，会报错Duplicate key ....</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F;Map&lt;Long, Scenic&gt; scenicMap &#x3D; scenicList.stream().collect(Collectors.toMap(Scenic::getId, a -&gt; a));</span><br><span class="line">&#x2F;&#x2F;System.out.println(scenicMap);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以用 (k1,k2)-&gt;k1 来设置，如果有重复的 key,则保留 key1,舍弃 key2</span><br><span class="line">Map&lt;Long, Scenic&gt; scenicMap &#x3D; scenicList.stream().collect(Collectors.toMap(Scenic::getId, a -&gt; a, (k1, k2) -&gt; k1));</span><br><span class="line">System.out.println(scenicMap);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="reduce-sum-求和"><a href="#reduce-sum-求和" class="headerlink" title="reduce sum 求和"></a>reduce sum 求和</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers &#x3D; Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">&#x2F;&#x2F; 没有起始值时返回为Optional类型</span><br><span class="line">Optional&lt;Integer&gt; sumOptional &#x3D; integers.stream().reduce(Integer::sum);</span><br><span class="line">System.out.println(sumOptional.get());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以给一个起始种子值</span><br><span class="line">Integer sumReduce &#x3D; integers.stream().reduce(0, Integer::sum);</span><br><span class="line">System.out.println(sumReduce);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;直接用sum方法</span><br><span class="line">Integer sum &#x3D; integers.stream().mapToInt(i -&gt; i).sum();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<h2 id="根据某个属性求平均数"><a href="#根据某个属性求平均数" class="headerlink" title="根据某个属性求平均数"></a>根据某个属性求平均数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 等级平均数</span><br><span class="line">OptionalDouble average &#x3D; scenicList.stream().mapToInt(Scenic :: getScenicLevel).average();</span><br><span class="line">System.out.println(average.getAsDouble());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java 8</category>
      </categories>
  </entry>
  <entry>
    <title>Java 中对象和数组的创建</title>
    <url>/Java-%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<p>在上篇文章中，主要介绍了 JVM 的运行时数据区域分布情况，包括堆，程序计数器，栈，方法区，运行时常量池，直接内存等，接下来我们就先来看下和堆区相关的知识点，之前说过堆区是提供所有的类实例以及数组进行内存分配的地方，那实例和数组又是怎么创建的呢？我们一起来看下吧。</p>
<a id="more"></a>

<p>在 Java 程序员圈子中我们可能都听说过类似这样的段子：”程序员找不到对象没关系，我们可以直接 new 一个“，这句话虽说是程序员的自我调侃，但在 Java 语言层面我们确实是通过 new 这个关键字来创建对象的，而且在程序的运行过程中无时无刻都在创建。</p>
<p>在 Java 语言层面我们通过 new 关键字很快就创建出一个对象，比如说像下面这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>Java 语言层面看起来很简单，但这一行代码在 Java 虚拟机中却伴随着一系列的过程，首先 JVM 既然要创建 Object 类的对象，那它肯定需要先有 Object 类才能创建，于是就需要先将 Object 这个类加载到 JVM 中，也就是我们经常听到的类加载。类加载分为以下几个过程：<strong>加载，连接，初始化</strong>。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>首先说明这里的加载并不是指上面提到的类加载过程，这里只是类加载过程中的一个阶段，拿上面的代码来说，也就是将 Object 这个类的字节流加载到 JVM 中，至于字节流从哪里来其实没有明确的规定，所以可以有很多种方式，可以从 jar 包读取，反射动态生成(动态生成代理类)，网络读取，以及 Class 文件，其中我们最为常见的可能就是从 Class 文件中读取。在读取时则需要借助类加载器来完成这个过程，同时根据类加载器的功能特征可将类加载器分成三级，在 Java 9 之前从上到下分别是启动类加载器(bootstrap class loader) &gt; 扩展类加载器(extension class loader) &gt; 应用类加载器(application class loader)。</p>
<p>从名字也可以大概知道启动类加载器一般负责加载最基础以及最重要的类，包括其它下面的类加载器类，比如说扩展类加载器和应用类加载器都是 java.lang.ClassLoader 的子类，也就是这些类加载器类也是需要通过启动类加载器先进行加载才可使用。对于扩展类加载器主要负责 jre/lib/ext 目录下 jar 包中对应的类，而应用类加载器则负责加载应用程序路径下的类，通俗的来说就是我们指定的 classpath 路径下的类。从 Java 9 开始会有一些变化，比如说扩展类加载器改名成为平台类加载器(platform class loader)，如果对具体细节感兴趣的话可以去查阅相关资料，这里就不再深究了，知道个大概就行。</p>
<p>除了 Java 提供的这三类核心加载器之外，我们也可以自定义我们自己的类加载器实现一些特殊的需求，比如说我们将一个 Class 文件内容先进行了加密操作，那么在加载时就需要进行解密，这时就需要通过我们自定义的类加载器来实现了。</p>
<p>对于类加载器还有一个比较重要的点就是我们也经常听到的双亲委派模型，什么意思呢？前面我们提到类加载器是分等级的，在类加载器尝试加载一个类时，它首先需要先将这个加载请求转发给它的父类加载器，只有在父类加载器无法加载的情况下它才会去加载这个类，这也就是类加载器的双亲委派模型，其实主要是避免重复加载，如果每个类加载器都去加载自己所需要的类，那么就可能造成多个类加载器都去加载同一个类的情况。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接里面又可细分为 <strong>验证，准备，解析</strong> 三个阶段，在类加载之后，JVM 首先需要对加载的字节流是符合 JVM 的规范进行验证，比如说加载的字节流当前版本的虚拟机是否能够处理，超出当前版本则无法处理，当然还有一些更为精细的校验。</p>
<p>其次是准备阶段，在这一阶段中正式为类变量在方法区中分配内存以及设置初始值，也就是为 static 修饰的变量分配内存，对于基本数据类型，比如说 int 类型初始值为 0，boolean 类型为 false，对于引用类型则为 null，而真正的赋值是在第三阶段初始化阶段来完成。这里有个特殊情况，当类变量同时被 final 修饰的话，则会直接赋予代码中所给定的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">100</span>; <span class="comment">// 准备阶段 a 的初始值为 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">200</span>; <span class="comment">// 准备阶段 b 直接赋实际值 200</span></span><br></pre></td></tr></table></figure>

<p>某个类在加载到虚拟机前，它是不知道它所依赖的类，以及它里面的字段和方法对应的具体地址的，因此 Java 编译器在编译时会生成一些符号引用来指代它所引用的类，字段，方法，那么在解析阶段就是将这些符号引用解析成内存中具体的地址，如果解析过程中某个类还没有加载那么就会触发该类的加载，但不一定会触发连接和初始化。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在初始化阶段，将根据代码的实际赋值进行初始化，比如说上面的 a 正式赋值为 100，这一过程 JVM 是通过执行 &lt;clinit&gt; 方法实现的，在 &lt;clinit&gt; 方法中包括了所有的类变量的赋值操作以及所有的静态代码块， &lt;clinit&gt; 方法具有以下主要的特征:</p>
<ol>
<li>&lt;clinit&gt; 方法和实例构造器(&lt;init&gt;)不同，它不需要显式调用父类实例构造器，虚拟机会保证子类的 &lt;clinit&gt; 方法执行前，父类的  &lt;clinit&gt; 方法已经执行完成，由此可见，JVM 中第一个被执行的 &lt;clinit&gt; 方法的类是 Object 类。</li>
<li>对于接口，它和类有所不同，执行接口中的 &lt;clinit&gt; 方法不需要先执行父接口中的 &lt;clinit&gt; 方法，只有当父接口中的类变量需要赋值时才会执行，同时接口的实现类执行  &lt;clinit&gt; 方法也不会执行接口中的  &lt;clinit&gt; 方法。</li>
<li>从第一点中可以看出，父类的 &lt;clinit&gt; 方法先执行意味着父类的静态代码块在子类的静态代码块之前执行。</li>
<li>&lt;clinit&gt; 方法不是必需的，如果类中没有类变量的初始化赋值操作，也没有静态代码块，那么可以不用生产 &lt;clinit&gt; 方法。</li>
<li>虚拟机会通过加锁的方式保证一个类的 &lt;clinit&gt; 方法在多线程环境中只会被执行一次，因此需要注意如果在 &lt;clinit&gt; 方法中有耗时操作，可能会造成阻塞。</li>
</ol>
<p>哪些情况下会触发类的初始化呢？下面则是比较常见的需要对类进行初始化的情况，对于个别复杂的暂时不提了。</p>
<ol>
<li>虚拟机启动时会先初始化用户指定的主类，比如 SpringBoot 里面的 Application 类</li>
<li>通过 new 创建对象的类需先初始化</li>
<li>通过类访问静态变量，对类中静态变量赋值，调用类的静态方法都会触发该类的初始化，这里需要注意，无论是静态变量的访问，赋值，以及静态方法的调用都是直接定义这些变量和方法的类才会初始化，比如说通过子类调用父类中的静态变量则只会触发父类初始化，而不会初始化子类</li>
<li>初始化一个类时如果它的父类还没初始化会先将父类初始化</li>
<li>对一个类进行反射调用也会触发该类的初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你研究过单例模式的实现的话应该看到过上面面这种延时加载并且线程安全的实现方式，这里其实就是利用了 JVM 的类加载机制，当通过 Singleton 访问 getSingleton 方法，然后调用 Holder 类的类变量 singleton，这时才会触发 Holder 类的初始化，然后新建 Singleton 的实例，前面提到过，初始化过程 JVM 是保证线程安全并且只会执行一次，所以这里也就做到了线程安全的单例。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>前面花了很大一部分介绍了对象在创建前的准备工作，也就是在创建 Object 的对象前，对 Object 类的一个加载的过程，那么在 Object 类加载完成之后，就可以开始创建 Object 的对象了。</p>
<p>首先为新创建的对象在堆中进行内存分配，至于分配多大的内存在类加载完成之后就已经确定了，内存分配完之后，会将分配的内存空间初始化零值，这也是为什么我们在代码中可以不用赋值就能直接使用的原因。紧接着设置对象的头信息，比如说在 HotSpot 虚拟机中，一个对象在内存中主要包含三部分数据: <strong>对象头，实例数据，对齐填充</strong>，其中对象头中的信息比较重要，可以分为两部分，一部分是存储对象自身的运行时数据：哈希码，GC 分代年龄，锁状态标志，线程持有的锁，偏向线程 ID 等，而另一部分则是对象的类型指针，指向它的类元数据的指针，也就是该对象是属于哪个类的实例，但这部分数据并非所有的 JVM 都会保留，因为可通过其他的方式获取到该对象的类型数据。</p>
<p>在设置完对象头信息之后，在虚拟机中一个对象的创建算是完成了，但是在 Java 语言层面才算刚刚开始，因为这时候对象的字段值都为零值，然后通过实例构造器 &lt;init&gt; 方法进行赋值操作，在 &lt;init&gt; 方法执行完成之后，对象的创建也就正式完成了。</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>对于数组类来说，它是由 JVM 直接创建的，而不会像非数组类创建对象时需要经历类加载器加载的过程，但是需要注意的是虽然数组类不会使用类加载器加载，但是数组类中的元素类型(非基本类型的情况下)还是需要经历类加载的过程的。还有一个值得注意的就是当我们定义一个数组而没有使用，这时只是将元素类型加载了，而不会触发元素类型类的初始化，就相当于只是开辟了一块空间出来，定义了用来保存对应元素类型的容器，而并没有开始真正使用到相应的元素类，只有在真正使用时才会初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objects = <span class="keyword">new</span> Object[<span class="number">5</span>]; <span class="comment">// 定义一个 Object 类型的数组</span></span><br></pre></td></tr></table></figure>

<h3 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h3><p>对象创建好之后，我们可以通过引用中所存储的地址来找到堆中对象的具体位置，而引用中的地址可能有两种情况，一种是直接指向堆中对象的地址，另一种则是指向句柄池中句柄的地址，句柄中才真正存有对象在堆中的地址。通过下面的这幅图你应该就能明白两者的区别:</p>
<p>第一种方式可以直接定位到对象的内存数据，第二种则需要进行多一次的地址定位才能找到对象的内存数据，相比下来块一些，但是第二种方式的优势在于垃圾收集时，对象地址发生了移动，这时只需要修改句柄池中句柄的指向即可，而不用修改引用本身。</p>
<p>上面就是创建一个对象的整个过程了，可能就像前面提到的，在 Java 层面，创建一个对象直接 new 就好了，看起来非常简单，但如果我们对底层做了哪些事情有个初步的了解，这对我们在排查错误，理解代码为什么是按这样的顺序执行都是有很大帮助的。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java 中枚举让代码更优雅</title>
    <url>/Java-%E4%B8%AD%E6%9E%9A%E4%B8%BE%E8%AE%A9%E4%BB%A3%E7%A0%81%E6%9B%B4%E4%BC%98%E9%9B%85/</url>
    <content><![CDATA[<p>对于枚举，不知道你对它的使用了解多少，说实话在刚开始使用它的时候，我对它的印象仅次于帮助我们在代码中定义一个对象的字段特定的几种状态，便于我们理解代码中该字段有哪些值，又分别代表哪些含义。</p>
<a id="more"></a>

<p>也就是说当一个对象的某个字段只有特定的几种含义的时候，与其直接通过 Integer 类型来定义该字段，然后采取  1，2，3，4 每个数字来代表其中一种含义的方式来标记该字段的含义，倒不如使用枚举来标记该字段所代表的含义，这样能够更好地理解，同时也将该字段的含义包裹在你所定义的枚举类中。</p>
<p>这样如果这个字段跟你的业务关联非常紧密的时候，就不会出现一个工程项目中到处都充满了这个字段和数字类型的比较的代码，而是只和你所定义的枚举进行比较就可以了。这样做的好处一个是提高了代码的可阅读性，同时也避免了今后如果关于这个字段的业务逻辑需要更新而满工程的去找使用到这个字段的地方，有时还可能会落下一两个地方没有找到导致新的业务出现问题。</p>
<p>举个例子，非常典型的订单表中订单状态字段，假设在某电商业务中有一张订单表，其中有一个字段 status 表示该订单的状态，我们姑且先为订单的状态定义三种状态好了，分别是待支付，已支付，已退款，然后在数据库中分别对应于 0，1，2 这三个数字存储，而在代码中我们先用 Integer 类型来定义该字段，然后加上注释写上 0 表示待支付，1 表示已支付，2 表示已退款。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// private OrderStatus status;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0: 待支付，1:已支付，2:已退款.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在业务中只有待支付(0)的订单才能发起付款操作，已支付(1)的订单才能发起发货和退款操作，已退款(2)的订单便不能再发起任何操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initiatePay</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(order.getStatus() != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 订单状态异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发起付款</span></span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这种代码加上了注释还稍微能明白代码的业务逻辑，不然的话就需要去猜数字 0 表示什么状态了。但其实最好的是我们通过看代码就能明白代码所表达出来的含义，这也是我们经常说到的代码中的命名最好是能够规范一些，尽量做到见名知意，这一点在业务代码中显得尤为重要。</p>
<p>下面我们再看通过枚举的方式定义订单状态字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrderStatus &#123;</span><br><span class="line"></span><br><span class="line">    TO_PAY(<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    PAID(<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    REFUNDED(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    OrderStatus(<span class="keyword">int</span> code)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的业务逻辑代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initiatePay</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(order.getStatus() != OrderStatus.TO_PAY)&#123;</span><br><span class="line">        <span class="comment">// 订单状态异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发起付款</span></span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者相比是不是觉得下面使用枚举来定义的方式更优雅一些而且从枚举的名字一下就能明白这段代码的含义。但是你以为枚举的作用就只是这吗，其实枚举能够帮我们进一步的书写出更优雅的代码，下面就一个一个来介绍下枚举还有哪些特性。</p>
<h3 id="枚举的比较"><a href="#枚举的比较" class="headerlink" title="枚举的比较"></a>枚举的比较</h3><p>关于枚举的比较，其实枚举类型可确保 JVM 中仅存在所定义的常量的一个实例，所以我们可以直接使用 == 来比较两个枚举是否相等，而不需要通过 equals 方法来比较，当然用 equals 比较也可以，但是使用 equals 方法稍不注意可能会引起 NPE，下面我们举一个简单的例子来说明。</p>
<p>在敏捷开发中，我们常用 Issue 对象来表示 Epic(史诗)，Story(故事)，Task(任务)，Bug(缺陷)，这几个类型在 Issue 对象中会用一个类型字段来表示，然后与之对应的会有一个状态字段来标记当前 Issue 所处的状态，这里我们暂且使用 Task 类型的 Issue，然后通过该 Issue  中的状态字段来举例说明。不是很熟悉敏捷开发流程的建议可以了解下，应该算是目前比较流行的开发流程，快速迭代，将一个需求通过讲故事的方式进行开发迭代，将故事拆成很多的任务分配到开发人员来完成。具体可能需要经历过这样的过程才能更好地理解，这里就先暂时把 Issue 当成一个任务好了，任务肯定有它的状态，这里只是简单的定义成三种状态，TODO，DOING，DONE，分别代表待完成，正在进行中，已完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Issue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IssueType type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StatusEnum status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Issue</span><span class="params">(StatusEnum status)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> StatusEnum &#123;</span><br><span class="line"></span><br><span class="line">        TODO(<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">        DOING(<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">        DONE(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">        StatusEnum(<span class="keyword">int</span> code)&#123;</span><br><span class="line">            <span class="keyword">this</span>.code = code;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中就定义了一个 Issue 类，为了简单只定义了三个字段，id(住建)，type(issue 类型)，status(issue 状态)，其中 type 和 status 都是枚举，接下来以 status 枚举字段来测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Issue issue = <span class="keyword">new</span> Issue();</span><br><span class="line">issue.setId(<span class="number">1L</span>);</span><br><span class="line"><span class="comment">// compare result false</span></span><br><span class="line">System.out.println(issue.getStatus() == Issue.StatusEnum.DONE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// throw NPE</span></span><br><span class="line"><span class="comment">/// System.out.println(issue.getStatus().equals(Issue.StatusEnum.DONE));</span></span><br><span class="line">issue.setStatus(Issue.StatusEnum.DONE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compare  result true</span></span><br><span class="line">System.out.println(issue.getStatus() == Issue.StatusEnum.DONE);</span><br></pre></td></tr></table></figure>
<p>上面测试代码中从测试结果可以看到就算 issue 对象的 status 字段为 null，使用 == 比较是否相等也不会产生异常，比较的结果为 false，而如果使用一个 null 去调用 equals 方法这时就会产生 NPE，然后我们给 status 字段赋值 DONE，再使用 == 比较，比较的结果为 true，这就是推荐使用 == 比较两个枚举值是否相等的其中一个原因，可以避免运行时产生 NPE。</p>
<p>虽然使用 == 比较就算为 null 也没关系，但是值得注意的是当在 switch 中还是要注意 NPE 问题的，比如下面的代码当 issue 中的 status 值为 null 时就可能产生 NPE:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (getStatus())&#123;</span><br><span class="line">        <span class="keyword">case</span> TODO:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> DOING:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> DONE:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以从另外一点看出 Java 不希望我们使用 equals 来比较，首先 enum 类型继承自 java.lang.Enum 类，如果我们是通过调用 equals 方法来比较的话，调用的 equals 方法也就是 java.lang.Enum 类的中 equals 方法，而该类中 equals 方法被 final 修饰，并且方法实现就是使用 == 来比较的，我们都知道被 final 修饰的方法不能被重写，意味着我们自己定义的枚举类的 equals 方法都是使用 == 比较的，从这里可以看出可能是因为枚举所定义的枚举常量实例在 JVM 中是唯一的，所以 Java 就不希望我们重写 equals 方法来比较，直接使用 == 比较即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.Enum.java 类中 equals 方法的内部实现就是 ==，比较的是引用的地址是否相等，同时 final 修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>==other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐使用 == 比较的另外一个原因是可以在编译时就帮你进行了合法性检查，当使用两个不同类型的枚举进行比较是在编译时就报错提示不能使用 == 比较两个不同的枚举类型，但是使用 equals 却是可以的，但使用 equals 比较两个不同枚举类型是没有意义的，因为比较的结果总是为 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compare result false</span></span><br><span class="line">System.out.println(issue.getStatus().equals(TestFlowEnum.TODO));</span><br><span class="line"><span class="comment">// compile error</span></span><br><span class="line"><span class="comment">/// System.out.println(issue.getStatus() == TestFlowEnum.TODO);</span></span><br></pre></td></tr></table></figure>

<h3 id="在枚举中定义方法"><a href="#在枚举中定义方法" class="headerlink" title="在枚举中定义方法"></a>在枚举中定义方法</h3><p>文章开始我们提到使用枚举来定义字段，将枚举中的含义包裹在枚举类中，这里我们可以通过在枚举中定义一些方法来使一些基本的业务判断代码也包裹在枚举类中。请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StatusEnum &#123;</span><br><span class="line"></span><br><span class="line">    TODO(<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    DOING(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInnerCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDoing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    DONE(<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInnerCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInnerCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// default return -1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDoing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// default return false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// default return false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    StatusEnum(<span class="keyword">int</span> code)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的枚举类中定义了三个方法，方法带有默认实现，同时在各个枚举常量实例中分别重写对应的方法，覆盖默认的实现。这样在外围代码中都可以不需要使用 == 来作为业务判断了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">issue.setStatus(Issue.StatusEnum.DOING);</span><br><span class="line"><span class="comment">// 定义方法前的业务判断</span></span><br><span class="line"><span class="keyword">if</span>(issue.getStatus == Issue.StatusEnum.DOING)&#123;</span><br><span class="line">    <span class="comment">// execute</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义方法后的业务判断</span></span><br><span class="line"><span class="keyword">if</span>(issue.isDoing())&#123;</span><br><span class="line">    <span class="comment">// execute</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(issue.isDone());</span><br></pre></td></tr></table></figure>
<p>这样一来代码看起来是不是更优雅一点了呢。</p>
<h3 id="EnumSet-和-EnumMap-的使用"><a href="#EnumSet-和-EnumMap-的使用" class="headerlink" title="EnumSet 和 EnumMap 的使用"></a>EnumSet 和 EnumMap 的使用</h3><p>关于枚举还有两个集合类也会用到，分别是 EnumSet 和 EnumMap，这两个集合类在什么时候会用到呢。继续拿上面的 Issue 类来说，这时如果我们需要筛选出当前还未完成的任务，我们可以在 Issue 类中加一个方法，方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> EnumSet&lt;StatusEnum&gt; undoneSet = EnumSet.of(StatusEnum.TODO, StatusEnum.DOING);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Issue&gt; <span class="title">getUndoneIssue</span><span class="params">(List&lt;Issue&gt; issues)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> issues.stream().filter(issue -&gt; undoneSet.contains(issue.getStatus())).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EnumSet</span></span><br><span class="line">Issue issue1 = <span class="keyword">new</span> Issue(Issue.StatusEnum.TODO);</span><br><span class="line">Issue issue2 = <span class="keyword">new</span> Issue(Issue.StatusEnum.DOING);</span><br><span class="line">Issue issue3 = <span class="keyword">new</span> Issue(Issue.StatusEnum.DOING);</span><br><span class="line">Issue issue4 = <span class="keyword">new</span> Issue(Issue.StatusEnum.DONE);</span><br><span class="line">List&lt;Issue&gt; issues = Arrays.asList(issue1, issue2, issue3, issue4);</span><br><span class="line">List&lt;Issue&gt; undoneIssues = Issue.getUndoneIssue(issues);</span><br><span class="line">System.out.println(undoneIssues.size());</span><br><span class="line">undoneIssues.forEach(item -&gt; System.out.println(item.toString()));</span><br></pre></td></tr></table></figure>
<p>从测试代码中可以看到通过引入 EnumSet，可以做到很便利的筛选符合条件的状态的 Issue。</p>
<p>而当我们需要对 Issue 进行按状态分类时，就可以利用到 EnumMap 集合，在 Issue 类中加上 groupByStatus 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EnumMap&lt;StatusEnum, List&lt;Issue&gt;&gt; groupByStatus(List&lt;Issue&gt; issues)&#123;</span><br><span class="line">    <span class="keyword">return</span> issues.stream().collect(Collectors.groupingBy(Issue::getStatus, () -&gt; <span class="keyword">new</span> EnumMap&lt;&gt;(StatusEnum.class), Collectors.toList()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// todo status issue size is 1, doing status issue size is 2, done status issue size is 1</span></span><br><span class="line">EnumMap&lt;Issue.StatusEnum, List&lt;Issue&gt;&gt; map = Issue.groupByStatus(issues);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;todo status issue size is %s, doing status issue size is %s, done status issue size is %s&quot;</span>, map.get(Issue.StatusEnum.TODO).size(), map.get(Issue.StatusEnum.DOING).size(), map.get(Issue.StatusEnum.DONE).size()));</span><br></pre></td></tr></table></figure>

<p>同样从测试代码中可以看到通过使用 EnumMap 集合我们可以很快的做到按状态分类。</p>
<p>上面是我们在日常使用枚举的过程中可以稍微进行改进的地方，自我感觉合理的使用好枚举会让我们的代码看起来更加优雅，同时也会减少出错的可能性。当然这些只是关于枚举的一些小技巧，但其实通过枚举我们还可以实现简单的设计模式，接下来就来看看通过枚举怎么实现单例模式和策略模式。</p>
<p>完整测试代码地址：<a href="https://github.com/rookiedev-z/sample/tree/master/java-basic-sample">Java basic sample</a></p>
<p>参考：<a href="https://www.baeldung.com/a-guide-to-java-enums">https://www.baeldung.com/a-guide-to-java-enums</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 中通过枚举实现单例和策略模式</title>
    <url>/Java-%E4%B8%AD%E9%80%9A%E8%BF%87%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在上篇文章中主要介绍了 Java 中对于枚举的合理使用能让我们的代码看起来更优雅，但其实枚举还有一个特异功能，可以实现设计模式中的单例模式。</p>
<p>先来看我们最熟悉的单例模式，我们之前看到的最多的单例模式实现是像下面这种，线程安全的双重检查锁懒汉单例。</p>
<a id="more"></a> 

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ThreadSafeSingleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadSafeSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (ThreadSafeSingleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                singleton = <span class="keyword">new</span> ThreadSafeSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种实现方式是懒汉式单例，同时通过双重检查锁规避了线程安全问题和性能问题，同时利用 volatile 关键字杜绝 JVM 的指令重排，避免了多线程情况下可能出现 NPE 的问题，上面的实现方式既做到了线程安全，同时又不失性能的单例实现。</p>
<p>那么这里我么说到通过枚举来实现单例又是如何实现的呢，其实很简单，比如下面的代码就是使用枚举来实现的一个单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DeployEnvSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码实现了一个很简单的单例模式，虽然看起来非常简单，但是做的事情一点也不比上面开头提出的单例模式少，甚至在某些极端情况下还有特殊的效果。先来看看这个简单的单例做到了哪些事情：</p>
<ul>
<li>只会创建一个实例，因为枚举类型可确保 JVM 中仅存在所定义的常量的一个实例</li>
<li>线程安全，因为 Java 虚拟机在加载枚举类的时候，会使用 ClassLoader 的 loadClass 方法，而这个方法使用了同步代码块来保证线程安全</li>
<li>反射安全，因为JVM 会阻止反射获取枚举类的私有构造方法，而其他的单例实现是可以通过反射来创建对象的</li>
<li>序列化/反序列化安全，你用序列化工具对该实例进行序列化然后再反序列化会发现得到值是同一个</li>
<li>优雅简单，从代码就可以看出来实现非常简单</li>
</ul>
<p>从列举的这些可以看出使用枚举来实现单例是非常好的选择，当然唯一的一个缺点是不能实现懒加载，枚举中的实例不管我们有没有用到它，它都已经创建好了在那里。</p>
<p>说完单例，再看下策略模式又是怎样的。一般我们实现策略模式是通过实现接口的方式来实现的，每加一个新的策略就加一个子类实现相应的接口</p>
<p><img src="/images/strategy_uml.png" alt="strategy_uml"></p>
<p>上面就是策略模式的 UML 图，Strategy 是接口，ConcreteStrategyA 和 ConcreteStrategyB 是具体的策略实现，增加的新的策略则再加一个子类实现 Strategy 接口，然后我们再看采用枚举的实现方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnvEnum &#123;</span><br><span class="line"></span><br><span class="line">    DEVELOPMENT&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">(Issue issue)</span> </span>&#123;</span><br><span class="line">            System.out.println(issue.getId() + <span class="string">&quot; issue will deploy to DEVELOPMENT&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    TESTING&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">(Issue issue)</span> </span>&#123;</span><br><span class="line">            System.out.println(issue.getId() + <span class="string">&quot; issue will deploy to TESTING&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    PRODUCTION&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">(Issue issue)</span> </span>&#123;</span><br><span class="line">            System.out.println(issue.getId() + <span class="string">&quot; issue will deploy to PRODUCTION&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">(Issue issue)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是一个简易的策略模式，预先定义了三个环境，dev，test，prod，后期如果想要再加一个环境 staging 只需要在枚举类中再加一个 STAGING 实例即可。</p>
<p>整体看下来是不是觉得枚举这个类型还是可以做到很多特性的，不过我最喜欢枚举的一点还是它能够帮助我们写出易于阅读同时又非常优雅的代码。所以说好好利用枚举这个类型，也让你代码实现更优雅一些吧。</p>
<p>完整测试代码地址：<a href="https://github.com/rookiedev-z/sample/tree/master/java-basic-sample">Java basic sample</a></p>
<p>参考：<a href="https://www.baeldung.com/a-guide-to-java-enums">https://www.baeldung.com/a-guide-to-java-enums</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 细粒度锁续篇</title>
    <url>/Java-%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E7%BB%AD%E7%AF%87/</url>
    <content><![CDATA[<p>在上篇文章中大概介绍了 Java 中细粒度锁的几种实现方式，并且针对每种方式都做了优缺点说明，在使用的时候就需要根据业务需求选择更合适的一种。上篇文章中的最后一种弱引用锁的实现方式，我在里面也说了其实还有更优雅的实现，其实也算不上更优雅，只是看起来更优雅，原理还是一样的，今天我打算用一篇文章的篇幅来好好说下。</p>
<a id="more"></a>

<p>首先，我们来再次回顾一下，这里为什么可以利用弱引用的特性拿掉分段锁呢？分段锁在这里主要是为了保证每次在创建和移除锁时的线程安全，而采用了弱引用之后，我们不需要每次创建之后都进行移除，因为当弱引用指向的对象引用被释放之后 Java 会在下一次的 GC 将这弱引用指向的对象回收掉，在经过 GC 之后，当弱引用指向的对象被回收时，弱引用将会进入创建时指定的队列，然后我们通过队列中的值来将这些存放在 Map 中的弱引用移除掉，所以我们才能够顺利的拿掉分段锁。</p>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>你注意看弱引用锁的代码实现，里面在我们获取锁的时候有个手动去清理 Map 中被回收的锁的过程，如果你看过之前的 <a href="https://mp.weixin.qq.com/s/ElbPYeRSHfDxD62b14ZVGw">谈谈 Java 中的各种引用类型</a>  这篇文章的话，你应该知道 Java 提供了一个 WeakHashMap 类，他是使用弱引用作为 key，它在 GC 决定将弱引用所指向的 key 对象回收之后，会将当前保存的 entry 也自动移除，这个是怎么实现的呢？</p>
<p>其实原理也是一样的，利用弱引用指向的对象被回收时，弱引用将会进入创建时指定的队列这一特性，然后通过轮询队列来移除元素。只不过将移除的操作完全包裹在 WeakHashMap 类里面了，你可以看到里面所有的 public 的增删改查方法都直接或间接调用了expuntgeStaleEntries() 方法，而 expuntgeStaleEntries 方法中就是在轮询队列移除被回收的 key 所对应的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">      <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">      Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">      Entry&lt;K,V&gt; p = prev;</span><br><span class="line">      <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (prev == e)</span><br><span class="line">            table[i] = next;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            prev.next = next;</span><br><span class="line">          <span class="comment">// Must not null out e.next;</span></span><br><span class="line">          <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">          e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">          size--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = p;</span><br><span class="line">        p = next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然 Java 已经给我们提供了相应功能的类，那我们是不是可以在弱引用锁的实现中直接使用 WeakHashMap 呢？这样我们就不用在获取锁的时候做手动移除的操作了，WeakHashMap 内部已经帮我们做了。</p>
<p>但如果你稍微看一下 WeakHashMap 类的描述就能发现他不是线程安全的，在该类里面有这样一段描述:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Like most collection classes, this class is not synchronized. A synchronized &#123;@code WeakHashMap&#125; may be constructed using the &#123;@link Collections#synchronizedMap Collections.synchronizedMap&#125; method.</span><br></pre></td></tr></table></figure>

<p>正因为如此，在弱引用的实现中才采用 ConcurrentHashMap 来保存锁，只不过 ConcurrentHashMap 类没有提供弱引用的实现，也就没有提供自动为我们移除元素的功能，所以才会在获取锁的时候做一个移除元素的操作，相信看到这里你应该大概明白了使用弱引用作为 key 的 WeakHashMap 是怎么做到当弱引用被回收的时候自动把对应的元素给移除了。</p>
<p>那如果说按照上面描述里面所说的通过 Collections 工具类的 synchronizedMap 方法来实现线程安全呢？先来看代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map&lt;T, WeakReference&lt;ReentrantLock&gt;&gt; weakHashMap =</span><br><span class="line">            Collections.synchronizedMap(<span class="keyword">new</span> WeakHashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReentrantLock <span class="title">get</span><span class="params">(T key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weakHashMap.computeIfAbsent(key, lock -&gt; <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> ReentrantLock())).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中 WeakHashLock 类中只有一个 get 方法根据 key 获取锁对象，不存在的话创建一个新的锁对象返回，看起来是不是很简单，但不幸的是通过 Collections 工具类的 synchronizedMap 方法来实现的线程安全方式性能不是很好，为什么这么说呢，我们可以看下 synchronizedMap 方法实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronizedMap 方法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SynchronizedMap 类构造方法</span></span><br><span class="line">SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">  <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">  mutex = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">  <span class="keyword">this</span>.m = m;</span><br><span class="line">  <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码实现可以看出，synchronizedMap 方法会创建一个SynchronizedMap 实例返回，在该实例的构造方法中将自己赋值给用来同步的对象，然后 SynchronizedMap 类中的方法都使用该同步的对象进行同步，以致于我们做的每一个操作都需要进行同步，其实就相当于给 WeakHashMap 类中实例方法都加上了 synchronized 关键字，这种实现方式性能难免会大打折扣。</p>
<h3 id="ConcurrentReferenceHashMap"><a href="#ConcurrentReferenceHashMap" class="headerlink" title="ConcurrentReferenceHashMap"></a>ConcurrentReferenceHashMap</h3><p>这种方式不可取的原因主要是因为 WeakHashMap 不是线程安全的，那有没有线程安全的并且实现了弱引用来保存元素的 Map 呢？当然上篇文章中的实现是一种方式，那如果也想像 WeakHashMap 一样将这些移除的操作完全封装到 Map 类里面呢。我们可以看下 org.springframework.util 包下的 ConcurrentReferenceHashMap 类，该类就很好的实现了我们想要的效果，在该类的描述中就提到了这样一段话:</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">This class can be used as an alternative to &#123;@code Collections.synchronizedMap(new WeakHashMap&lt;K, Reference&lt;V&gt;&gt;())&#125; in order to support better performance when accessed concurrently. This implementation follows the same design constraints as &#123;@link ConcurrentHashMap&#125; with the exception that &#123;@code null&#125; values and &#123;@code null&#125; keys are supported.</span><br></pre></td></tr></table></figure>

<p>从描述中可以看到 ConcurrentReferenceHashMap 类可以用来替代使用 synchronizedMap 方法保证线程安全的 WeakHashMap 类，以便在并发访问时提供更好的性能。那就来看下采用 ConcurrentReferenceHashMap 类的实现方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentReferenceHashMap.ReferenceType DEFAULT_REFERENCE_TYPE =</span><br><span class="line">            ConcurrentReferenceHashMap.ReferenceType.WEAK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentReferenceHashMap&lt;T, ReentrantLock&gt; referenceHashMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create mutex factory with default settings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakHashLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenceHashMap = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(DEFAULT_INITIAL_CAPACITY,</span><br><span class="line">                DEFAULT_LOAD_FACTOR,</span><br><span class="line">                DEFAULT_CONCURRENCY_LEVEL,</span><br><span class="line">                DEFAULT_REFERENCE_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakHashLock</span><span class="params">(<span class="keyword">int</span> concurrencyLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ConcurrentReferenceHashMap.ReferenceType referenceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenceHashMap = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(DEFAULT_INITIAL_CAPACITY,</span><br><span class="line">                DEFAULT_LOAD_FACTOR,</span><br><span class="line">                concurrencyLevel,</span><br><span class="line">                referenceType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReentrantLock <span class="title">get</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.referenceHashMap.computeIfAbsent(key, lock -&gt; <span class="keyword">new</span> ReentrantLock());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码实现同样非常简单，相比上面 WeakHashMap 的方式多了两个构造方法而已，但不同于使用 synchronizedMap 方法来保证线程安全的方式，性能会提高很多。如果你感兴趣的话可以去看下这个类的内部实现，原理都是利用了弱引用的特性，只不过实现方式有点不同而已。</p>
<p>这里我想要提醒两点，一个是 ConcurrentReferenceHashMap 中默认的引用类型是软引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceType DEFAULT_REFERENCE_TYPE = ReferenceType.SOFT;</span><br></pre></td></tr></table></figure>

<p>另外一个要注意的是 ConcurrentReferenceHashMap 中有的方法返回的结果是 GC 之后但还没有清理被回收元素之前的结果，什么意思呢，我们来看一个示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentReferenceHashMap&lt;String, String&gt; referenceHashMap = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="number">1</span>, ConcurrentReferenceHashMap.ReferenceType.WEAK);</span><br><span class="line">referenceHashMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">// 经过 GC 标记之后，弱引用已经进入创建时指定的队列中，这时可以去轮询队列移除元素了</span></span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// isEmpty 和 size 方法返回的结果是还没有移除元素的结果</span></span><br><span class="line">System.out.println(referenceHashMap.isEmpty()); <span class="comment">// false</span></span><br><span class="line">System.out.println(referenceHashMap.size()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// get 方法中调用了移除元素的方法</span></span><br><span class="line">System.out.println(referenceHashMap.get(<span class="string">&quot;key&quot;</span>)); <span class="comment">// null</span></span><br><span class="line">System.out.println(referenceHashMap.isEmpty()); <span class="comment">// true</span></span><br><span class="line">System.out.println(referenceHashMap.size()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面测试结果可以看到，在 GC 标记之后调用 isEmpty 和 size 方法得到的返回结果都表明集合中是还有元素，而调用 get 方法得到的却是个 null，然后再调用 isEmpty 和 size 方法得到的结果表示集合为空，这其实是因为前面两个方法里面没有做移除元素的操作，而 get 方法是先做了一次移除元素然后再去获取值，这里提醒下这个细节问题，避免以为 ConcurrentReferenceHashMap 没有实现移除元素的功能。</p>
<p>好了，上面都是利用弱引用特性再配合 ReentrantLock 实现了细粒度锁，这里就再顺便看下利用弱引用特性配合 synchronized 关键字的实现方式吧。同样，原理是一样，只不过从 ReentrantLock 再回到 synchronized，前面说了这么多的原理，就不再赘述了，直接看代码实现吧:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于同步的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mutex</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Mutex&lt;T&gt; <span class="title">of</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mutex&lt;&gt;(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Mutex&lt;?&gt; xMutex = (Mutex&lt;?&gt;) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(key, xMutex.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentReferenceHashMap.ReferenceType DEFAULT_REFERENCE_TYPE =</span><br><span class="line">            ConcurrentReferenceHashMap.ReferenceType.WEAK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentReferenceHashMap&lt;T, Mutex&lt;T&gt;&gt; referenceHashMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutexFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenceHashMap = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(DEFAULT_INITIAL_CAPACITY,</span><br><span class="line">                DEFAULT_LOAD_FACTOR,</span><br><span class="line">                DEFAULT_CONCURRENCY_LEVEL,</span><br><span class="line">                DEFAULT_REFERENCE_TYPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutexFactory</span><span class="params">(<span class="keyword">int</span> concurrencyLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ConcurrentReferenceHashMap.ReferenceType referenceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenceHashMap = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(DEFAULT_INITIAL_CAPACITY,</span><br><span class="line">                DEFAULT_LOAD_FACTOR,</span><br><span class="line">                concurrencyLevel,</span><br><span class="line">                referenceType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mutex&lt;T&gt; <span class="title">getMutex</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.referenceHashMap.computeIfAbsent(key, Mutex::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 提供强制移除已经被回收的弱引用元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purgeUnreferenced</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.referenceHashMap.purgeUnreferencedEntries();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们一般实现的细粒度基本上是基于用户或者其他的需要同步的对象，上面是通过构建一个互斥对象作为 ConcurrentReferenceHashMap 的 value，然后我们就可以使用 synchronized 关键字来锁定该 value 对象达到同步的效果，使用方式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MutexFactory&lt;String&gt; mutexFactory = <span class="keyword">new</span> MutexFactory&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String userId)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (mutexFactory.getMutex(userId))&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种同步方式业务代码看起来简单些，对于一些简单的需求就可以直接使用这种方式，当然如果需要提供 API 级别的加锁方式或者需要构建带条件的加锁方式那还是使用 ReentrantLock。</p>
<p>对于加锁这一块虽然说了这么多，也许你已经打算采用这些方式去实现你想要的效果了，可是呢随着微服务大行其道，一个系统往往启动了好几个实例，每个实例对应一个 JVM 虚拟机，而我们前面说的这些都是在只有一个虚拟机的前提下才有用，这就意味着我们前面说的这些加锁方式基本上已经派不上用场了。</p>
<p>那随之而来的解决方案就是我们经常听到并且感觉很高大上，却很少用到的分布式锁了，这一块我虽然使用过，也去查阅过相关资料，但我自认为没有完全真正掌握底层的原理，还需要进一步的实践，只好再找机会整理整理后再输出了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 面试系列——基础篇(一)</title>
    <url>/Java-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%B8%80/</url>
    <content><![CDATA[<h2 id="面向对象的特征：封装、继承、多态、抽象"><a href="#面向对象的特征：封装、继承、多态、抽象" class="headerlink" title="面向对象的特征：封装、继承、多态、抽象"></a>面向对象的特征：封装、继承、多态、抽象</h2><p>封装给对象提供了隐藏内部特性和行为的能力，对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 4 种访问权限，对应有三个修饰符 : public、private 、protected，每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。下面列出了使用封装的一些好处:</p>
<a id="more"></a>
<ul>
<li>通过隐藏对象的属性来保护对象内部的状态</li>
<li>提高了代码的可用性和可维护性,因为对象的行为可以被单独的改变或者是扩展</li>
<li>禁止对象之间的不良交互提高模块化</li>
</ul>
<p>继承给对象提供了从基类获取字段和方法的能力、继承提供了代码的重用行、在不修改类的情况下给现存的类添加新特性。</p>
<p>多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力，一个多态类型上的操作可以应用到其他类型的值上面。</p>
<p>抽象是把想法从具体的实例中分离出来的步骤,因此,要根据他们的功能而不是实现细节来创建类，Java 支持创建只暴漏接口而不包含方法实现的抽象的类，这种抽象技术的主要目的是把类的行为和实现细节分离开。</p>
<p>** 备注: 抽象和封装是互补的概念。一方面,抽象关注对象的行为。另一方面,封装关注对象行为的 细节。一般是通过隐藏对象内部状态信息做到封装,因此,封装可以看成是用来提供抽象的一种策略。**</p>
<h2 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h2><p>final : 修饰符(关键字)，如果一个类被声明为 final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract 的,又被声明为 final 的。将变量或方法声明为 final,可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值,而在以后的引用中只能读取,不可修改。被声明为 final 的方法也同样只能使用,不能重载。</p>
<p>finally : 在异常处理时提供 finally 块来执行资源释放操作，如果抛出一个异常，那么相匹配的 catch 子句就会执行,然后就会进入 finally 块(如果有的话)。</p>
<p>finalize : 方法名，Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作，这个方法是由垃圾收集器在确定这个对象没有被引用时在释放对象占用的内存之前会调用该方法，它是在 Object 类中定义的，因此所有的类都继承了它，子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。</p>
<h2 id="Exception、Error、运行时异常与一般异常有何异同"><a href="#Exception、Error、运行时异常与一般异常有何异同" class="headerlink" title="Exception、Error、运行时异常与一般异常有何异同"></a>Exception、Error、运行时异常与一般异常有何异同</h2><p>error 表示程序运行出错了，它是一种比较严重的问题，比如说内存溢出，不可能指望程序能处理这样的情况。</p>
<p>exception 表示程序运行过程中可能会出现的异常情况，如果程序运行正常的话不会发生的情况。</p>
<p>异常表示程序运行过程中可能出现的非正常状态。运行时异常表示虚拟机的通常操作中可能遇到的异常,是一种常见运行错误，比如说 NullPointerException、IndexOutOfBoundsException、NumberFormatException、ClassCastException、IllegalArgumentException，这类异常的话 Java 虚拟机并不要求声明抛出或者捕获。而对于一般异常 Java 编译器要求方法必须声明抛出或者捕获，常见的这类异常有IOException、SQLException、InternetedException。</p>
<h2 id="int-和-Integer-有什么区别，Integer-的值缓存范围"><a href="#int-和-Integer-有什么区别，Integer-的值缓存范围" class="headerlink" title="int 和 Integer 有什么区别，Integer 的值缓存范围"></a>int 和 Integer 有什么区别，Integer 的值缓存范围</h2><p>Java 中有八种基本数据类型，int 就是其中一种，而每一种基本数据类型都有其对应的包装类型，两者之间的转换也称为自动装箱和自动拆箱。</p>
<p>对于 Integer 的值 Java 会进行缓存，值在 -128 - 127 之间的数字会进行缓存。</p>
<h2 id="String、StringBuilder、StringBuffer-的理解"><a href="#String、StringBuilder、StringBuffer-的理解" class="headerlink" title="String、StringBuilder、StringBuffer 的理解"></a>String、StringBuilder、StringBuffer 的理解</h2><p>首先 String 字符串常量，被 final 所修饰，不可被继承，StringBuilder 字符串变量，非线程安全，StringBuffer 字符串变量，线程安全，由于 String 是字符串常量，不可变，当涉及到字符串的拼接时会频繁的创建对象，所以这时需要使用 StringBuilder 和 StringBuffer 这两个类了，当然如果没有涉及到多线程的话尽量使用 StringBuilder ，它比 StringBuffer 这个类处理速度要快，当然如果涉及到多线程的话就只能使用 StringBuffer 类了。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p>方法的重写 Overriding 是父类与子类之间多态性的一种表现，如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写，子类重写的方法访问修饰符的限制一定要大于被重写方法的访问修饰符 (public&gt;protected&gt;default&gt;private)，重写方法一定不能抛出新的检查异常或者比被重写方法声明更加宽泛的检查型异常。</p>
<p>重载 Overloading 是一个类中多态性的一种体现，子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们有不同的参数个数或者有不同的参数类型，则称为方法的重载 Overloading，Overloaded 的方法是可以改变返回值的类型，也可以有不同的访问修饰符，还可以抛出不同的异常。</p>
<h2 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h2><p>抽象类是对根源的抽象，它表示的是这个对象是什么。同时抽象类中可以没有抽象方法，抽象类中的变量可以任意定义，对于抽象方法是要被实现的，所以不能是静态的也不能是私有的，</p>
<p>接口是对动作的抽象，接口表示的是这个对象能做什么。对于接口中的抽象方法默认是都是公开的，接口里定义的变量只能是公共的静态的常量，接口中一般只做方法的声明，不过在 Java 8 中可以有具体的实现，一种是由 static 修饰，另一种使用 default关键字修饰，对于 static 修饰的由接口名称直接调用，而对于 default 修饰的方法则需要对应的实现类去调用，如果一个类实现了多个接口，而且这些接口中都有相同的默认方法时，此时必须重写掉默认方法，否则编译失败。</p>
<h2 id="反射的用途及实现"><a href="#反射的用途及实现" class="headerlink" title="反射的用途及实现"></a>反射的用途及实现</h2><p>当程序运行时，允许动态的改变程序结构或变量类型，通过反射我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。由于在运行时才动态加载的类或调用方法或属性，所以不需要事先（写代码的时候或编译期）知道运行对象是谁。<br>当我们在使用 IDE 时，当我们输入一个对象名或者类名并想调用它的属性和方法时，一按 (“.”) 点号，编译器就会自动列出它的属性和方法，这里就会用到反射。</p>
<p>反射最重要的用途就是开发各种通用框架，很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p>
<ul>
<li><p>先获得一个类的 Class 对象 :<br>  Class<?> klass = Class.forName(class 全类名);
Class<?> klass = 对象.class; 或者 Class<?> klass = 对象.getClass();
又或者 Class<?> klass = 类名.TYPE;</p>
</li>
<li><p>再通过拿到的 Class 对象创建实例 :<br>  Object str = klass.getInstance(); 或者<br>  Constructor constructor = klass.getConstructor(String.class);<br>//根据构造器创建实例<br>Object obj = constructor.newInstance(“23333”);</p>
</li>
</ul>
<h2 id="HTTP请求的-GET-与-POST-方式的区别"><a href="#HTTP请求的-GET-与-POST-方式的区别" class="headerlink" title="HTTP请求的 GET 与 POST 方式的区别"></a>HTTP请求的 GET 与 POST 方式的区别</h2><ul>
<li>GET 方式会将请求的参数拼接在 URL 后面，会显示在地址栏中，而 POST 方式则是         放在请求体中</li>
<li>GET方式提交的数据最多只能有 1024 字节，POST 方式没有限制</li>
<li>HTTP 请求默认是 GET 方式，对于敏感的数据类型最好采用 POST 方式提交请求。</li>
</ul>
<h2 id="Session与Cookie区别"><a href="#Session与Cookie区别" class="headerlink" title="Session与Cookie区别"></a>Session与Cookie区别</h2><ul>
<li>Cookie 和 Session 都是会话技术，Cookie 是运行在客户端，Session 是运行在服务器端，通过生成的 sessionId 来区分不同的客户，同时将 sessionId 的值通过 Cookie 返回给客户端。</li>
<li>Cookie 有大小限制以及浏览器在存 Cookie 的个数也有限制，Session 是没有大小限制的，和服务器的内存大小有关。</li>
<li>Cookie 有安全隐患，通过拦截或本地文件找得到你的 Cookie 后可以进行攻击。</li>
<li>Session 是保存在服务器端会存在一段时间才会消失，如果 Session 过多会增加服务器的压力。</li>
</ul>
]]></content>
      <categories>
        <category>面试系列</category>
      </categories>
  </entry>
  <entry>
    <title>Java 面试系列——基础篇(二)</title>
    <url>/Java-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="Java-中-equals-与-的区别"><a href="#Java-中-equals-与-的区别" class="headerlink" title="Java 中 equals 与 == 的区别"></a>Java 中 equals 与 == 的区别</h2><p>通俗的来说，“==” 比较的是地址，equals 比较的是内容。也就是说前者比较的是对象(堆)在(栈)内存中存放的内存地址，用来判断两个对象的地址是否相同，即是否是指向同一个对象。后者用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object 类的，所以适用于所有对象，注意如果没有对该方法进行重写的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是内存地址比较的结果，方法内容如下 ：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hashCode-和-equals-方法的区别与联系"><a href="#hashCode-和-equals-方法的区别与联系" class="headerlink" title="hashCode 和 equals 方法的区别与联系"></a>hashCode 和 equals 方法的区别与联系</h2><p>hashCode 和 equals 方法都是 Object 中的方法，其中 hashCode 方法是 Native 修饰，该方法是计算出对象实例的哈希码，又称哈希函数，计算方式依赖于对象实例的内存地址，所以一般来说，每个对象实例的哈希码都是唯一的，当然如果对该方法进行重写了，结果也就不一样了。而 equals 方法一般是用来比较两个对象实例的值是否相等，当然如果没有对该方法进行重写，比较的就是两个对象的地址是否相等。</p>
<p>他们之间的联系就是当两个对象的 equals 相等那么 hashCode 一定相等，hashCode 不等那么equals 一定不等。反之 hashCode 相等，equals 不一定相等，因为哈希散列值有冲突的时候，当然好的哈希算法冲突的几率比较小。</p>
<p>其次在我们开发当中，一般都会同时对这两个方法进行重写，如果只重写其中一个或者都不重写当我们将这个对象放入 Map 集合或者 Set 集合中时就会出问题了。如果只重写了 hashCode 方法没有重写 equals 方法，那么就会出现 hashCode 值相同时，这时找到数组同一个位置的元素链表，由于没有重写 equals 方法导致向 Map 中取元素时找不到你要找的元素；当向 Map 集合中放入元素时就会放入重复的元素，因为此时比较的是两个元素的内存地址。如果只重写了 equals 方法没有重写 hashCode 方法，当你向 Map 中获取元素时，第一步比较 hashCode 值时就已经不等，所以也就找不到你想要找的元素了；当你向 Map 中放入元素时，第一步比较就始终定位在数组的不同的位置，这样也就达不到覆盖 key 值相同的元素，Set 集合也达不到去重的效果了。</p>
<p>还有就是对于需要大量并且快速的对比的话如果都用 equals 方法做比较显然效率太低，所以解决方式是每当需要对比的时候，首先用 hashCode 方法进行对比，如果hashCode 不一样，则表示这两个对象肯定不相等（也就是不必再用 equals 对比了），如果 hashCode 相同，此时再通过 equals 方法对比，如果 equals 也相同则表示这两个对象是真的相同了，这样既能大大提高效率也保证对比的绝对正确性！</p>
<p><strong><em>总之，这两个方法对实现 HashMap 的精确性和正确性，以及对 Set 集合中去重功能的实现至关重要，以下 String 类中的 hashCode 方法和 equals 方法：</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    int h &#x3D; hash;</span><br><span class="line">    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">        char val[] &#x3D; value;</span><br><span class="line">    </span><br><span class="line">        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;</span><br><span class="line">            h &#x3D; 31 * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash &#x3D; h;</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>public boolean equals(Object anObject) &#123;
    if (this == anObject) &#123;
        return true;
    &#125;
    if (anObject instanceof String) &#123;
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) &#123;
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) &#123;
                if (v1[i] != v2[i])
                    return false;
                i++;
            &#125;
            return true;
        &#125;
    &#125;
    return false;
&#125;</code></pre>
<h2 id="什么是-Java-序列化和反序列化，如何实现-Java-序列化？或者请解释-Serializable-接口的作用"><a href="#什么是-Java-序列化和反序列化，如何实现-Java-序列化？或者请解释-Serializable-接口的作用" class="headerlink" title="什么是 Java 序列化和反序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用"></a>什么是 Java 序列化和反序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用</h2><p>序列化就是一种用来处理对象流的机制,所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间，序列化是为了解决在对对象流进行读写操作时所引发的问题。反序列话则刚好相反，将流化后的对象重新恢复成对象状态就称为反序列化。<br>序列化的实现:将需要被序列化的类实现 Serializable 接口,该接口没有需要实现的方法，实现 Serializable 接口只是为了标注该对象是可被序列化的，然后使用一个输出流(如:FileOutputStream)来构造一个 ObjectOutputStream (对象流)对象，接着使用ObjectOutputStream 对象的 writeObject(Object obj) 方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则使用输入流。</p>
<h2 id="Object-类中常见的方法，为什么-wait-notify-会放在-Object-里边？"><a href="#Object-类中常见的方法，为什么-wait-notify-会放在-Object-里边？" class="headerlink" title="Object 类中常见的方法，为什么 wait notify 会放在 Object 里边？##"></a>Object 类中常见的方法，为什么 wait notify 会放在 Object 里边？##</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;&#125;</span><br><span class="line">public boolean equals(Object obj) &#123;&#125;</span><br><span class="line">public native int hashCode();</span><br><span class="line">protected void finalize() throws Throwable &#123;&#125;</span><br><span class="line">public final native Class&lt;?&gt; getClass();</span><br><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br><span class="line">public final void wait() throws InterruptedException &#123;&#125;</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;&#125;</span><br><span class="line">public final native void notify();</span><br><span class="line">public final native void notifyAll();</span><br><span class="line">private static native void registerNatives();</span><br></pre></td></tr></table></figure>
<p>以上便是 Object 类中所有的方法，其中 toString(), equals(), hashCode() 三个方法是我们见的相对较多的，finalize() 这个方法是由垃圾收集器在确定这个对象没有被引用时在释放对象占用的内存之前会调用该方法，clone() 方法是给对象创建一个自己的副本，前提是对象已经实现了 Cloneable 接口，否则抛出 CloneNotSupportedException，getClass() 方法返回此对象的运行时类型。</p>
<p>wait 有三个重载方法，同时必须捕获非运行时异常 InterruptedException。</p>
<ul>
<li>wait() 进入等待，需要 notify()，notifyAll() 才能唤醒</li>
<li>wait(long timeout) 进入等待，经过 timeout 超时后，若未被唤醒，则自动唤醒</li>
<li>wait(timeout, nanos) 进入等待，经过 timeout 超时后，若未被唤醒，则自动唤醒。相对 wait(long timeout) 时间更加精确。</li>
</ul>
<p>wait() 和 notify() 以及 notifyAll() 则是用来控制线程的状态的，它们必须在 synchronized 同步关键字所限定的作用域中调用，否则会报错 java.lang.IllegalMonitorStateException，意思是因为没有同步，所以线程对象锁的状态是不确定的，不能调用这些方法。同时 synchronized 关键字锁可以是任意对象，任意对象调用的方法则一定是定义在 Object 类中。</p>
<ul>
<li><p>wait 表示持有对象锁的线程准备释放对象锁，释放资源并进入等待状态，直到它被其他线程通过 notify() 或者 notifyAll() 唤醒。</p>
</li>
<li><p>notify 表示持有对象锁的线程准备释放对象锁，调用 notify() 通知 JVM 随机选择一个在该对象上调用 wait() 方法的线程，解除其阻塞状态使其获得对象锁，synchronized 代码作用域结束后，随机选择的那个线程获得对象锁，其他调用 wait() 方法的线程继续等待，直到有新的 notify() 或者 notifyAll() 被调用。</p>
</li>
<li><p>notifyAll 表示持有对象锁的线程准备释放对象锁，调用 notifyAll() 通知 JVM 唤醒所有在该对象上调用 wait() 方法的线程的阻塞状态, synchronized 代码作用域结束后，JVM 通过算法将对象锁指派给其中一个线程，当前获得对象锁的线程 synchronized 代码作用域结束后，然后所有被唤醒的线程不再等待，之前所有被唤醒的线程都有可能获得该对象锁权限，这个由 JVM 算法决定。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试系列</category>
      </categories>
  </entry>
  <entry>
    <title>JdbcTemplate 实现批量插入</title>
    <url>/JdbcTemplate-%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<p>项目中有时候我们会遇到 excel 导入的需求, excle 文件的每一行记录对应的可能都是数据库中的一条记录，一个 excel 中可能有很多行，所以导入一个 excel 就意味着 excel 里面有多少行，我们就要插入多少条记录。如果我们采用一条一条记录插入的方式，毫无疑问，这可能要执行很久。</p>
<a id="more"></a>

<p>如果是采用同步的方式的话，页面就会需要等好长一段时间才能有响应。就算采用异步的方式，先给前端一个响应，后台异步执行插入操作，用户也会需要等好长一段时间才能看到刚才 excel 导入的数据。</p>
<p>这时候批量插入的方式就显得很有必要了。这里我们采用 JdbcTemplate 来实现批量插入。</p>
<p>这里再次以活动统计表 activity_stats 来举例，比如需求就是要导入一份活动统计的 excel 数据,这里为了简单起见，就通过 for 循环来模拟构造一份 excel 数据。</p>
<p>这里我两种方式都实现了，一种是通过 for 循环一个一个保存的，另一种则是批量插入。先声明我测试使用的 mysql 驱动版本是:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>spring jdbc 依赖版本是:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先我们看 for 循环的方式，代码很简单，我就直接贴出来了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertStats</span><span class="params">(List&lt;ActivityStat&gt; activityStatList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(activityStatList))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = <span class="string">&quot;insert into activity_stats(activity_id, times_viewed, works_count, user_count) values(?, ?, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        activityStatList.forEach(item -&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.jdbcTemplate.update(sql, preparedStatement -&gt; &#123;</span><br><span class="line">                preparedStatement.setLong(<span class="number">1</span>, item.getActivityId());</span><br><span class="line">                preparedStatement.setLong(<span class="number">2</span>, item.getTimesViewed());</span><br><span class="line">                preparedStatement.setLong(<span class="number">3</span>, item.getWorksCount());</span><br><span class="line">                preparedStatement.setLong(<span class="number">4</span>, item.getUserCount());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">&quot;insert state cost &#123;&#125; s&quot;</span>, (System.currentTimeMillis() - start) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面则是批量的方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchInsertStats</span><span class="params">(List&lt;ActivityStat&gt; activityStatList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(activityStatList))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String sql = <span class="string">&quot;insert into activity_stats(activity_id, times_viewed, works_count, user_count) values(?, ?, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate.batchUpdate(sql, <span class="keyword">new</span> BatchPreparedStatementSetter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PreparedStatement preparedStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                ActivityStat data = activityStatList.get(i);</span><br><span class="line">                preparedStatement.setLong(<span class="number">1</span>, data.getActivityId());</span><br><span class="line">                preparedStatement.setLong(<span class="number">2</span>, data.getTimesViewed());</span><br><span class="line">                preparedStatement.setLong(<span class="number">3</span>, data.getWorksCount());</span><br><span class="line">                preparedStatement.setLong(<span class="number">4</span>, data.getUserCount());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBatchSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> activityStatList.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">&quot;batch insert state cost &#123;&#125; s&quot;</span>, (System.currentTimeMillis() - start) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码实现写好了，接下来我们来测试下看看效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsertStats</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ActivityStat&gt; activityStatList = mockStatsData();</span><br><span class="line">        <span class="keyword">this</span>.activityStatService.insertStats(activityStatList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchInsertStats</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ActivityStat&gt; activityStatList = mockStatsData();</span><br><span class="line">        <span class="keyword">this</span>.activityStatService.batchInsertStats(activityStatList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 mockStatsData() 方法是一个 for 循环构建了 10000 个 ActivityStat，返回 activityStatList:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ActivityStat&gt; <span class="title">mockStatsData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;ActivityStat&gt; activityStatList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            ActivityStat activityStat = <span class="keyword">new</span> ActivityStat();</span><br><span class="line">            activityStat.setActivityId((<span class="keyword">long</span>)i)</span><br><span class="line">                    .setTimesViewed((<span class="keyword">long</span>)(i + <span class="number">100</span>))</span><br><span class="line">                    .setWorksCount((<span class="keyword">long</span>) i + <span class="number">50</span>)</span><br><span class="line">                    .setUserCount((<span class="keyword">long</span>) i + <span class="number">10</span>);</span><br><span class="line">            activityStatList.add(activityStat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activityStatList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行测试的结果是下面这样的:<br><img src="/images/inser_stats_result.png" alt="insert stats result"></p>
<p><img src="/images/batch_insert_stats_result.png" alt="batch insert stats result"></p>
<p>往数据库中插入 10000 条记录，采用 for 循环的方式和采用批量的方式插入竟然时间量级是一样的，是不是有点懵，说实话刚开始我也有点懵，就觉得不应该啊，如果这样的话那还要 batchUpdate 方法有什么意义呢。</p>
<p>懵归懵，但还是要找出其中的原因来，正常来说肯定不会是这种结果，应该是哪个环节没弄好，从我们写的代码来看应该是没有问题的，那就通过 debug 的方式看看 batchUpdate 方法里面到底是怎么执行的。这里建议如果要 debug 的源码是稍微比较复杂的，建议不要直接看 class 文件，calss 文件毕竟是编译之后的，代码看起来不是那么的直观，可以在打开 class 文件之后点击右上角提示的下载源码按钮。<br><img src="/images/download_source.png" alt="download_source"></p>
<p>通过 debug 的方式我在 ClientPreparedStatement 类中找到下面这样一段代码:<br><img src="/images/batch_insert_condition.png" alt="batch insert condition"></p>
<p>这里有个判断 !this.batchHasPlainStatements &amp;&amp; this.rewriteBatchedStatements.getValue()<br>只有这两个条件同时都满足的情况下才会执行下面的 executeBatchedInserts 或 executePreparedBatchAsMultiStatement 方法，这两个都是批量的方法，第一个是针对 Insert 语句的，下面那个是 Update 和 Delete 语句的批量方法。</p>
<p>当上面这两个条件只要有一个不满足，就会执行最下面的 executeBatchSerially 方法，而在这个方法的内部可以看到有一个 for 循环，然后在 for 循环里面一个一个执行 SQL。<br><img src="/images/batch_insert_for_loop.png" alt="batch insert for loop"></p>
<p>看到这里再仔细看上面两个条件，对于    !this.batchHasPlainStatements 是类的一个属性，默认值是 false:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Does the batch (if any) contain &quot;plain&quot; statements added by</span></span><br><span class="line"><span class="comment">     * Statement.addBatch(String)?</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * If so, we can&#x27;t re-write it to use multi-value or multi-queries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> batchHasPlainStatements = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>只有在 addBatch 方法中才会置为 true，所以第一个条件满足的。再看第二个条件 thi.rewriteBatchedStatements,是父类的一个属性:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> RuntimeProperty&lt;Boolean&gt; rewriteBatchedStatements;</span><br></pre></td></tr></table></figure>
<p><img src="/images/jdbc_url_property.png" alt="jdbc_url_property"><br>再看这个属性的初始化值的地方应该能猜到是这个是数据库地址 url 后面接的配置信息。</p>
<p>到这里我们应该知道为什么批量执行的方式和 for 循环一个一个插入时间量级是一样的了，是由于我们的少了rewriteBatchedStatements=true 的配置，导致 batchUpdate 代码内部其实还是通过 for 循环的方式来执行的，所以量级才会是一样的，接下来我们加上这项配置再执行就可以看到速度明显上来了，下面是加上改配置执行之后的结果:</p>
<p><img src="/images/real_batch_insert_stats_result.png" alt="real batch update result"></p>
<p>插入 10000 条记录用时才 2s，而加上配置之前是 30s。其实 rewriteBatchedStatements=true 配置对于批量的 insert 语句来说，是实现了下面的效果:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats(activity_id, times_viewed, works_count, user_count) <span class="keyword">values</span>(?, ?, ?, ?);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats(activity_id, times_viewed, works_count, user_count) <span class="keyword">values</span>(?, ?, ?, ?);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats(activity_id, times_viewed, works_count, user_count) <span class="keyword">values</span>(?, ?, ?, ?)</span><br><span class="line"><span class="comment"># 重写之后</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats(activity_id, times_viewed, works_count, user_count) <span class="keyword">values</span>(?, ?, ?, ?),(?, ?, ?, ?),(?, ?, ?, ?);</span><br></pre></td></tr></table></figure>
<p>也就是是否将多条重写成一条，然后在发给 MySQL 执行，这样不用一条一条发过去执行，大大提高了执行效率。</p>
<p>好了，上面整体就是 JdbcTemplate 批量插入的实现，记得千万不要忘了加上 rewriteBatchedStatements=true 的配置，不然可能你写完了以为已经实现了批量插入，但结果根本没有达到批量执行的效果。</p>
]]></content>
      <categories>
        <category>JdbcTemplate</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 系统下 AES 解密报错问题</title>
    <url>/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B-AES-%E8%A7%A3%E5%AF%86%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>前两天在开发中遇到一个问题，就是一个服务部署在 Window 系统上的，而另一个服务部署在 Linux 系统上，Linux 系统上的服务需要通过 WebService 向 Window 系统上的服务获取数据，而这个数据是经过 AES 加密的，获取到密文之后需要进行解密，然后拿到解密之后的数据进行处理，但是在 Linux 系统服务上进行解密时却报错了，下面就是报错信息。</p>
<a id="more"></a>

<p><img src="/images/AES-Error.png" alt="解密时报错信息"></p>
<p>遇到错误第一时间找度娘 ( 其实应该找 Google )，结果发现原来是操作系统的原因，Linux 系统下在进行 AES 加解密时生成 key 时是有问题的，key 值的生成方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeyGenerator generator &#x3D; KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">&#x2F;&#x2F;password 为加解密使用的密钥</span><br><span class="line">generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">Key key &#x3D; generator.generateKey();</span><br></pre></td></tr></table></figure>

<p>SecureRandom 的实现尝试完全随机化生成器本身的内部状态，因此随操作系统本身的內部状态而定，该实现在 windows 上每次生成的 key 都相同，但是在 linux 系统上则不同，除非调用方在调用 getInstance 方法之后又调用了 setSeed 方法，将上述生成 key 值的方式改为如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeyGenerator generator &#x3D; KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">&#x2F;&#x2F;generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">SecureRandom secureRandom &#x3D; SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">&#x2F;&#x2F;password 为加解密使用的密钥</span><br><span class="line">secureRandom.setSeed(password.getBytes());</span><br><span class="line">generator.init(128, secureRandom);</span><br><span class="line">Key key &#x3D; generator.generateKey();</span><br></pre></td></tr></table></figure>
<p>上面只是修改了 key 值的生成方式，这样就能够避免在 Linux 系统上加解密失败的错误了。完整的 AES 加解密工具类如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ecjtu.common.util;</span><br><span class="line"></span><br><span class="line">import sun.misc.BASE64Decoder;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line">import javax.crypto.KeyGenerator;</span><br><span class="line">import java.security.Key;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AesEncodeUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String content &#x3D; &quot;www.baidu.com&quot;;</span><br><span class="line">        String pwd &#x3D; &quot;ecjtu&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;加密前content：&quot; + content);</span><br><span class="line">        &#x2F;&#x2F; 加密</span><br><span class="line">        String enContent &#x3D; encodeByAes(content, pwd);</span><br><span class="line">        System.out.println(&quot;加密后content：&quot; + enContent);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 解密</span><br><span class="line">        String deContent &#x3D; decodeByAes(enContent, pwd);</span><br><span class="line">        System.out.println(&quot;解密后content：&quot; + deContent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 加密</span><br><span class="line">     *</span><br><span class="line">     * @param content  待加密内容</span><br><span class="line">     * @param password 加密密钥</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String encodeByAes(String content, String password) &#123;</span><br><span class="line">        Key key &#x3D; generateKey(password);</span><br><span class="line">        BASE64Encoder base64en &#x3D; new BASE64Encoder();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建密码器</span><br><span class="line">            Cipher cipher &#x3D; Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">            byte[] byteContent &#x3D; content.getBytes(&quot;utf-8&quot;);</span><br><span class="line">            &#x2F;&#x2F; 初始化</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">            &#x2F;&#x2F; 加密</span><br><span class="line">            content &#x3D; base64en.encode(cipher.doFinal(byteContent));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 解密</span><br><span class="line">     *</span><br><span class="line">     * @param content  待解密内容</span><br><span class="line">     * @param password 解密密钥</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String decodeByAes(String content, String password) &#123;</span><br><span class="line">        Key key &#x3D; generateKey(password);</span><br><span class="line">        BASE64Decoder base64de &#x3D; new BASE64Decoder();</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] byteContent &#x3D; base64de.decodeBuffer(content);</span><br><span class="line">            &#x2F;&#x2F; 创建密码器</span><br><span class="line">            Cipher cipher &#x3D; Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">            &#x2F;&#x2F; 初始化</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">            &#x2F;&#x2F; 解密</span><br><span class="line">            content &#x3D; new String(cipher.doFinal(byteContent), &quot;UTF8&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据密钥生成加解密使用的 key 值</span><br><span class="line">     *</span><br><span class="line">     * @param password 加解密密钥</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Key generateKey(String password) &#123;</span><br><span class="line">        Key key &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyGenerator generator &#x3D; KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">            &#x2F;&#x2F;下面这种方式在 Linux 系统下会报错</span><br><span class="line">            &#x2F;&#x2F;generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">            SecureRandom secureRandom &#x3D; SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">            secureRandom.setSeed(password.getBytes());</span><br><span class="line">            generator.init(128, secureRandom);</span><br><span class="line">            key &#x3D; generator.generateKey();</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 系统下的软链接和硬链接</title>
    <url>/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>之前一直不是很明白 Linux 系统下的软链接 (soft link) 和硬链接 (hard link) 的区别和用法，今天刚好又用到了，特意花了点时间去了解了一下，暂且在这里记录一下吧。</p>
<a id="more"></a>

<p>在介绍硬链接和软链接之前先介绍一下 Linux 系统下面的文件结构，文件在 Linux 下可以分为两个部分：元数据和用户数据。元数据中主要包含文件的一些附加属性，比如：文件大小，创建时间，所有者信息以及 文件的 inode 索引号，inode 索引号是文件索引节点号，也是文件的唯一标识，我们平常看到的文件名并非是用来区分文件而是一个别名便于我们识别和记忆；用户数据则是文件的数据块内容，也就是该文件保存的真正内容。</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>(1) 含义<br>硬链接表示的是一个文件的 inode 索引号对应于多个文件名，也就是说我们对一个文件创建了多个文件名，它们都对应于同一个 inode 索引号标识的文件，当我们删除其中任意一个文件名，都不会对其他文件名有影响，每删一个文件名，该文件的链接数减一，只有当该文件的链接数为 0 时系统会将其数据块和 inode 索引号回收。</p>
<p>(2) 创建方式<br>eg. 为 /root/fileA 创建硬链接 /home/fileB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln &#x2F;root&#x2F;fileA &#x2F;home&#x2F;fileB</span><br></pre></td></tr></table></figure>

<p>注意：应该使用文件的绝对路径，避免使用相对路径。</p>
<p>(3) 特性</p>
<ul>
<li>文件有相同的 inode 及 data block</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件</li>
<li>文件的链接数为 0 时系统会将其数据块和 inode 索引号回收</li>
</ul>
<p>(4) 使用限制</p>
<ul>
<li>不能对目录创建硬链接，只能对文件创建</li>
<li>不能对不同的文件系统创建硬链接,即两个文件名要在相同的文件系统下</li>
<li>只能对已存在的文件进行创建</li>
</ul>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>(1) 含义<br>软链接其实就是一个普通的文件，有着自己的 inode 索引号和数据块，特殊的是该文件的用户数据块中存放的是另一个文件的路径，有点类似于 Windows 系统中的快捷方式，通过快捷方式可以打开它所指向的文件，链接文件的删除不影响该链接文件数据块存放的路径指向的文件。</p>
<p>(2) 创建方式<br>eg. 为 /root/fileA 创建软链接 /home/fileB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;root&#x2F;fileA &#x2F;home&#x2F;fileB</span><br></pre></td></tr></table></figure>

<p>注意：应该使用文件的绝对路径，避免使用相对路径。</p>
<p>(3) 特性</p>
<ul>
<li>软链接有自己的文件属性及权限等</li>
<li>创建软链接时，链接计数不会增加</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）</li>
</ul>
<p>(4) 使用限制</p>
<ul>
<li>可以跨文件系统创建</li>
<li>可以对文件或者目录创建</li>
<li>可以对一个不存在的文件或者目录创建</li>
</ul>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>最后说一下文件的类型主要有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d ：目录   </span><br><span class="line">- ：文件   </span><br><span class="line">l ：链接   </span><br><span class="line">s ：socket   </span><br><span class="line">p ：named pipe   </span><br><span class="line">b ：block device   </span><br><span class="line">c  ：character device  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 系统下远程连接和远程拷贝命令</title>
    <url>/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在平常开发部署中，我们可能经常需要远程连接到服务器上执行一些操作，有时还需要拷贝相应的文件过去，这里记录下平常自己用的比较多的远程连接命令以及远程拷贝文件的命令。</p>
<a id="more"></a>
<h3 id="远程连接-ssh-命令"><a href="#远程连接-ssh-命令" class="headerlink" title="远程连接 ssh 命令"></a>远程连接 ssh 命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh zhouxh@192.168.0.134</span><br></pre></td></tr></table></figure>
<p>上面是通过默认 22 端口连接，如果需要指定端口连接，加上 -p 参数指定相应端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 33109 zhouxh@192.168.0.134</span><br></pre></td></tr></table></figure>

<h3 id="远程拷贝-scp-命令"><a href="#远程拷贝-scp-命令" class="headerlink" title="远程拷贝 scp 命令"></a>远程拷贝 scp 命令</h3><p>将本地文件 file1 拷贝到另一台主机用户名为 zhouxh 的家目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp &#x2F;home&#x2F;zhouxh&#x2F;file1 zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;</span><br></pre></td></tr></table></figure>
<p>将本地目录 dir1 拷贝到另一台主机用户名为 zhouxh 的家目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r &#x2F;home&#x2F;zhouxh&#x2F;dir1 zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;</span><br></pre></td></tr></table></figure>
<p>将另一台主机用户名为 zhouxh 的家目录下的文件 file1 拷贝到本地家目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;file1 &#x2F;home&#x2F;zhouxh&#x2F;</span><br></pre></td></tr></table></figure>
<p>将另一台主机用户名为 zhouxh 的家目录下的 dir1 目录拷贝到本地家目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;dir1 &#x2F;home&#x2F;</span><br></pre></td></tr></table></figure>
<p>以上拷贝命令都是通过默认 22 端口拷贝，如果需要指定端口，加上 -P 参数，注意 P 大写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -P 33109 &#x2F;home&#x2F;zhouxh&#x2F;file1 zhouxh@192.168.0.134:&#x2F;home&#x2F;zhouxh&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet 3.0 引入对异步处理的支持</title>
    <url>/Servlet-3-0-%E5%BC%95%E5%85%A5%E5%AF%B9%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%9A%84%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>前面我们说了很多关于异步接口的实现，而且看的都是 SpringMVC 包装了一层的之后的实现，现在让我们抛开 SpringMVC 那一层包装再看看是怎样的。</p>
<p>好了，我们先看下没有了 SpringMVC 包装的异步实现代码：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;asyncServlet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncServlet</span><span class="params">(HttpServletRequest servletRequest)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;========== received async servlet endpoint request&quot;</span>);</span><br><span class="line">    AsyncContext asyncContext = servletRequest.startAsync();</span><br><span class="line">    asyncContext.setTimeout(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">this</span>.executorService.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String result = <span class="keyword">this</span>.taskService.execute();</span><br><span class="line">            asyncContext.getResponse().getWriter().println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().println(e.getCause());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioException) &#123;</span><br><span class="line">                ioException.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">&quot;========== the servlet thread that received the request has been released&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中其实主要是看从接收到请求，servletRequest 调用 startAsync 方法得到 asyncContext 实例，然后在业务线程池中调用 service 层的方法执行得到结果，再通过 asyncContext 拿到 response 将结果写入响应，最后在 finally 代码块里面执行 complete 方法，整个请求结束。</p>
<p><img src="/images/async_request_response.png" alt="async_request_response"></p>
<p>整个执行顺序如下：</p>
<ol>
<li>客户端发送请求</li>
<li>servlet 容器分配一个线程处理请求</li>
<li>servlet request 调用 startAsync，得到 asyncContext</li>
<li>容器线程退出，但 response 保持打开</li>
<li>业务线程使用 asyncContext 来完成响应</li>
<li>客户端收到请求响应</li>
</ol>
<p>上面能够实现异步的前提是 servlet 引入了对异步的支持，对异步处理的支持是在 servlet 3.0 之后 引入的，其实也已经很久了，之前都不知道这个特性，主要是我们平常一个请求从头到尾由同一个线程来处理的这种线程模型基本上就能满足大部分的需求了。</p>
<p>上面的执行效果和之前的返回结果是 Callable，DeferredResult 大体上是一样的，只不过 SpringMVC 帮我们包装了，根据接口的返回值来决定是否开启异步请求，不需要自己处理响应信息，同时也让我们更方便的实现我们的业务代码而已，但其实底层同样也是通过 servletRequest 拿到 asyncContext 来实现的，我之前的文章中在截图中其实也标记了一下，不过当时没提，主要是想单独用一篇文章来说明。</p>
<p>再回到上面那张图，可以看到异步的实现不可避免的会涉及到线程间频繁的切换上下文，但是如果这样也带来了其他的好处，比如说可以处理的并发连接数更多，请求的处理和业务的处理分开，同时可以自定义业务线程池，更好地监控执行状况。</p>
<p>最后我还想说一下在使用这个异步特性的过程中需要注意的一些地方：</p>
<ol>
<li>首先由于并不是像普通的一个请求一个线程处理直到结束，所以 ThreadLocal 保存的信息并不能在业务线程中获取。</li>
<li>如果实现了自己的 Filter，记得一定加上 asyncSupported=true，否则会报错</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(filterName = &quot;normalFilter&quot;, urlPatterns = &quot;/*&quot;, asyncSupported = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupportedAsyncFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如果需要实现拦截器，可以实现 AsyncHandlerInterceptor 接口，里面 afterConcurrentHandlingStarted 方法在异步线程执行前会回调。</li>
<li>实现 AsyncHandlerInterceptor 接口，接口中 preHandle 会执行两次，要注意实现业务逻辑幂等性。</li>
</ol>
<p>文中代码地址：<br><a href="https://github.com/rookiedev-z/sample/tree/master/async-controller-sample">https://github.com/rookiedev-z/sample/tree/master/async-controller-sample</a></p>
<p>参考：<br><a href="https://docs.oracle.com/javaee/7/tutorial/servlets012.htm">https://docs.oracle.com/javaee/7/tutorial/servlets012.htm</a><br><a href="https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support">https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 下 MySQL 安装以及配置远程可访问</title>
    <url>/Ubuntu-%E4%B8%8B-MySQL-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%8F%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h3 id="Ubuntu-安装-MySQL"><a href="#Ubuntu-安装-MySQL" class="headerlink" title="Ubuntu 安装 MySQL###"></a>Ubuntu 安装 MySQL###</h3><p>最好先执行一次更新操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后执行以下三条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get isntall mysql-client</span><br><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<p>安装成功后可以通过下面的命令测试是否安装成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure>

<p>出现如下信息证明 MySQL 安装成功：<br>​<img src="/images/mysql.png" alt="mysqld.cnf 文件"></p>
<p>对于 Ubuntu 系统下安装 MySQL 后一般都不支持远程连接，只能通过 localhost 或者 127.0.0.1 进行连接，因此需要我们自己去配置，这里介绍两种方式：</p>
<h3 id="创建一个新的访问用户，配置该用户可以远程访问。-推荐使用这种方式"><a href="#创建一个新的访问用户，配置该用户可以远程访问。-推荐使用这种方式" class="headerlink" title="创建一个新的访问用户，配置该用户可以远程访问。(推荐使用这种方式)"></a>创建一个新的访问用户，配置该用户可以远程访问。(推荐使用这种方式)</h3><p>(1) 在安装好了 MySQL 数据库之后，由于 MySQL 数据库安装好之后出于安全考虑默认就是只允许通过本机访问，即只能通过 127.0.0.1 或者 localhost 去访问，所以首先需要修改 MySQL 的配置文件，在 Ubuntu 系统下, MySQL 的配置文件在路径 /etc/mysql/mysql.conf.d/ 下,找到该路径下的 mysqld.cnf 文件打开找到如下位置:<br>​<img src="/images/mysqld.cnf.png" alt="mysqld.cnf 文件"></p>
<p>红色标注部分这里就是 MySQL 默认只能由本机访问，我们将其注释掉。注释之后最好将服务重启，之后再进行创建用户以及赋予相应权限的操作。</p>
<p>(2) 在本机使用 root 用户登录到 MySQL 数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>回车后输入密码登录。<br>(3) 创建用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user username identified by &#39;password&#39;; </span><br></pre></td></tr></table></figure>

<p>username 是你要创建的用户名，password 为密码。</p>
<p>(4) 给创建的用户添加权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to &#39;username&#39;@&#39;%&#39; identified by &#39;password&#39; with grant option;</span><br></pre></td></tr></table></figure>

<p>上面的 all 代表接受所有操作，比如 select,insert,delete….;  <em>.</em> 代表所有数据库下面的所有表，也就是所有权限;而 % 代表这个用户允许从任何地方登录；为了安全期间，这个 % 可以替换为你允许的 ip 地址。username  表示你要赋予权限的用户名，password 表示该用户名对应的密码。</p>
<p>(5) 修改后刷新权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>(6) 执行完上面的操作后，输入 quit 命令退出数据库将 MySQL 服务重启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>

<p>(7) 重启之后用刚才创建好的用户并且使用本机的 IP 地址进行测试，输入如下命令登录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h 192.168.0.161 -u username -p</span><br></pre></td></tr></table></figure>

<p>192.168.0.161 表示 MySQL 服务所在机器的 IP 地址，username 为刚才新创建的用户名，回车后输入密码，再回车登录成功表示配置已经生效了。否则需要再检查一遍其他哪里没有配置好。</p>
<h3 id="修改当前-root-用户的配置，使该用户可以远程访问"><a href="#修改当前-root-用户的配置，使该用户可以远程访问" class="headerlink" title="修改当前 root 用户的配置，使该用户可以远程访问"></a>修改当前 root 用户的配置，使该用户可以远程访问</h3><p>同样的先执行第一种方式中步骤一和步骤二，然后执行以下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39; with grant option;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>之后将 MySQL 服务重启，重启之后用 root 用户通过 IP 地址登录测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h 192.168.0.161 -u root -p</span><br></pre></td></tr></table></figure>
<p>两种方式本质是一样的，只不过第二种更省事，直接在已有的 root 用户上进行更改，但这样不是很安全，所以推荐第一种方式，配置权限时可以指定一些权限，也可以指定 IP 地址可远程访问。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 执行命令时报错 unable to resolve host</title>
    <url>/Ubuntu-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%97%B6%E6%8A%A5%E9%94%99-unable-to-resolve-host/</url>
    <content><![CDATA[<h2 id="记录一下今天遇到的一个问题"><a href="#记录一下今天遇到的一个问题" class="headerlink" title="记录一下今天遇到的一个问题"></a>记录一下今天遇到的一个问题</h2><p>今天在阿里云服务器上部署应用时遇到一个小问题，每次执行完 sudo 命令都会出现一行错误信息，刚开始还以为执行命令出错了，但仔细一看不像是执行命令的报错信息，而且还发现命令其实已经执行成功了。</p>
<a id="more"></a>

<p>执行命令之后的报错信息如下：</p>
<p><img src="/images/resolve-host3.png" alt="hosts 文件"></p>
<p>于是去百度了一波，发现原来是**<em>因为 /etc/ 路径下 hosts 文件中的主机名和 hostname 文件中的主机名不一致**</em>所导致的错误。</p>
<p>经查看 hostname 文件中的主机名如下：</p>
<p><img src="/images/resolve-host5.png" alt="hosts 文件"></p>
<p>知道原因了之后就知道如何解决了，方式如下:</p>
<p>在 /etc/ 路径下 hosts 文件中添加一行，将 /etc/ 路径下 hostname 文件中的主机名称拷贝过来即可，hosts 文件修改之后如下：</p>
<p><img src="/images/resolve-host4.png" alt="hosts 文件"></p>
<p>以下则分别是我电脑上 /etc 路径下 hosts 文件和 hostname 文件中的内容</p>
<p><img src="/images/resolve-host.png" alt="hosts 文件"></p>
<p><img src="/images/resolve-host2.png" alt="hostname 文件"></p>
<p>比如上面我电脑上 hostname 文件中内容是 zhouoxh-X550VC ，只要在 hosts 文件中添加一行 127.0.1.1       zhouxh-X550VC，如果不加这一行执行 sudo 命令就会报错。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu 系统安装以及一些开发中必要的安装配置</title>
    <url>/Ubuntu-%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BF%85%E8%A6%81%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>对于开发人员来说，个人强烈推荐使用 Linux 系统进行开发，至于为什么，这里贴出自己刚开始尝试使用 Linux 系统时看的一个博主写的文章，可以说就是因为看了这位博主的文章才立即决定装上 Linux 系统，开始了我的 Linux 系统之旅，从此停不下来了。下面就是这位博主写的文章地址，里面详细阐述了为什么要使用 Linux 系统。</p>
<a id="more"></a>

<p><a href="http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/">http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/</a><br><a href="http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/">Ubuntu桌面生存指南 (1) — 选择 Linux</a></p>
<p>这位博主写了 5 篇文章关于 Linux 系统的，建议从第一篇开始看，一直看下去，看完之后如果还是不想进入 Linux 系统的世界，那么可能 Linux 系统与你无缘，这里并无冒犯的意思，纯属个人喜好。</p>
<p>博主从零开始全面的介绍了 Linux 系统，（当然还是要有点 Linux 系统的基础去看更好）一直到 Linux 系统的安装以及后面的维护和备份，值得去好好的看一遍，那么这里我主要是想记录下自己的安装过程以及开发中的一些必要软件安装和配置，以防以后重复去搜索资源。</p>
<h3 id="Ubuntu-系统的安装"><a href="#Ubuntu-系统的安装" class="headerlink" title="Ubuntu 系统的安装"></a>Ubuntu 系统的安装</h3><p>U 盘启动盘制作<br>对于 Linux 系统的启动盘制作很简单，只需要下载一个制作工具即可，下载链接如下：</p>
<p><a href="http://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/#button">U 盘启动盘制作软件</a></p>
<p><img src="/images/download.png" alt="制作工具下载网页"></p>
<p>下载完制作工具后，准备好 Linux 系统镜像文件，以 Ubuntu 镜像为例，最好去官网下载最新的，而且带有 LTS 结尾的 ISO 文件，下载好以后打开刚才下载的制作软件</p>
<p><img src="/images/make-usb.jpg" alt="制作工具使用"></p>
<p>图中三处标红的地方从上到下分别是制作的启动盘要安装的镜像类型，准备好的镜像文件位置，要制作的 U 盘。这里提醒记得备份 U 盘里面的重要资料，制作完成之后会全部格式化。选择好之后点击 create 按钮，等个十来分钟应该就会出现如下字样了。</p>
<p><img src="/images/success.jpg" alt="制作成功"></p>
<p>到这里 U 盘启动盘就已经制作好了，接下来就是插入你要安装系统的笔记本或者台式机上，设置好从 U 盘启动，进入系统后出现以下界面(有的版本不一样可能不会立马进入这个界面，会直接进入安装界面，可以点击旁边的 Try Ubuntu 按钮来进入这个界面，直接安装可能会出问题)</p>
<p><img src="/images/install.png" alt="Ubuntu 系统安装"></p>
<p>在从这里点击进入安装界面，接下来就是按照指示进行操作即可，实在不懂的可以百度找一下具体的安装步骤，中间分区的步骤尽量自己来进行分区，具体的分区方案以下供参考：</p>
<p>一般来说一个 Ubuntu 的系统在安装之初应该有三个分区，他们分别是挂载于根目录： /, home 目录： /home 的两个分区以及 swap 分区。swap 分区是指虚拟内存的交换区，一般设置为实际内存容量的两倍大小即可。<br>假如有一台 8G 内存，1T 磁盘的笔记本电脑，swap: 15G  15360M，/:  100G  102400M<br>/boot:    20G     20480M，/home:   剩余空间都分给 home</p>
<p><a href="https://blog.csdn.net/u012052268/article/details/77145427">安装 Ubuntu Linux 系统时硬盘分区最合理的方法</a><br><a href="https://blog.csdn.net/zzxian/article/details/25487951">win7 下制作 Ubuntu 系统安装启动盘和 U 盘安装 Ubuntu 全过程</a></p>
<h3 id="Ubuntu-系统软件源配置"><a href="#Ubuntu-系统软件源配置" class="headerlink" title="Ubuntu 系统软件源配置"></a>Ubuntu 系统软件源配置</h3><p>到这里 Ubuntu 系统应该安装完成了，接下来就可以配置日常开发中需要的工具软件了<br>软件源配置：Ctrl + Alt + T 快捷键打开终端命令行，输入 update-manager 回车打开软件更新器，这时可能会提示检查更新，可以选择稍后提醒，</p>
<h3 id="Ubuntu-系统软件后台启动"><a href="#Ubuntu-系统软件后台启动" class="headerlink" title="Ubuntu 系统软件后台启动"></a>Ubuntu 系统软件后台启动</h3><p>在 Ubuntu 系统的终端运行软件会将终端占据，这样你不得不重新启动一个终端来执行命令，这里有一个脚本配置软件从后台启动，不会占据终端。在 home 目录下创建 bin目录，然后在 bin 目录下新建一个文本文件，命名 x ，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">&quot;$@&quot; 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>并且给这个脚本文件添加可执行权限，这个脚本的大意是运行软件的时候，不输出任何标准信息和错误信息，并且在后台运行，这样就可以避免占据终端的行为。比如启动火狐浏览器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x Firefox</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-系统-vi-编辑器配置"><a href="#Ubuntu-系统-vi-编辑器配置" class="headerlink" title="Ubuntu 系统 vi 编辑器配置"></a>Ubuntu 系统 vi 编辑器配置</h3><p>在终端中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ set -o vi</span><br></pre></td></tr></table></figure>

<p>可以开启以兼容 vi 的快捷键操作 bash 命令，此时你可以在终端使用 Esc 切换到命令模式，在命令模式下，按 h，l 可以左右移动光标，按 j，k 可以切换前一条后一条命令。x可以修改字符，”$， ^”可以返回命令尾部或头部，i 可以返回编辑模式。Vi/Vim 本身不需要安装，但是如果你更乐衷于视觉效果更好，功能更丰富的 GUI 版本可以安装GVim:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure>
<p>执行以下命令进入 vi 编辑器训练教程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimtutor</span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-系统终端分屏工具-Tmux"><a href="#Ubuntu-系统终端分屏工具-Tmux" class="headerlink" title="Ubuntu 系统终端分屏工具 Tmux"></a>Ubuntu 系统终端分屏工具 Tmux</h3><p> 运行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<p>安装过程中如果遇到由于包依赖问题导致安装失败的话，可以尝试下面命令进行修复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get -f install</span><br></pre></td></tr></table></figure>

<p>个性化配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">rm -rf .tmux</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gpakosz&#x2F;.tmux.git</span><br><span class="line">ln -s .tmux&#x2F;.tmux.conf</span><br><span class="line">cp .tmux&#x2F;.tmux.conf.local .</span><br></pre></td></tr></table></figure>
<p>相关链接：<br><a href="https://blog.csdn.net/u014015972/article/details/51611817">tmux 的使用</a><br><a href="http://blog.jobbole.com/87584/">Tmux 速成教程：技巧和调整</a><br><a href="http://www.cnblogs.com/chjbbs/p/5689011.html">tmux的使用方法和个性化配置</a></p>
<h3 id="Ubuntu-系统安装-Chrome-浏览器"><a href="#Ubuntu-系统安装-Chrome-浏览器" class="headerlink" title="Ubuntu 系统安装 Chrome 浏览器"></a>Ubuntu 系统安装 Chrome 浏览器</h3><p>在终端中，执行以下四条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget http:&#x2F;&#x2F;www.linuxidc.com&#x2F;files&#x2F;repo&#x2F;google-chrome.list -P &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;</span><br><span class="line">wget -q -O - https:&#x2F;&#x2F;dl.google.com&#x2F;linux&#x2F;linux_signing_key.pub | sudo apt-key add -</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu-系统安装-JDK"><a href="#Ubuntu-系统安装-JDK" class="headerlink" title="Ubuntu 系统安装 JDK"></a>Ubuntu 系统安装 JDK</h3><p>去官网下载 Ubuntu 系统的 JDK 开发工具压缩包，解压到某个文件夹中，然后配置环境变量，以下是我电脑上的一些环境变量配置，我这里是配置在 /etc/profile 文件中的，对所有用户有效：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jdk1.8.0_144</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export ZOO_HOME&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.11</span><br><span class="line">export M2_HOME&#x3D;&#x2F;opt&#x2F;maven&#x2F;apache-maven-3.5.0</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;M2_HOME&#125;&#x2F;bin:$&#123;ZOO_HOME&#125;&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;curl&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>
<p>配置好后要想环境变量立即生效可以执行以下命令,或者重启生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu-系统安装截图工具-deepin-scrot-并且配置快捷键"><a href="#Ubuntu-系统安装截图工具-deepin-scrot-并且配置快捷键" class="headerlink" title="Ubuntu 系统安装截图工具 deepin-scrot 并且配置快捷键###"></a>Ubuntu 系统安装截图工具 deepin-scrot 并且配置快捷键###</h3><p>执行以下命令下载截图工具：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;packages.linuxdeepin.com&#x2F;deepin&#x2F;pool&#x2F;main&#x2F;d&#x2F;deepin-scrot&#x2F;deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure>
<p>截图工具安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-xlib</span><br><span class="line">sudo dpkg -i deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure>
<p>当安装失败时可能是由于依赖问题，执行下面命令进行修复之后继续安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get -f install</span><br><span class="line">sudo dpkg -i deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure>
<p>deepin-scrot 截图快捷键设置：<br><img src="/images/deepin-scrot-key.png" alt="截图快捷键设置"></p>
<p>xkill 快捷键配置， 关闭无响应的程序：<br><img src="/images/xkill-key.png" alt="xkill 快捷键设置"></p>
<p>返回桌面快键键配置，换回 window 系统下熟悉的 super + d 快捷键：<br><img src="/images/super-d.png" alt="返回桌面快捷键设置"></p>
<p>可能有时返回桌面的快捷键配置后还是没用，super + d 无法返回到桌面，这时需要做以下设置：<br>首先安装 compizconfig-settings-manager：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install compizconfig-settings-manager</span><br></pre></td></tr></table></figure>

<p>然后在终端输入 compizconfig-settings-manager 命令打开该软件，找到 Ubuntu Unity plugin，General 里面有个 Show Desktop，设置一下相应快捷键就可以了。</p>
<h3 id="Ubuntu-系统微信、QQ、Listen-安装"><a href="#Ubuntu-系统微信、QQ、Listen-安装" class="headerlink" title="Ubuntu 系统微信、QQ、Listen 安装###"></a>Ubuntu 系统微信、QQ、Listen 安装###</h3><p>微信安装参考 GitHub 上面的一个项目，里面有已经发布好了的，直接下载解压后即可使用，链接如下：</p>
<p><a href="https://github.com/geeeeeeeeek/electronic-wechat/releases">GitHub 微信项目链接</a></p>
<p>QQ 安装参考下面博主写的教程：</p>
<p><a href="https://blog.csdn.net/ysy950803/article/details/80215101">Ubuntu 18.04安装最新版QQ（9.0）</a><br><a href="https://blog.csdn.net/qq_36428171/article/details/78244730">在ubuntu17.04下安装最新版QQ教程</a></p>
<p>Listen 是一款听音乐的 App，集成了网易，虾米，QQ 音乐，你想听的里面基本上能够搜到，而且界面也很符合我们开发者的风格，可以说很良心了，网站链接：</p>
<p><a href="http://listen1.github.io/listen1/">Listen 网站链接</a><br>打开该网站下载 Linux 版本即可，他还有浏览器插件版，不想安装的话也可以直接下载浏览器插件版。</p>
<p>最后如果必须要用到 Windows 系统下面的软件的话，那就只能推荐一款软件给你了：Virtual Box 安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install virtualbox</span><br><span class="line">sudo apt-get install virtualbox-guest-additions</span><br><span class="line">sudo apt-get install virtualbox-guest-additions-iso</span><br></pre></td></tr></table></figure>
<p>使 Virtualbox 辨认出物理 USB 外设</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gnome-system-tools</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>change buffer 的理解以及唯一索引的选择</title>
    <url>/change-buffer-%E7%9A%84%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h4 id="change-buffer-介绍"><a href="#change-buffer-介绍" class="headerlink" title="change buffer 介绍"></a>change buffer 介绍</h4><p>在介绍 change buffer 之前，先来看一个 SQL 的执行时涉及索引树的更新过程，比如下面的这个插入语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into users(id, identity) values(1, 4504);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>上面的 SQL 很简单，就是将 id = 1，identity = 4504 数据插入到 users 表里面，这里先声明下 users 表 identity 字段上建有普通索引，id 是主键字段。</p>
<p>在之前的文章 &lt;深入理解 MySQL 索引(一) &gt; 中已经提到，InnoDB 使用的是 B+ 树索引模型，数据都是存储在 B+ 树中的，表的每一个索引在 InnoDB 里面都对应于一棵 B+ 树，B+ 树的节点存储在数据页当中，一个页里面可以存放很多行数据。</p>
<p>如果不考虑现有的执行流程，我们来看插入这条数据时更新 identity 索引树的过程应该是怎样的，这里假设 identity = 4504 要存放的数据页 Page1 不在内存里面，简单的来说 identity 索引树的更新需要经历下面三个步骤：</p>
<p>1.从磁盘上读取出 identity = 4504 将要存放的数据页 Page1 到内存</p>
<p>2.将 identity = 4504，id = 1 的数据存放到相应的数据页 Page1上(内存操作)</p>
<p>3.将内存中更新之后的数据页 Page1 写回到磁盘上</p>
<p>上面三个步骤其中 1 和 3 是比较耗时的，涉及到从磁盘中随机读数据和随机写数据到磁盘，而步骤 2 是在内存中的操作，耗时基本可以忽略不计。既然上面提到不考虑 MySQL 现有的执行流程，那实际情况肯定不是这样的，对于步骤 3，在前面的文章 &lt;CRUD 也可以更进一步——更新语句&gt;里面介绍了 redo log，更新数据前先记录 redo log，再将数据写入内存，redo log 是顺序写，可以节省步骤 3 中随机写的时间，同时还能做到崩溃恢复的功能。</p>
<p>那就还剩步骤一里面的随机读，这时候 change buffer 就派上用场了，当要更新的数据页不在内存里面的时候(在内存中的时候直接更新内存，不需要用到 change buffer)，可以直接将步骤二的操作记录在 change buffer 里面，然后记录 redo log 后直接返回。整个数据更新的流程就变成下面这样：</p>
<p>1.直接在 change buffer 记录对数据页 Page1 更新</p>
<p>2.将步骤 1 的操作记录 redo log</p>
<p>优化之后就只剩下步骤 1 的内存操作和步骤 2 里面的顺序写磁盘操作了，相比上面三个步骤执行时间明显减少。</p>
<p>从上面前后流程对比可以看到，change buffer 是在要更新的数据页不在内存里面时，直接将对数据页的修改记录在 change buffer 里面，而不需要从磁盘上读取数据页进行修改后再写入磁盘，减少了随机读取和写磁盘的时间，同时由于没有将数据页读入内存，也间接提高了内存的利用率。</p>
<p>需要注意的是 change buffer 里面的数据页修改记录并不只是存放在内存里面，它也是需要写到磁盘上的，只不过是在后台异步写到磁盘上，同样的对 change buffer 的操作也会记录 redo log，由于记录了 redo log，因此不需要担心数据页修改丢失的问题。</p>
<p>上面将对数据行的修改记录放在 change buffer 里面，而没有从磁盘上读取这部分数据做修改，并不是说就不去做随机读写的操作了，最终数据肯定都是要写到磁盘上的，只不过将这两个耗时的操作放到后台异步去执行，后台会有定时任务去执行这两个操作。还有一种情况是定时任务还没执行前就需要访问这一数据页时，这时会先将数据页读取到内存，然后应用 change buffer 中和这个数据页有关的修改记录，再将应用之后的数据返回，这样就能保证返回的是修改之后的数据。</p>
<p>将原有数据页应用 change buffer 里面的修改记录的这一过程称为 merge 的过程，总的来说触发 merge 的过程有下面几种情况:</p>
<p>1.定时任务执行前访问的数据页有变动，先将数据页读取到内存，然后应用 change buffer</p>
<p>2.后台定时任务定时执行</p>
<p>3.数据库正常关闭的过程</p>
<p>4.数据库异常关闭后再启动，通过 redo log 恢复数据时也可能会产生 merge 的操作</p>
<h4 id="change-buffer-和-redo-log-的对比"><a href="#change-buffer-和-redo-log-的对比" class="headerlink" title="change buffer 和 redo log 的对比"></a>change buffer 和 redo log 的对比</h4><p>1.redo log 优化的是更新数据页后随机写磁盘的过程，将随机写转变为顺序写，而 change buffer 优化的则是随机读磁盘的过程，直接将对数据页的修改放在 change buffer 里面，把随机读磁盘的操作从更新的流程里面省去了，使得更新语句的执行速度得到明显提升。</p>
<p>2.change buffer 里面的数据页修改记录并不只是存放在内存里面，它会被写到磁盘上，并且将对数据页的修改放在 change buffer 里面的这一动作需要记录 redo log，由于记录了 redo log，因此没有数据修改丢失的问题。</p>
<p>3.使用到 change buffer 时，真正对磁盘数据页的修改每次都是将磁盘上的数据页读取到内存，然后应用 change buffer 的修改，再将内存中更新后的数据页回写到磁盘上，而不是根据 redo log 来完成的。</p>
<p>4.redo log 里面包含了两种日志记录，一种是普通数据页的修改，也就是读取到内存里面的数据页变动，还有一种就是我们这里提到的对 change buffer 里面的操作，使用到 change buffer 说明数据页不在内存里面，因此不存在内存里面的数据页变动，只是在 change buffer 里面记录了一下数据页的变动而已，后续将 change buffer 里面记录的数据页变动应用到磁盘数据页上时，会将磁盘上的数据页读取到内存，然后在内存里面应用 change buffer 里面的修改，这一步会再次记录 redo log，这时记录就是第一种。</p>
<h4 id="change-buffer-的局限性"><a href="#change-buffer-的局限性" class="headerlink" title="change buffer 的局限性"></a>change buffer 的局限性</h4><p>从上面 change buffer 的介绍来看，change buffer 的确大大提高了数据的更新速度，但也并不是任何时候都能使用 change buffer，比如说下面这些场景就没有办法使用，或者说没必要使用 change buffer。</p>
<p>1.要更新的数据行所在数据页本身就在内存里面，这时就没必要使用 change buffer 了，直接将内存里面的数据页修改即可</p>
<p>2.要更新的索引字段也是 where 后面的条件字段，这时也不需要使用 change buffer，因为 where 后面的条件字段本身就要将数据页读取到内存来判断是否符合条件，这时都已经读取出来了，更新的时候直接更新内存就可以</p>
<p>3.更新后的数据页紧接着就需要进行查询，这时也没有必要去使用 change buffer，因为在你更新之后立马查询，这时需要去读取磁盘上的数据页，然后应用 change buffer 里面的修改再返回，还不如在更新时将数据页读取到内存进行修改，紧接着的查询就可以直接将内存更新后的数据返回即可，因此一般对于那种写多读少的数据就很适合使用 change buffer，比如说日志数据</p>
<p>4.要更新的索引字段是唯一索引，这时也不适用，具体原因在看完下面的内容之后就知道了</p>
<h4 id="唯一索引和普通索引的区别"><a href="#唯一索引和普通索引的区别" class="headerlink" title="唯一索引和普通索引的区别"></a>唯一索引和普通索引的区别</h4><p>对于唯一索引和普通索引，它们两者有什么区别呢，可能我们会说唯一索引表明该字段是全局唯一的，而普通索引则没有这个要求，当然这么说肯定没错，但这则是表面上的区别，唯一索引字段全局唯一这个特性相对普通索引会给查询和更新带来哪些变化呢。</p>
<h4 id="查询时的区别"><a href="#查询时的区别" class="headerlink" title="查询时的区别"></a>查询时的区别</h4><p>首先我们来看针对唯一索引和普通索引查询时的区别，比如下面这个 SQL 语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id, identity from users where identity &#x3D; 4504;</span><br></pre></td></tr></table></figure>

<p>上面的 SQL 查询 users 表里面 identity = 4504 的记录，假设 identity 字段上建立的是普通索引，并且当前 identity 字段上的索引树结构如下:</p>
<p>在  &lt;深入理解 MySQL 索引(二)&gt; 文章中我们已经提到了索引字段的查询方式，查询过程是下面这样的:</p>
<p>1.通过 idx_identity 索引树定位到第三个叶子节点</p>
<p>2.将第三个叶子节点所在数据页读取到内存，取出第一个值 4504，判断满足条件取出主键 id = 4(这里因为只需要查询 id 和 identity 字段的值，所以不存在回表的过程)</p>
<p>3.接着再取下一个值 4505，大于 4504 不满足条件，查询结束返回</p>
<p>上面是 identity 字段为普通索引的查询过程，而如果是唯一索引，则是在上面步骤 2 取出第一个值 4504 判断满足条件取出 id = 4 之后直接查询结束返回，而不会执行步骤 3，这是普通索引和唯一索引在查询时的区别。</p>
<h4 id="更新时的区别"><a href="#更新时的区别" class="headerlink" title="更新时的区别"></a>更新时的区别</h4><p>再来看数据更新时的区别，比如下面这个更新语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update users set identity &#x3D; 4504 where id &#x3D; 3;</span><br></pre></td></tr></table></figure>

<p>上面 SQL 将 users 表中 id = 3 的记录 identity 字段更新成 4504，这个 SQL 首先查询到 id = 3 的记录，除了将主键索引树叶子节点里面的 data 更新，还涉及到 identity 索引树的更新，需要将 identity 索引树上原来 id = 3 的 identity = 4503 更新成 4504(这里先不考虑索引树的页合并以及分裂过程)，假设原来 id = 3 的 identity = 4503 所在的数据页是在 Page3 上，结合上面提到的 change buffer，identity 索引树的更新过程如下:</p>
<p>第一种情况，数据页 Page3 当前已经在内存里面:</p>
<p>1.如果 identity 字段上建立的是普通索引，直接将内存里面 Page3 数据页上的 identity = 4503 更新成 4504</p>
<p>2.如果 identity 字段上建立的是唯一索引，则会先进行判断当前是否已经存在 identity = 4504 的记录，不存在则更新</p>
<p>第二种情况，数据页 Page3 当前不在内存里面:</p>
<p>1.如果 identity 字段上建立的是普通索引，直接在 change buffer 记录对数据页 Page3 更新后返回</p>
<p>2.如果 identity 字段上建立的是唯一索引，则会先将 Page3 数据页读入内存，判断当前是否已经存在 identity = 4504 的记录，不存在则更新</p>
<p>可以看到由于唯一索引字段全局唯一的特性，没有办法使用到 change buffer 的特性，因为使用到了 change buffer 根本不会去读取磁盘上的数据，也就无法确认磁盘上是否还存在其他 identity = 4504 的数据，直接记录数据页修改可能违反字段全局唯一的特性，这也就回答了我上面提到的如果要更新的索引字段是唯一索引，不适用 change buffer。</p>
<h4 id="唯一索引和普通索引如何选择"><a href="#唯一索引和普通索引如何选择" class="headerlink" title="唯一索引和普通索引如何选择"></a>唯一索引和普通索引如何选择</h4><p>在一个字段上可以建立普通索引也可以建立唯一索引的时候，我们该如何进行选择呢，看到这里或许你已经有了答案了，但还是有一些我们需要注意的地方。</p>
<p>首先如果一个字段上可以是普通索引也可以是唯一索引，说明这个字段我们在业务代码层面就已经能够保证不会插入相同值，否则我们肯定还是要建立唯一索引。</p>
<p>如果两者都可以的时候，使用普通索引在更新时可以利用到 change buffer，极大提高更新速度，但在查询方面其实都差不多，没有太大区别，参考上面提到的普通索引和唯一索引查询时的区别，无非就是多了一个步骤 3 的判断，这一判断大概率是内存中执行的，因为从磁盘上读取数据都是一页一页的读取，极端情况下下一个值刚好在下一个数据页，这时才可能会涉及到从磁盘上再读取一次数据的过程，但概率一般很小</p>
<p>还有一个要注意的是使用 change buffer 的局限性，如果我们的更新都紧伴随着对该数据的查询，那么这时候就没有必要去使用 change buffer 了，相反还需要关闭 change buffer，因此这种情况下选择唯一索引和普通索引也就没什么区别了。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>join 查询是如何执行的</title>
    <url>/join-%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<h4 id="join-联表查询的性能"><a href="#join-联表查询的性能" class="headerlink" title="join 联表查询的性能"></a>join 联表查询的性能</h4><p>有时候可能会听说尽量不要使用 join 联表查询，或者更直接一点就禁止使用 join 联表查询，这时如果我们要查询的数据分布在两张关联表中，就不得不先去一张表里面查出要查询的数据，然后再根据关联字段去另一张表里面查出数据，但你有想过从查询性能上来说，这样做的查询速度就一定比 join 联表查询速度要快吗？不妨来看一个具体的例子，下面是活动表和城市编码表的表结构，活动表里面的 city_code 对应于城市编码表中的 code 字段:</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table activities</span><br><span class="line">(</span><br><span class="line">    id bigint unsigned auto_increment comment &#39;主键&#39; primary key,</span><br><span class="line">    name varchar(255) default &#39;&#39; not null comment &#39;活动名称&#39;,</span><br><span class="line">    city_code varchar(64) default &#39;&#39; not null comment &#39;城市编码&#39;,</span><br><span class="line">    start_time timestamp default CURRENT_TIMESTAMP not null comment &#39;开始时间&#39;,</span><br><span class="line">    end_time timestamp default CURRENT_TIMESTAMP not null comment &#39;结束时间&#39;,</span><br><span class="line">    status tinyint unsigned default &#39;0&#39; not null comment &#39;状态:0-待启用,1-待生效,2-生效中,3-已结束,4-已禁用&#39;,</span><br><span class="line">    create_time timestamp default CURRENT_TIMESTAMP not null comment &#39;创建时间&#39;,</span><br><span class="line">    update_time timestamp default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment &#39;更新时间&#39;</span><br><span class="line">) comment &#39;活动表&#39; CHARSET&#x3D;utf8mb4;</span><br><span class="line">create index idx_city_code on activities(city_code);</span><br><span class="line">create index idx_create_time on activities (create_time);</span><br><span class="line">create index idx_end_time_start on activities (end_time, start_time);</span><br><span class="line"></span><br><span class="line">create table cities</span><br><span class="line">(</span><br><span class="line">    id bigint unsigned auto_increment comment &#39;主键&#39; primary key,</span><br><span class="line">    name varchar(255) default &#39;&#39; comment &#39;城市名称&#39;,</span><br><span class="line">    code varchar(64) default &#39;&#39; not null comment &#39;城市编码&#39;</span><br><span class="line">) comment &#39;城市编码表&#39;;</span><br><span class="line">create index idx_name on cities(name);</span><br><span class="line">create unique index uk_code on cities (code);</span><br></pre></td></tr></table></figure>

<p>现在如果要查询出活动的基本信息，包含城市名称，这时候就有两种方法，一种是先从活动表查出 city_code 列的值，然后用 city_code 列的值去 cities 表中查询，还一种就是直接 join 联表查询，先来看第一种，首先去查 activities 表，得到结果之后将 city_code 列字段提取出来组装成 list，再去 cities 表里面做 in 查询，对应 SQL 分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from activities;</span><br><span class="line">select * from cities where code in (cityCodeList);</span><br></pre></td></tr></table></figure>

<p>上面 activities 表中有 1000 条数据，cities 表里面有 3525 条数据，正常来说上面两个 SQL 其实都不算耗时操作，第一个仅仅是全表扫描 1000 行，第二个则是通过索引树所搜索 1000 行，加起来也就是扫描 2000 行，然后就是需要和 MySQL 服务建立两次连接</p>
<p>接下来再来看另一种直接进行 join 联表查，通过城市编码字段进行关联查询，对应 SQL explain 结果如下：</p>
<p><img src="/images/image-20220514151259765.png" alt="image-20220514151259765"></p>
<p>从 explain 结果来看，对表 t1 采取的是全表扫描，扫描 1000 行，表 t2 采取的是等值索引查询，整体的执行流程是这样的:</p>
<p>1.先从 activities 表里面读出一行数据，提取出 city_code 字段的值</p>
<p>2.然后去 cities 表中对 code 字段进行索引树搜索，找到了则保存到结果里面</p>
<p>3.继续重复步骤 1，2，直到 activities 表中的数据都读取完毕</p>
<p>其实也就是遍历 activities 表，对每一条数据都去 cities 表里面查询，同样也是扫描 activities 表 1000 行，然后循环 1000 次去 cities 表里面搜索，加起来也是扫描 2000 行，同时只需要建立一次连接，但如果采用第一种方式的话，在 activities 表数据量更多的情况下还需要在业务代码里面进行分段 in 查询，这么看来使用 join 查询反而会更好一些。</p>
<h4 id="join-查询的执行流程"><a href="#join-查询的执行流程" class="headerlink" title="join 查询的执行流程"></a>join 查询的执行流程</h4><p>既然使用 join 联表反而会更好一些，那什么情况下我们不能使用 join 查询呢，如果你仔细看的话，上面参与 join 联表查询的字段无论是 activities 表里面的 city_code 还是 cities 表里面的 code 字段，这两个字段上其实都是建有索引的，如果我们把这两个字段上的索引都去掉会怎么样呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_city_code ON activities;</span><br><span class="line">DROP INDEX uk_code ON cities;</span><br></pre></td></tr></table></figure>

<p>执行完上面的删除索引的语句后，再来看使用 join 查询 explain 的结果:</p>
<p><img src="/images/image-20220514154214185.png" alt="image-20220514154214185"></p>
<p>从图中可以看到，这时无论 activities 表还是 cities 表都是全表扫描，暂时先不去看 t1 表 Extra 里面的信息的话，整体查询流程是这样的:<br>1.先从 activities 表里面读出一行数据，提取出 city_code 字段的值</p>
<p>2.然后去 cities 表中对 code 字段全表扫描，找到了则保存到结果里面</p>
<p>3.继续重复步骤 1，2，直到 activities 表中的数据都读取完毕</p>
<p>由于步骤二里面不再是索引搜索而是全表扫描，于是步骤二里面每次都要扫描 3525 行数据，对 cities 表的扫描行数就是 1000 * 3525 行，总的扫描行数就是 1000 + 1000 * 3525 行，相比有索引的情况下扫描行数直接提高了数倍，这时 join 查询也就不再有优势了。</p>
<p>这里还有两个问题需要注意，先说第一个问题，上面提到如果不去看 t1 表 Extra 里面的信息的话，执行流程是上面这样的，那 t1 表 Extra 里面的信息代表什么意思呢？你可以去看下之前的文章 &lt;Explain 使用解析一&gt;，里面描述了什么情况下会出现这种信息，其实就是当被驱动表的联表字段上没有索引的时候就会出现，这里的 Using join buffer (hash join) 是 MySQL 8.0 版本之后才会出现的，而我测试使用的正是 8.0 版本的 MySQL，如果是之前的版本的话，Extra 里面应该是 Using join buffer (Block Nested Loop)，我们分开来介绍这两种情况。</p>
<h4 id="Using-join-buffer-Block-Nested-Loop"><a href="#Using-join-buffer-Block-Nested-Loop" class="headerlink" title="Using join buffer (Block Nested Loop)"></a>Using join buffer (Block Nested Loop)</h4><p>上面我们说不去看 Extra 里面的信息执行的话，需要扫描的行数是 1000 * 3525，主要是由于步骤二里面去被驱动表里面查询的时候每次都是全表扫描，因此如果驱动表数据量为 M，被驱动表数据量为 N，总的扫描行数就是 M + M * N，如果这时两张表的数据量都是 10000，总的扫描行数就上亿了，这样的查询代价就太大了，因此 MySQL 进行了优化，首先将步骤一中驱动表查询得到的数据整个放入 join buffer 里面，然后扫描被驱动表，再和 join buffer 里面的数据进行对比，整体执行流程就变成下面这样：</p>
<p>1.全表扫描 activities，将查询得到的数据全部放入 join buffer 内存中，保存的是一个无序数组</p>
<p>2.全表扫描 cities，每扫描一行数据都去 join buffer 内存中遍历步骤一放入的 1000 条数据，判断是否满足 join 条件</p>
<p>这样的话，扫描行数就变成 1000+3525，然后就是多了步骤二里面 join buffer 内存中 3525 * 1000 次的判断，由于判断是在内存中进行的，因此速度并不算慢，执行效率对应的计算方式也由 M + M * N 变成 M+N 外加 M * N 次内存判断。</p>
<p>值得注意的是如果步骤一中驱动表中的数据太大，join buffer 内存不够的话怎么办呢？这时会采用**分段(block)**的方式存入 join buffer，若是采用的分段的方式，假设 join buffer 只能存储 100 条数据，执行流程如下：</p>
<p>1.全表扫描 activities，将查询得到的数据放入 join buffer 内存中，保存的是一个无序数组，到了 100 条的时候 join buffer 内存满了，执行下一步</p>
<p>2.全表扫描 cities，每扫描一行数据都去 join buffer 内存中遍历步骤一放入的 100 条数据，判断是否满足 join 条件</p>
<p>3.清空 join buffer，接着扫描 activities 表，将剩下 900 条里面的 100 条继续放入 join buffer，接着执行步骤二，直到驱动表的数据全部扫描完毕</p>
<p>采取分段的方式，扫描行数为 1000+1000/100 * 3525，内存中的判断次数依然是 3525 * 1000 次，扫描行数对应的计算方式为 M+M/buffer_size * N=M+(M * N)/buffer_size，执行效率对应就是 M+(M * N)/buffer_size 扫描行数外加 M * N 次内存判断。</p>
<h4 id="Using-join-buffer-hash-join"><a href="#Using-join-buffer-hash-join" class="headerlink" title="Using join buffer (hash join)"></a>Using join buffer (hash join)</h4><p>上面是 MySQL 8.0 之前的  Using join buffer (Block Nested Loop) 的执行过程，同样的如果两张表的数据量都是 10 万的话，那么就要在内存中进行 100 亿次的判断，尽管是在内存中进行判断，但执行 100 亿次的判断也是挺耗时的，于是 MySQL 8.0 做了进一步的优化。</p>
<p>上面由于步骤一里面将驱动表的数据放入 join buffer 内存时保存的是一个无序数组，所以步骤二每次和 join buffer 里面的数据对比都要循环遍历进行判断，但如果保存的是一个 hash 的结构，步骤二里面就只要将每一行数据都在 hash 里面进行一次查找定位就可以了，优化之后的执行流程如下：</p>
<p>1.全表扫描 activities，将查询得到的数据全部放入 join buffer 内存中，保存的是一个 hash 结构</p>
<p>2.全表扫描 cities，每扫描一行数据都去 join buffer 内存 hash 结构中查找一次，找到了则表示满足 join 条件</p>
<p>优化之后，扫描行数还是 1000+3525，但 3525 * 1000 次的判断变成了 3525 次查找，如果是两个大表，执行速度相比之前也会提高许多，执行效率对应就是 M+N 扫描行数外加 N 次hash 查找。</p>
<h4 id="为什么要用小表作为驱动表"><a href="#为什么要用小表作为驱动表" class="headerlink" title="为什么要用小表作为驱动表"></a>为什么要用小表作为驱动表</h4><p>接下来看第二个问题，同时如果你仔细看的话会发现，我故意将 SQL 语句中 join 表的顺序调换了，将 cities 表放在前面，从 SQL 语句看起来应该是 cities 作为驱动表，activities 表作为被驱动表才对，但从 explain 的执行结果来看，MySQL 没有按照我们书写的顺序来进行执行，因为 activities 表有 1000 条数据，cities 表有 3525 条数据，相对来说 activities 是小表作为驱动表，cities 是大表作为被驱动表，所以它是先去查询 activities 表，再去查 cities 表，从这一点也可以看出，我们无需可以调整我们的 SQL 语句中 join 表的前后顺序，MySQL 会自动调整，将小表作为驱动表，大表作为被驱动表，那为什么要使用小表作为驱动表呢。</p>
<p> 从执行效率来看的话，在被驱动表可以使用索引的情况下，执行效率是 M+N，没法用上索引的情况下如果是 Using join buffer (Block Nested Loop)，执行效率是 M + N 或者 M+(M * N)/buffer_size 外加 M * N 次内存判断，如果是 Using join buffer (hash join) 执行效率是 M+N 扫描行数外加 N 次内存 hash 查找，其中 M 表示驱动表的数据量，N 表示被驱动表的数据量，可以得出在不考虑内存中的判断和 hash 查找操作的话:</p>
<p>1.在有索引的情况下驱动表的 M 是全表扫描，被驱动表的 N 是索引搜索，固然 M 越小越好，应使用小表作为驱动表</p>
<p>2.没法用上索引(Block Nested Loop)并且 join buffer 内存足够的情况下，执行效率是 M+N，无论驱动表还是被驱动表哪个更小都是全表扫描，所以这种情况下就无所谓哪张表作为驱动表了</p>
<p>3.没法用上索引(Block Nested Loop)并且 join buffer 内存不够需要分段的情况下，执行效率是 M+(M * N)/buffer_size，显然 M 对结果的影响更大，因此也应尽量使用小表作为驱动表</p>
<p>4.没法用上索引(hash join)并且 join buffer 内存足够的情况下，执行效率是 M+N，同理也无所谓哪张表作为驱动表了</p>
<p>5.没法用上索引(hash join)并且 join buffer 内存不够需要分段的情况下，执行效率是 M+(M/buffer_size) * N，同理也是应尽量使用小表作为驱动表</p>
<p>综上几点可以得出在进行 join 查询时，最好是让小表作为驱动表，大表作为被驱动表来进行查询。</p>
<h4 id="如何判断小表大表"><a href="#如何判断小表大表" class="headerlink" title="如何判断小表大表"></a>如何判断小表大表</h4><p>在 join 联表查询时既然都说用小表作为驱动表，大表作为被驱动表，那么怎么去判断哪张表是大表，哪张表是小表呢，你可能会说当然数据量大的是大表，数据量小的是小表了，那真的是这样的吗？为了看出效果，我把上面两张表的索引都重新加上了，来看下面的几个例子:</p>
<p><img src="/images/image-20220515192053380.png" alt="image-20220515192053380"></p>
<p>同样是最开始的那个 SQL，只是在最后面给 cities 表加上了一个 where 条件，这时候虽然 cities 表的数据量更大，但是在这个 SQL 里面参与 join 的数据量其实只有一条数据(唯一索引)，所以在这个 SQL 里面 cities 应该作为驱动表，因为参与 join 联表查询的数据量更小。</p>
<p>还有一种情况就是当两张表参与 join 查询的数据量一样时，这时还会去看需要查询的字段大小，MySQL 也会考虑将查询字段更少的表作为驱动表，比如说下面这两个 SQL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select activities.*, cities.code from activities join cities on activities.city_code &#x3D; cities.code where cities.code &lt;&#x3D; 1000;</span><br><span class="line">explain select activities.code, cities.* from activities join cities on activities.city_code &#x3D; cities.code where cities.code &lt;&#x3D; 1000;</span><br></pre></td></tr></table></figure>

<p>在没有索引的情况下，放到 join buffer 里面的字段是不一样的，第一个 SQL，cities 表只要放入 code 字段加上 id，而 activities 表则是放入整张表的字段，第二个 SQL 则刚好相反，因此 MySQL 采取的也是将放入 join buffer 里面数据更小的表作为驱动表，这样可以避免分段或者分的段数更少。</p>
<p>因此，我们在判断大表小表的时候，不单单是看表里面的数据量，而是要看实际参与 join 查询的数据量的大小，也就是经过条件过滤之后真正参与 join 的数据以及真正查询的字段的大小。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>macOS 下使用 Docker 运行 MySQL 服务遇到的问题说明</title>
    <url>/macOS-%E4%B8%8B%E4%BD%BF%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-MySQL-%E6%9C%8D%E5%8A%A1%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>在之前的使用 Docker 运行 MySQL 服务的这篇文章中，有个问题没有描述清楚，这里我纠正下当时的说法，并且详细解释下缘由。</p>
<p>当时我做的测试是在 macOS 系统下完成的，当时使用 Docker 启动服务的时候报错了，报错信息如下:</p>
<a id="more"></a>

<p><img src="/images/docker_run_error.png" alt="docker run error"></p>
<p>当时我没太在意为什么会出现这种情况，我以为是跟我的目录包含大写字母的目录有关系，就直接去查了下解决办法，当时找到的解决方法是就是加上 mysqld –lower_case_table_names=0 这一串参数。</p>
<p>但其实不是这样的，首先先说明跟我指定的数据存储的目录包含大写路径无关。出现这个错误的原因其实错误信息里面已经提示了，”lower_case_table_names” 设置不一致，server 上该参数的值是 2，数据目录是 0。</p>
<p>首先我们先明白 lower_case_table_names 这个参数的作用，它的值可能有三种: 0，1，2.</p>
<ul>
<li>0: 表名和数据库名使用 CREATE TABLE 或 CREATE DATABASE 语句中指定的字母大小写存储在磁盘上，名称比较区分大小写</li>
<li>1: 表名以小写形式存储在磁盘上，名称比较不区分大小写，MySQL 在存储和查找时将所有表名转换为小写，此行为也适用于数据库名称和表别名。</li>
<li>2: 表名和数据库名使用 CREATE TABLE 或 CREATE DATABASE 语句中指定的字母大小写存储在磁盘上，但 MySQL 在查找时将它们转换为小写，名称比较不区分大小写，仅适用于不区分大小写的文件系统。</li>
</ul>
<p>上面是设置不同值下的作用，那么默认值是多少呢？这取决于我们运行 MySQL 所在的系统，在 Unix 上，lower_case_table_names 的默认值为 0。在 Windows 上，默认值为 1。在 macOS 上，默认值为 2。</p>
<p>而且还有值得注意的一点是: 仅在初始化服务器时才能配置 lower_case_table_names，禁止在服务器初始化后更改 lower_case_table_names 设置。</p>
<p>好了，在介绍完 lower_case_table_names 参数的作用以及注意事项之后，我们再回到之前的启动报错问题，这个就是 MySQL 初始化的时候数据目录挂在 macOS 下，该值的默认值是 2，而数据库启动的时候在 docker 容器中，容器中系统是 Unix，默认值是 0，这就是尝试在服务器初始化后更改 lower_case_table_names 设置，这是被禁止的，启动的时候和初始化时不一致所以报错了。</p>
<p>知道原因之后，那我们就尝试在初始化的时候就指定，加上 mysqld –lower_case_table_names=0 这一串参数来指定 lower_case_table_names 的值为 0，所以我们启动成功了。</p>
<p>但是我们一般都希望数据库名称或表名称在比较时不区分大小写，而且官方也有说明: “如果您在具有不区分大小写的文件名（例如 Windows 或 macOS）的系统上运行 MySQL，则不应将此变量设置为 0。如果在不区分大小写的文件系统上使用 –lower-case-table-names = 0 将此变量强制为 0，并使用不同的字母大小写访问 MyISAM 表名，则可能导致索引损坏”。</p>
<p>所以我们还是将 lower_case_table_names 的值设置成 1。同时我们在创建数据库名或表名的时候也尽量不要大小写混用，这也是为了避免出现意外情况。其实在阿里的 Java 开发手册中是强制约束表名、字段名必须使用小写字母，也是为了避免节外生枝。</p>
<p><img src="/images/table_name_rule.png" alt="table name rule"></p>
<p>好了，如果我们想要将 lower_case_table_names 的值设置成 1 该怎么做呢。是不是直接将参数改成 1 就可以了呢，我们可以试下，看看效果。试之前记得将挂载的数据库数据目录删除再做测试，不然会影响测试效果，或者重新挂载另一个目录也行，做完测试删掉就好了。</p>
<p>我们执行下面命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d run -d -p 3307:3307 -v /Users/rookiedev/docker/mysql/data1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql8.0-test mysql/mysql-server:8.0 mysqld --lower_case_table_names=1</span><br></pre></td></tr></table></figure>

<p>这里要注意，不同的数据库版本测试效果不一样的，这里我测试的效果是启动成功了，也验证确实将 lower_case_table_names 参数设置为 1 了，我通过以下命令进入连接 mysql 服务并且查看该参数的值确实是 1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it a9 mysql -uroot -p</span><br><span class="line">show variables like &quot;%case_table%&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/mysql_case_table.png" alt="mysql case table"></p>
<p>但有的版本是会失败的，我遇到过，但我没找出其中失败的规律，如果刚好你也碰到了，感兴趣的话可以研究看看，但我觉得大概率是不同版本的 mysql 启动配置文件可能不一样导致的，接下来我们就来介绍一下通过配置文件的方式来指定该参数值的方式。</p>
<p>之前我们只是通过 -v 参数挂载了数据目录，我们也可以通过 -v 参数来挂载 mysql 的配置文件, -v /Users/rookiedev/docker/mysql/conf:/etc/mysql，完整启动命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d run -d -p 3307:3307 -v /Users/rookiedev/docker/mysql/data1:/var/lib/mysql -v /Users/rookiedev/docker/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root --name mysql8.0-test mysql/mysql-server:8.0</span><br></pre></td></tr></table></figure>

<p>/Users/rookiedev/docker/mysql/conf 目录下包含一个 my.cnf 配置文件，文件内容是:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># datadir=/home/data</span><br><span class="line"># log-error=/home/logs/error.log</span><br><span class="line">lower_case_table_names=1</span><br></pre></td></tr></table></figure>

<p>上面的命令如果启动还是失败的话，可以加上 –restart=always 参数看看，参数的意思就是容器启动失败时会自动重启容器，同时 docker 重启时容器也会自动重启。同样启动成功之后可以进入容器连接 mysql 后看看是否设置成功了。</p>
<p>总的来说，我说的通过 mysqld 参数指定还是通过配置文件的方式指定，可能不一定适合你，具体问题具体分析吧。但我觉得这里我们需要知道的是 lower_case_table_names 这个参数的含义，在我们遇到数据库名字或表名是大写的或大小写混合时，我们可能会碰到一些问题，这时注意下当前数据库 lower_case_table_names 的值，还是有利于排查问题的。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>nginx location 路径匹配规则</title>
    <url>/nginx-location-%E8%B7%AF%E5%BE%84%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>之前每次配置 nginx 中的 location 这个路径时都会很头疼，基本上每次都是靠碰运气，一个个去试，直到访问路径通了为止，这样一来到最后还是不知道怎么配置成功的，下次再配置时又需要一个个去试，既浪费时间又很没有效率，所以这次特意花了点时间去学习了一番，特此记录一下，也记录一下自己在测试的过程中踩过的一些坑。</p>
<a id="more"></a>

<h2 id="location-匹配模式"><a href="#location-匹配模式" class="headerlink" title="location 匹配模式"></a>location 匹配模式</h2><p>主要有以下几种匹配模式：</p>
<ul>
<li>= 绝对匹配，如果匹配到了这个将停止匹配并处理该请求</li>
<li>~ 区分大小写的正则匹配</li>
<li>~* 不区分大小写的正则匹配</li>
<li>^~ 如果把这个前缀用于一个常规字符串,那么告诉 nginx 如果路径匹配那么不再去匹配正则</li>
<li>/ 通用匹配，任何请求都会匹配到</li>
</ul>
<p>它们之间的匹配顺序为：<br>1.先匹配普通字符串，然后再匹配正则表达式。<br>2.一般情况下，匹配成功了普通字符串 location 后还会进行正则表达式的 location 匹配。当然有两种方法能够改变这种方式，一个是使用 = 进行绝对匹配，另一个则是使用 ^~ 前缀匹配，它在匹配到了普通字符 location 之后不会再去寻找正则匹配。<br>3.普通字符串匹配顺序是根据配置中的字符长度从长到短，也就是使用普通字符串的匹配顺序和 location 之间的先后顺序是无关的，最后 nginx 都会根据配置的字符长短来进行匹配。<br>4.正则表达式则是按照配置文件里的顺序来匹配，找到第一个匹配的正则表达式将停止搜索。</p>
<p>下面列举常见的几个匹配模式，在测试的过程中注意缓存的原因导致测试结果不正确，优先使用 Firefox 浏览器测试，Chrome 浏览器的缓存更严重。最好的还是每次测试访问时先清除一下缓存，这样才能保证我们的测试结果是正确的。还一个就是注意地址是否填写正确，不要在地址栏最后多出一个斜杠。最后就是我们所编辑的 nginx 配置文件一定要和我们启动的 nginx 配置文件一致。</p>
<h2 id="绝对匹配"><a href="#绝对匹配" class="headerlink" title="绝对匹配"></a>绝对匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;192.168.0.234:10080&#x2F;index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的绝对匹配只是简单的配置了一个代理，将当前路径代理到另外一个服务的首页。</p>
<h2 id="区分大小写的正则匹配"><a href="#区分大小写的正则匹配" class="headerlink" title="区分大小写的正则匹配"></a>区分大小写的正则匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ image &#123;</span><br><span class="line">    root &#x2F;home&#x2F;zhouxh&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置表示当用户访问 <a href="http://192.168.0.234:10080/image/test.jpg">http://192.168.0.234:10080/image/test.jpg</a> 时，将会转到当前服务的 /home/zhouxh/image/ 目录下去查找 test.jpg，也就是 <a href="http://192.168.0.234:10080/home/zhouxh/image/test.jpg%E3%80%82">http://192.168.0.234:10080/home/zhouxh/image/test.jpg。</a></p>
<h2 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line">    root &#x2F;home&#x2F;zhouxh&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于配置比较简单，上面的配置和上一个正则匹配的结果是一样的，只不过这里是通过普通的匹配方式匹配到 /image 这个 location。</p>
<h2 id="location-中的-root-和-alias-的区别"><a href="#location-中的-root-和-alias-的区别" class="headerlink" title="location 中的 root 和 alias 的区别"></a>location 中的 root 和 alias 的区别</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line">    root &#x2F;home&#x2F;zhouxh&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;image &#123;</span><br><span class="line">    alias &#x2F;home&#x2F;zhouxh&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个配置当用户访问 <a href="http://192.168.0.234:10080/image/test.jpg">http://192.168.0.234:10080/image/test.jpg</a> 时，访问的文件路径是不一样的，当使用 root 时路径为 <a href="http://192.168.0.234:10080/home/zhouxh/image/test.jpg%EF%BC%8C%E5%BD%93%E4%BD%BF%E7%94%A8">http://192.168.0.234:10080/home/zhouxh/image/test.jpg，当使用</a> alias 时路径为 <a href="http://192.168.0.234:10080/home/zhouxh/test.jpg%EF%BC%8C%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E">http://192.168.0.234:10080/home/zhouxh/test.jpg，两者的区别在于</a> root 是将实际访问文件路径即 root 后面的路径拼接 URL 中的路径，而 alias 是实际访问文件路径即 alias 后面的路径不去拼接 URL 中的路径。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 实现 TCP 代理及其负载均衡之 stream 模块</title>
    <url>/nginx-%E5%AE%9E%E7%8E%B0-TCP-%E4%BB%A3%E7%90%86%E5%8F%8A%E5%85%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8B-stream-%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>前面所说的 nginx 负载均衡都是基于 HTTP 七层代理，有时候我们可能需要基于 TCP 四层代理以及负载均衡，在之前我们可能需要编译安装第三方的一个模块 nginx_tcp_proxy_module，并且需要打上一个补丁，具体安装方式可以去参考项目中的描述。</p>
<a id="more"></a>

<p>项目地址如下，不过需要注意的是安装这个模块存在兼容性问题，最好使用较低版本的 nginx 去安装，否则很容易出错，所以现在不推荐使用这个进行 TCP 代理。在 nginx 1.9.0 的版本以及更高的版本中，nginx 默认将 ngx_stream_core_module 模块编译进来了，该模块支持 TCP 代理及其负载均衡。下面就主要来介绍一下如何使用它来进行 TCP 代理和负载均衡。</p>
<p><a href="https://github.com/yaoweibin/nginx_tcp_proxy_module">nginx_tcp_proxy_module 项目地址</a></p>
<h2 id="ngx-stream-core-module-编译安装"><a href="#ngx-stream-core-module-编译安装" class="headerlink" title="ngx_stream_core_module 编译安装"></a>ngx_stream_core_module 编译安装</h2><p>由于 nginx 1.9.0 版本以及之后的版本默认将该模块集成进来了，所以我们不需要额外添加，我们只需要在配置时加上 –with-stream 参数来激活这个模块。命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --with-stream</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="TCP-代理"><a href="#TCP-代理" class="headerlink" title="TCP 代理"></a>TCP 代理</h2><p>将 nginx 配置安装好了之后就可以在 nginx.conf 的配置文件中配置 TCP 代理了，其实也就是在配置文件在加一个和 http 模块平级的 stream 模块，其他配置大部分和 http 代理中的一样，下面是一个简单的 TCP 代理配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 50001;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass 192.168.1.110:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 50002;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是监听本机的 50001 和 50002 端口，并且将其分别代理到 192.168.1.110 和 192.168.1.111 的 10080 端口，而 10080 这个端口 分别是 192.168.1.110 和 192.168.1.111 的 nginx 访问端口，测试情况如下图：</p>
<p><img src="/images/tcp_proxy.png" alt="测试结果"></p>
<h2 id="TCP-负载均衡"><a href="#TCP-负载均衡" class="headerlink" title="TCP 负载均衡"></a>TCP 负载均衡</h2><p>基于 TCP 的负载均衡和 HTTP 的负载均衡配置大致一样，只不过负载均衡策略没有那么多，主要有默认的轮询，加权轮询，最少连接数，最低平均延时，hash 这五种方式，先声明以下测试是在 nginx 版本 1.12.0 上测试的。这里简单说一下我所遇到的坑，我刚开始是在 chrome 浏览器上测试的，发现测试这些策略都是不对的，而且始终访问到后台同一台服务，只是偶尔会变一下，然后使用 Firefox 浏览器测试，发现按 F5 刷新还是始终访问到同一后台服务，然后尝试着按 Ctrl + F5 进行刷新这才按照我们配置的策略进行负载，而回到 chrome 浏览器上也试着按 Ctrl + F5 刷新还是一直访问的后台同一台服务，暂时还不知道是什么原因。有知道的可以告诉我一下，不甚感激。</p>
<p>1.默认配置 ( 轮询 )</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的配置就是不加任何负载策略，采用默认的方式，默认的方式就是轮询的方式。</p>
<p>2.加权轮询配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        server 192.168.1.110:10080 weight&#x3D;3;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在轮询策略的基础上给每个后台服务加上权重，权重越大，访问的概率越大，像上面的配置的话就是每访问三次 192.168.1.110 这台服务就会访问一次 192.168.1.111 这台服务。</p>
<p>3.最少连接数配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是采用一种固定的负载策略，最少连接数策略，也就是选择连接数最少的后台服务。</p>
<p>4.最低平均延时配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        least_time connect;</span><br><span class="line">        #least_time first_byte;</span><br><span class="line">        #least_time last_byte;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面策略配置表示的是对于每个请求，可通过最低平均延时来选择后台服务，而这个最低平均延时则是看 least_time 指令中指定的参数计算出来的，主要有下面三个参数：</p>
<ul>
<li>connect：连接到后台服务花的时间</li>
<li>first_byte：接收到第一个字节花的时间</li>
<li>last_byte：接收到最后一个字节花的时间，也就是全部接收完的时间</li>
</ul>
<p>值得注意的是该策略现在是作为 nginx 商业订阅的一部分提供，也就是需要花钱才能够实现这个功能。</p>
<p>5.hash 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        hash $remote_addr consistent;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面采用的是 hash 算法策略，对客户端的 IP 进行 hash，让每台客户端固定访问到后台的一台服务。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 的正向代理和反向代理</title>
    <url>/nginx-%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>nginx 服务器在我们平常的软件开发中可能还是用到的比较多的，那么有一个问题我们就应该明白，也许让你去实现轻而易举，但说到其中的原理就有点不是很清楚了。下面就谈谈我自己对正向代理和反向代理的理解：首先有一个用户 C，三台服务器 S1，S2 和 S3，S1，S2，S3 在同一局域网内互相可访问，但 S1 对外网开放，S2 和 S3 不对外网开放，还有一份数据资源 D，资源 D 放在服务器 S2 和 S3 上。</p>
<a id="more"></a>

<h2 id="nginx-正向代理"><a href="#nginx-正向代理" class="headerlink" title="nginx 正向代理"></a>nginx 正向代理</h2><p>这时用户 C 明确知道自己想访问的数据资源 D 在服务器 S2 上，用户 C 想要访问这份资源但是没办法直接访问服务器 S2，用户 C 想到服务器 S1 和 S2 在同一局域网并且互相可访问，而自己能够访问服务器 S1，所以用户 C 就通过服务器 S1 去访问服务器 S2 上的资源 D。那么正向代理就是对于用户 C 来说他是明确知道他要访问的数据资源 D 在哪个服务器上；对于服务器 S1 来说他只充当了用户 C 的中间代理角色；而对于服务器 S2 来说他只知道访问他的资源的是服务器 S1，根本不知道用户 C 的存在。</p>
<p>正向代理的整个流程就是用户 C 访问服务器 S2 上的数据资源 D，但是是通过借助服务器 S1 来进行访问，服务器 S1 得到数据资源后再返回给用户 C。</p>
<h2 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h2><p>还是刚开始上面说的这些：用户 C，服务器 S1，S2 和 S3，以及服务器 S2 和 S3 上的数据资源 D。这时用户 C 并不知道数据资源 D 在服务器 S2 和 S3 上面，他只知道访问服务器 S1 可以得到自己想要的内容，于是他每次都是直接访问服务器 S1，只不过提供给用户 C 数据资源的都是服务器 S2 或者 S3。那么反向代理就是对于用户 C 来说他是不知道数据资源 D 具体在哪里，是由谁提供的；对于服务器 S1 来说每次都接收用户的请求，然后再把请求交给真正能提供资源的服务器 S2 或 S3；对于服务器 S2 和 S3 来说同样也都不知道访问这份资源的真实用户是谁，只是和服务器 S1 进行交互。</p>
<p>反向代理的整个流程就是用户 C 访问服务器 S1 获取数据资源 D，服务器 S1 将请求转交给服务器 S2 或 S3，然后得到相应的资源后再返回给用户 C。</p>
<p>总之，正向代理就是客户端知道服务器端，带过代理连接服务器端。反向代理就是客户端不知道服务器端，通过代理连接服务器端，具体是由哪个服务器端提供服务取决于代理的调度方式，即 nginx 中的负载均衡策略。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 负载均衡策略之内置策略</title>
    <url>/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B9%8B%E5%86%85%E7%BD%AE%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>nginx 服务器在开发中我们用的比较多的有 nginx 的负载均衡，nginx 负载均衡主要是利用反向代理来实现，也就是表面上我们访问的是这个服务，其实访问的是该服务背后支撑的众多服务器中的其中一台。比如说全世界同一时间有这么多人同时在访问百度这个网站，它是怎么能够承受的住这么大的访问量呢，这时我们就应该知道其实百度这个网站的背后有很多的服务器在支撑着众多的用户的访问。</p>
<a id="more"></a>

<p>但是这里就引出一个问题，用户访问的这个服务是如何分发给它背后的众多的服务器呢，于是就出现了满足各种需求的负载均衡策略，其中有 nginx 自己内置的负载均衡策略，也有第三方提供的一些负载均衡策略。今天主要谈一下 nginx 内置的负载均衡策略，主要有四种：轮询（默认）、加权轮询、最少连接 least_conn、IP 哈希 ip_hash，下面将一一进行介绍。</p>
<p>首先我们先安装好 nginx 服务器，下面是在 Ubuntu 16.04 系统测试的，采用的 nginx 版本是 nginx/1.12.0。</p>
<h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p>下载基于 Linux 系统的 nginx/1.12.0 版的 nginx 服务器进行解压编译安装，下面是安装命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.12.0.tar.gz</span><br><span class="line">sudo tar xzf nginx-1.12.0.tar.gz</span><br><span class="line">cd nginx-1.12.0</span><br><span class="line">sudo .&#x2F;configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>上面安装成功后，nginx 默认安装在目录 /usr/local/nginx/ 下面，当然你也可以自定义安装目录，不过一般不建议这么做，以防以后都不知道到哪里去找配置文件，默认就好，安装成功后可以在 /usr/sbin/ 目录下创建一个软链接指向 /usr/local/nginx/sbin/nginx 文件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;sbin&#x2F;nginx &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>这样我们就不用每次启动 nginx 服务都切换到 /usr/local/nginx/sbin/ 目录下去执行 nginx 的启动命令，配置好了这些后就可以启动 nginx 服务器进行测试了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf </span><br></pre></td></tr></table></figure>

<p>执行上面的启动命令后在浏览器中输入 localhost 后回车出现对应的 nginx 服务器的欢迎页面就表示 nginx 服务器安装成功了，这里我们为了更好的测试首先将 nginx.conf 配置文件中 http 的默认端口 80 改成 10080，改了之后重新启动 nginx 服务器后接着在浏览器中输入 localhost:10080 后回车应该又会出现刚才的欢迎页面了。接下来就开始我们的 nginx 的负载均衡策略之旅吧。</p>
<h2 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h2><p>轮询这个策略是 nginx 进行负载均衡时默认采用的策略，也就是最基本的负载均衡配置，打开 /usr/local/nginx/conf/ 目录下的 nginx.conf 配置文件，我们配置一个最简单的负载均衡方式，在配置文件中 http 模块里面也就是和 http 模块里面的 server 模块同级加上以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 http 模块里面的 server 模块下面的 location 模块加上一行配置，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;loadserver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>部分配置文件截图如下：</p>
<p><img src="/images/polling.png" alt="轮询策略配置"></p>
<p>这样也就配置好了最基本的负载均衡，默认采用轮询的策略将请求分发给后台服务器，当我们访问 localhost:10080 这个地址时页面轮流的展示 192.168.1.110 和 192.168.1.111 这两台主机的 nginx 服务器的欢迎页面，这里为了区分这两个欢迎页面需要修改一下这两台主机的 nginx 服务器的欢迎页面信息，欢迎页面默认存放在 /usr/local/nginx/html/ 目录下的 index.html 页面。我们只要稍微修改一下这两台主机的 nginx 欢迎页面使得每次访问的页面都是不同的，便于我们区分访问的是哪台主机的 nginx 服务器。</p>
<h2 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h2><p>加权轮询则是在第一种轮询的基础上对后台的每台服务赋予权重，服务器的权重比例越大，被分发到的概率也就越大，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    server 192.168.1.110:10080 weight&#x3D;3;</span><br><span class="line">    server 192.168.1.111:10080 weight&#x3D;1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是给每个后台服务加上了一个权重比例，拿上面的配置举例：用户将会每访问三次 192.168.1.110 这个服务访问一次 192.168.1.111 这个服务。这种适合后台的各个服务的性能不一样，这时我们就可以将性能好的服务器权重设置大一些，减轻一些性能不怎么样的服务器的压力。</p>
<h2 id="最少连接-least-conn"><a href="#最少连接-least-conn" class="headerlink" title="最少连接 least_conn"></a>最少连接 least_conn</h2><p>最少连接是每次请求都将请求分发给后台服务连接数最少的那台服务上，当然如果每台服务还配置了权重，那么这时会取连接数和权重比值最小的那台服务，如果连接数和权重的比值都相同的话就会采取轮询的方式进行分发，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置只是加了一个调度策略 least_conn，其他和轮询的方式一样，当然你也可以给每台服务加上权重比例，分发时就会选择 conn / weight 值最小的那台服务，这种方式适合请求处理时间长短不一造成服务器过载的情况。</p>
<h2 id="IP-哈希-ip-hash"><a href="#IP-哈希-ip-hash" class="headerlink" title="IP 哈希 ip_hash"></a>IP 哈希 ip_hash</h2><p>ip_hash 这种负载策略是根据客户端的 IP 地址的 hash 结果来进行分发，这样的话能够确保每个访客访问后端固定的一台服务器，这种情况对于需要保存用户的 session 信息的应用就很方便了，它避免了同一个用户访问到不同的服务器上产生 session 共享的问题。配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置只是加了一个调度策略 ip_hash，其他也和轮询的方式一样，这里你也可以给每台服务加上权重比例，分发时在该客户端 IP 第一次访问时就会优先选择 weight 值最大的那台服务。</p>
<h2 id="其他配置说明"><a href="#其他配置说明" class="headerlink" title="其他配置说明"></a>其他配置说明</h2><p>其实每个后台服务器的配置除了权重 weight 还有一些配置，比如说下面的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.1.110:10080 weight&#x3D;5 ;</span><br><span class="line">    server 192.168.1.111:10080 weight&#x3D;1;</span><br><span class="line">    server 192.168.1.112:10080 weight&#x3D;1 max_fails&#x3D;3 fail_timeout&#x3D;30s;</span><br><span class="line">    server 192.168.1.113:10080 down;</span><br><span class="line">    server 192.168.1.114:10080 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置说明：<br>1.weight 的值默认为1，weight 越大，服务器负载的权重就越大，访问的概率越高。<br>2.down 表示当前服务器暂时不参与负载。<br>3.backup 表示其它所有的非 backup 服务器 down 或者忙的时候才会请求 backup 服务器，所以这台服务器压力最轻，一般这台服务器当做是备用服务器。<br>3.max_fails 表示允许请求失败的次数，默认为 1，当超过最大次数时，返回proxy_next_upstream 模块定义错误。<br>4.fail_timeout 表示每次失败后暂停的时间。</p>
<p>到这里就全部介绍完了 nginx 负载均衡内置的一些策略，还有第三方扩展的一些策略，未完待续………</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx 负载均衡策略之第三方扩展策略</title>
    <url>/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>之前已经将 nginx 负载均衡中的内置策略介绍完了，下面我们来看一下第三方的扩展策略，所谓的内置策略其实就是 nginx 安装后就已经自带了，对于第三方的一些策略则是需要我们在安装时要额外添加第三方的模块才能实现。下面就一一进行介绍：</p>
<a id="more"></a>

<h2 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h2><p>该策略将前端请求的 url 地址进行 hash，根据 hash 结果将请求定向到同一后端服务器节点上，这种适合后台服务器为缓存时比较有效，一般也会配合缓冲命中来使用。</p>
<p>刚才也说了第三方策略需要额外添加第三方模块才能实现，所以我们需要对我们的 nginx 进行重新编译安装，下面是添加第三方模块编译安装的命令，但要注意的是这个第三方模块需要我们提前下载好，下面命令中的路径就是我下载的模块所在路径。url_hash 策略需要的第三方模块是 ngx_http_consistent_hash，这个可以在 nginx 第三方模块网站中找到该项目的 github 地址，这里贴出地址：</p>
<p><a href="https://www.nginx.com/resources/wiki/modules/">nginx 第三方模块网站</a><br><a href="https://github.com/replay/ngx_http_consistent_hash">ngx_http_consistent_hash 项目地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;ngx_http_consistent_hash</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>然后还是在之前我们添加的 upstream 中加上对应的策略，配置如下，不清楚的可以参考上一篇的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    consistent_hash $request_uri;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置加了一个调度策略：一致性哈希 consistent_hash，对客户端请求的 url 进行哈希，既然这里采用 url_hash 的策略来进行负载，那么对于后面再进行权重配置就没有多大意义了，所以后面就不必再添加 weight 权重配置了。</p>
<h2 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h2><p>这个策略按后端服务器的响应时间来分配请求，响应时间短的优先分配，但在实际项目中，响应时间受很多的因素所影响，所以真正采用这种方式进行负载需慎重。同样的先下载 fair 策略对应的第三方模块 nginx-upstream-fair，再对我们的 nginx 进行重新编译安装，nginx-upstream-fair 项目地址如下：</p>
<p><a href="https://github.com/itoffshore/nginx-upstream-fair">nginx-upstream-fair 项目地址</a></p>
<p>这个项目其实并不是第三方模块网站中找到的那个 nginx-upstream-fair 项目，那个项目我使用 nginx-1.12.0 版本的 nginx 编译出错，于是看到那个项目中也有人遇到这个问题，他推荐的是另一个 nginx-upstream-fair 项目，也就是上面贴出来的那个，编译正常通过，基于 nginx-1.12.0 版本的 nginx 亲测可用。<br>编译安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;ngx_http_consistent_hash --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;nginx-upstream-fair</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>配置也是一样的，只是需要改变一下策略名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    fair;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>该策略是在多台服务器的环境下，确保一个客户端只和一台服务器通讯，它会保持长连接，并在结束会话后再次选择一个服务器，保证了压力均衡。同样的我们先下载 fair 策略对应的第三方模块 nginx-upstream-fair，再对我们的 nginx 进行重新编译安装，nginx-upstream-fair 模块在第三方模块网站中能够找到直接下载：</p>
<p><a href="https://www.nginx.com/resources/wiki/modules/">nginx 第三方模块网站</a></p>
<p>编译安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo .&#x2F;configure --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;ngx_http_consistent_hash --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;nginx-upstream-fair --add-module&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;nginx-sticky-module-ng</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>配置也是一样的，需要改变一下策略名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    sticky;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：由于整个模块是通过 cookie 实现，如果浏览器不支持 cookie，那么 sticky 不生效。</p>
<p>到这里 nginx 负载均衡一些扩展的第三方策略也全部介绍完了 ，有点要提醒的是以上都是基于 HTTP 七层负载均衡，还有一个是 TCP 四层负载均衡，接下来会有介绍。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized 加锁实现线程安全</title>
    <url>/synchronized-%E5%8A%A0%E9%94%81%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p>在 Java 里面我们可能会遇到由于资源共享导致线程安全的问题，经常性的就是多个线程同一时间对共享的资源数据进行修改，这时可能就会出现数据不是我们预期的情况。</p>
<p>拿一个通俗点的例子来说的话就是多个线程对同一个账户进行扣款操作，比如说下面的例子：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> accountBalance = <span class="number">10</span>;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(accountBalance &gt;= amount)&#123;</span><br><span class="line">    <span class="comment">// deduction</span></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    accountBalance -= amount;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction success&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction failed, insufficient account balance.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Thread thread0 = <span class="keyword">new</span> Thread(() -&gt; consume(<span class="number">10</span>));</span><br><span class="line">  Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; consume(<span class="number">10</span>));</span><br><span class="line">  thread0.start();</span><br><span class="line">  thread1.start();</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(<span class="number">5000</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;account balance: &quot;</span> + accountBalance);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中很简单，大体就是模拟账户余额剩余 10 元，然后有两个线程同时进行消费，两个线程都是消费 10 元，消费方法里面有个判断当账户余额不足 10 元会打印账户余额不足，扣款失败，但是执行上面代码后发现两个线程都消费成功了，最后打印账户余额变成了 -10 元，甚至有时候还会出现 0 元的情况，很明显这不是我们预期的结果，我们想要的是账户余额不足时扣款失败，但上面都成功了，然后账户余额变成了负数。这就是由于多个线程同时对同一个账户进行消费扣款而没有做相应的线程安全的保证措施而导致的，这只是一个很简单的例子演示了多线程下出现的问题，那么在我们日常开发中有哪些措施来保证线程安全呢。</p>
<p>Java 中保证线程安全的通用做法是通过 synchronized 关键字来对方法或者代码块进行加锁，比如说上面的代码中对 consume 方法进行加锁，这样就能够保证每次只有一个线程能够进入 consume 方法来进行扣款操作，相当于让扣款操作同步执行，这样就不会出现多个线程同时对账户扣款导致出现问题，consume 方法加上 synchronized 关键字之后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(accountBalance &gt;= amount)&#123;</span><br><span class="line">    <span class="comment">// deduction</span></span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">    accountBalance -= amount;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction success&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction failed, insufficient account balance.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面由于我为了简单起见，方法直接声明成静态的，所以在方法上加锁的话，锁定的是类对象，不同线程执行该方法需要先获取该类对象锁，如果锁已经被其他线程占有，那么就需要等待其他线程释放锁。但是这样直接对整个方法进行加锁可能有点太粗暴了，其实如果方法中还有其他操作的话，我们往往只是需要保证方法中的一小部分代码是线程安全的即可，假如 consume 方法在扣款前还需要对账户进行校验，以验证账户是否正常，那么校验账户是否正常的这部分代码就可以不用进行同步，可以并发执行，而只要对扣款的那部分代码加锁即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;verify that the account is normal...&quot;</span>);</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (SynchronizedTest.class)&#123;</span><br><span class="line">    <span class="keyword">if</span>(accountBalance &gt;= amount)&#123;</span><br><span class="line">      <span class="comment">// deduction</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">      accountBalance -= amount;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction success&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction failed, insufficient account balance.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 consume 方法只对扣款部分代码进行加锁，加锁的方式和上面其实是一样的，也是通过该类对象来加锁，只不过锁定的范围缩小了，锁定的只是扣款的那部分操作，对于账户校验的操作依然是并发执行，这样可以提高程序执行的最大并发度，从而提高程序执行效率。</p>
<p>其实上面的代码看起来好像已经是最大限度的并发执行了，但是上面的代码演示的是同一个用户同时进行消费，你可以试想一下如果是两个用户在同时进行消费操作呢，那么找上面的代码执行的话，他们的消费的顺序也是依次按序执行的。</p>
<p>这里用 A 和 B 来代表两个不同用户，A1，A2 表示 A 用户同时进行的两笔消费，B1，B2 表示 B 用户同时进行的两笔消费，那么当 A，B 用户同时进行消费的时候，按照上面的代码执行逻辑，那就可能产生这种消费顺序: A1 -&gt; A2 -&gt; B1 -&gt; B2，当然这只是可能的消费顺序中其中一种，也有可能 B1 -&gt; B2 -&gt; A1 -&gt; A2，A1 -&gt; B2 -&gt; B1 -&gt; A2 等等一些。</p>
<p>但不管是哪一种，由于我们通过 synchronize 关键字来保证线程安全，那么这四笔消费都是按顺序依次进行扣款的，但其实呢，这里 A，B 两个用户之间的扣款是没有关联的，因为他们隶属于不同的账户，也就是说他们之间的扣款是可以并发执行的，而不需要按序来进行扣款，所以我们只要保证同一个用户在同一时间的消费扣款是顺序执行的就可以了。因此我们需要通过更细粒度的锁来实现只在同一用户下不同线程之间的扣款是顺序执行，而不同用户之间的扣款依然是并发执行。</p>
<p>那这种用户级别的细粒度锁又该如何来实现呢？首先我们先来梳理一下我们要实现的预期效果，对于 A，B 两个用户来说，他们之间是不同的账户，他们之间互相的扣款顺序是互不影响的，我们最终仅仅是要保证每个用户他自己在多线程扣款的情况下是安全的即可。那么我们在加锁的时候就应该对该用户进行加锁，A 用户的 T1 线程执行扣款操作时，如果已经有其他线程 T2 已经获取了 A 用户的锁正在执行扣款操作的话，那么 T1 线程就需要等待 T2 线程释放 A 用户的锁才能继续往下执行。而这时如果 B 用户的一个线程也来执行扣款操作，那么 B 用户扣款操作的线程需要获取的是 B 用户的锁，如果 B 用户没有其他线程正在执行扣款，那么 B 用户就可以正常执行扣款，与 A 用户是否存在扣款操作线程无关。</p>
<p>说了这么多，其实也就是我们的程序在加锁时只要锁定和每个用户各自相关的对象锁，不同用户之间互不影响即可，我们来看看一种简单的用户级别细粒度锁是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(String userId, <span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;verify that the account is normal...&quot;</span>);</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (userId.intern())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;enter the deduction code block&quot;</span>);</span><br><span class="line">    Integer userAccountBalance = accountMap.get(userId);</span><br><span class="line">    <span class="keyword">if</span>(userAccountBalance &gt;= amount)&#123;</span><br><span class="line">      <span class="comment">// deduction</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">      userAccountBalance -= amount;</span><br><span class="line">      accountMap.put(userId, userAccountBalance);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction success&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction failed, insufficient account balance.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码从最初的单个用户扣款经过简单的扩展模拟多个用户进行消费，同时在消费方法加上了用户 id 参数来决定扣款的账户是哪一个，然后使用 Map 来保存用户的账户余额信息。在扣款时先去 Map 中取对应用户的账户然后再执行扣款操作。</p>
<p>但要注意的是上面加锁的代码中加锁的对象是用户字符串 id 调用 intern() 方法返回的值，那 String 类中的 intern 方法是干嘛的呢？<strong>简单的说是一个字符串对象调用此方法时，如果字符串常量池中已经包含了该字符串，则直接返回常量池中该字符串的引用地址，否则该字符串对象的引用地址将会被加入到常量池中，然后再返回该引用地址。</strong>也就是说一个字符串对象的地址通过调用 intern 方法之后，那么最终在字符串常量池中会生成一份唯一的值，所以我们通过 synchronize 关键字加锁的这个对象是用户 id 字符串在字符串常量池中唯一对象的地址值。(这里可能有点不太好理解，intern 方法下次再用一篇文章单独详细介绍下)</p>
<p>那么接下来再回到用户 A，B 同时消费的情况，由于我们锁定的是用户 id，那么当用户 A，B 同时进行消费，A 用户获取的是 A 用户 id 的对象锁，而 B 用户获取的是 B 用户 id 的对象锁，不同用户获取的锁是不同的，所以他们之间互不影响，那么他们在同时进行消费扣款时就能同时进入加锁的代码块执行扣款，但相同用户的不同线程则还是会等同一用户的其他线程释放锁之后才能进入加锁的代码块。</p>
<p>虽然说这种实现方式实现起来相对较简单，但是这种通过 intern 方法的实现方式也是有缺陷的，当用户量特别大的情况下就会有问题了，这时字符串常量池中可能会存储大量的字符串引用，这其实就涉及到 JVM 虚拟机的存储结构了以及 GC 相关的知识了，字符串常量池这块区域相对于 GC 的主要区域堆区来说，这块区域 GC 比较困难，因此一般也不太建议采用这种方式来实现用户级别的细粒度锁，下篇文章我们就来看下比较常见的细粒度锁的实现方式有哪些。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized 的替代品 ReentrantLock</title>
    <url>/synchronized-%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81-ReentrantLock/</url>
    <content><![CDATA[<p>v本来这篇文章打算写下细粒度锁的几种通用实现的，但在实践的过程中，我觉得有必要先介绍一下 ReentrantLock 这个类，可能大部分人都没有使用过，其实我也是一样，在接触到这个类之前都是只用过 synchronized 关键字，直到接触到了 ReentrantLock 这个类才知道还有这个东西，哎，还是对并发编程不是非常熟悉，对 JUC 并发包还需要进一步的去学习，下面我们就一起来看下 ReentrantLock 这个类是怎样的。</p>
<a id="more"></a>

<p>在 Java 中当我们需要对某个方法或代码块进行加锁时，往往我们第一时间想到的是 synchronized 关键字，通过 synchronized 来保证多线程环境下的线程安全。比如说下面两段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;execute sync method&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;enter sync method&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;execute sync method&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两段代码很简单，一个是在 syncMethod 方法上加上 synchronized 关键字，另一个是在方法内部对部分代码块进行加锁，或许我们都知道这样都能保证 syncMethod 方法或 syncMethod 方法内部分代码块是线程安全的，那么有没有另外一种方式来实现这一效果呢？</p>
<p>答案是有的，也就是我们上面提到的 ReentrantLock 类了，他可以说是 synchronized 的替代品，一般翻译成再入锁，和 synchronized 关键字一样都是可重入的，也就是说当一个线程尝试获取它已经获取成功的锁时，这时锁直接获取成功。那我们先看如何使用 ReentrantLock 类实现上面的效果吧。</p>
<p>其实第一种也可以认为是使用 synchronized 关键字将整个 syncMethod 方法的代码包裹起来，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;execute sync method&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ReentrantLock 类实现加锁方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;execute sync method&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到使用 ReentrantLock 来加锁的话其实就跟使用普通对象一样，调用 lock 方法加锁，unlock 方法解锁，只不过千万需要注意的是在我们调用 lock 方法进行加锁之后一定要保证有解锁的操作。一般我们是通过 try-finally 的方式来确保 unlock 方法被调用，而且 unlock 方法的调用需要放在 finally 代码块的第一行。还有就是 lock 方法的调用最好不要放到 try 代码块中，不然万一 lock 方法加锁失败，最终 finally 代码块中的解锁方法被调用会抛出异常，因为是在锁根本没有加成功的情况下去解锁。</p>
<p>如果说仅仅是作为 synchronized 关键字的替代品那就太弱了，ReentrantLock 还能够实现一些 synchronized 无法做到的场景，比如说带超时的加锁操作。有时候由于业务需要，在尝试进入加锁的代码块时，如果 3s 之内没有获取到锁的话直接返回，提示用户重新操作，这可以有效减小高并发给系统带来的压力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;execute sync method&quot;</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;execute other logic&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中通过调用 ReentrantLock 类的 tryLock 带超时时间参数的方法，在 3s 内加锁失败的话执行其他逻辑。</p>
<p>对于 ReentrantLock 类，它还提供保证获取锁公平性，判断是否有其他线程也在排队等待获取锁等一些特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建公平性锁</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 队列中是否有线程在等待获取锁</span></span><br><span class="line">lock.hasQueuedThreads();</span><br><span class="line"><span class="comment">// 锁是否已经被线程持有</span></span><br><span class="line">lock.isLocked();</span><br><span class="line"><span class="comment">// 是否是当前线程持有该锁</span></span><br><span class="line">lock.isHeldByCurrentThread();</span><br></pre></td></tr></table></figure>

<p>上面锁在创建的时候设置 boolean 参数指定是否需要提供公平性，一般是不太建议引入公平性锁，因为只要引入公平性锁必然就要有额外的开销来保证线程获取锁的公平性，所以说除非业务实在是需要一般不引入。</p>
<p>接下来我们再看一下和 ReentrantLock 类有关的一个比较实用的功能，配合 Condition 条件变量非常优雅的实现线程间的通信操作，就有点类似于 Object 类中的 wait，notify/notifyAll 方法，都是实现线程间的通信，而这里是采用 await，signal/signalAll 组合，我们可以看下面一段很简单的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition notEmpty = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(String str)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  reentrantLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    list.add(str);</span><br><span class="line">    System.out.println(<span class="string">&quot;send a signal to add elements to the list&quot;</span>);</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;producer unlock&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  reentrantLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;waiting for elements to add the list&quot;</span>);</span><br><span class="line">      notEmpty.await();</span><br><span class="line">      System.out.println(<span class="string">&quot;received a signal to add elements to the list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;consume list element&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;consumer unlock&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码我们拿一个 list 来简单模仿队列的生产和消费操作，同时通过 ReentrantLock 创建一个 notEmpty 的 condition 来实现当 list 集合大小为 0 时，消费端则需要等待生产端生产元素，一旦生产端有元素进入，立马通过 notEmpty 的 condition 来通知消费端消费，消费端在收到生产端的信号之后则可以继续消费。</p>
<p>测试代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    test.consume();</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    test.produce(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">consumer.start();</span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">producer.start();</span><br></pre></td></tr></table></figure>

<p>测试代码中先启动消费线程，消费线程启动之后，等待元素进入集合，接着启动生产线程，生产元素进入集合，紧接着发送有元素加入的信号通知消费线程开始消费。测试结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">waiting for elements to add the list</span><br><span class="line">send a signal to add elements to the list</span><br><span class="line">producer unlock</span><br><span class="line">received a signal to add elements to the list</span><br><span class="line">consume list element</span><br><span class="line">consumer unlock</span><br></pre></td></tr></table></figure>

<p>当然上面例子中的代码可能不是很严瑾，但我觉得足以说明 ReentrantLock 配合 Condition 一起使用可以实现的功能了，如果你想看下标准的实现方式，可以去看下标准类库中的 ArrayBlockingQueue，它里面的入队和出队操作就是利用了上面例子所表达的这一功能。</p>
<p>上面描述了 ReentrantLock 类的整体使用，基本上能够做到 synchronized 关键字所能做到功能，那么它们两者的性能如何呢？其实在 Java 6 之前的版本，synchronized 关键字的性能表现不是很理想，直到在 Java 6 中进行了很大的改进，加入了偏斜锁，轻量级锁，重量级锁实现，这才让 synchronized 关键字的性能得到很大的改善，在这之后，如果是并发冲突很高的情况下，ReentrantLock 的性能表现会更好点，相反，synchronized 关键字的表现会更好些。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>zookeeper 单机模式以及伪集群模式搭建</title>
    <url>/zookeeper-%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>首先说一下我对 <code>zookeeper</code> 的学习，在刚开始听的时候觉得很高大上，但又觉得很陌生，也不知道是干嘛的，然后就网上查各种资料开始慢慢对 <code>zookeeper</code> 好像有点感觉了，又好像还是似懂非懂的样子，然后还看到网上都在告诉我们 <code>zookeeper</code> 的安装以及 <code>zookeeper</code> 集群的搭建，又尝试着去搭建了一遍。到最后还是有点晕乎乎的样子，总觉得好像不是很理解，包括网上说的 <code>zookeeper</code> 一些使用场景。</p>
<a id="more"></a>

<p>通过这些过程下来，我有点觉得刚开始既然不是很理解，那么就先不去理解它，不要尝试着钻牛角尖，为何不先试着在实践中动手接触它，感受它，在这之后有点感觉之后我们再去理解 <code>zookeeper</code> 背后的那些原理会不会更好一点呢？当然这只是个人看法，因人而异，如果有类似感觉的不防这样试试。那么接下来我就先说说 <code>zookeeper</code> 的安装以及搭建过程。</p>
<h2 id="zookeeper-下载解压"><a href="#zookeeper-下载解压" class="headerlink" title="zookeeper 下载解压"></a>zookeeper 下载解压</h2><p>在测试之前先说一下，zookeeper 的运行需要依赖 Java 运行环境，所以先要保证你安装好了 Java 环境。接下来下载 zookeeper 的最新稳定版 <code>zookeeper-3.4.12</code> 进行测试，下载链接如下：</p>
<p><a href="http://mirrors.shu.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz">zookeeper-3.4.12 下载链接</a></p>
<p>由于本人使用的是 Ubuntu 16.04 系统版本，所以下面的测试也是基于该系统下进行测试的，当然在 Window 系统下步骤也是一样的，只是执行的方式不一样而已。将上面下载好的文件进行解压，最好解压到你常用的安装软件目录下，以便后面查找 zookeeper 配置文件的位置，当然如果说你知道你自己所放的位置那也无所谓了，当然我还是比较推荐把我们平常开发中常用的软件单独建一个文件夹保存，这样可以让我们的电脑文件不会显得很乱，后面的查找效率也会高很多。回到正题，下面是 zookeeper 的解压命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzvf zookeeper-3.4.12.tar.gz -C &#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="zookeeper-单机搭建"><a href="#zookeeper-单机搭建" class="headerlink" title="zookeeper 单机搭建"></a>zookeeper 单机搭建</h2><p>解压好之后，记住你解压之后存放的位置，比如我上面，我存放在 /home/zhouxh/software/ 目录下面，接下来就切到该目录下的 zookeeper-3.4.12 目录下，里面有一个 conf 的目录，继续 cd 到 conf 目录下，这个目录存放的就是 zookeeper 运行时需要的配置文件，这里我们先将里面的 zoo_sample.cfg 文件拷贝一份并且重命名为 zoo.cfg，然后编辑 zoo.cfg 文件，这里我们先不说文件中的各项配置是什么含义，先照着做就可以了，到后面会详细解释，打开 zoo.cfg 文件，在里面修改 dataDir 配置然后再加上 dataLogDir 配置，该文件的全部配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">#dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper</span><br><span class="line">dataDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data</span><br><span class="line">dataLogDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;logs</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br></pre></td></tr></table></figure>

<p>上面配置文件中修改和添加的这两项配置都有一个路径，也就是刚才解压的 zookeeper 文件所在路径，在 zookeeper 的目录下创建两个文件夹：data 和 logs，创建好之后单机模式的 zookeeper 文件配置就已经配置好了，然后我们就可以运行了，为了运行方便，最好我们把 zookeeper 命令路径配置到环境变量中去，这样我们就不用每次执行都切换到 zookeeper 目录下的 bin 目录中去，如果没配那就到 zookeeper 的 bin 目录下去执行命令，启动命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>启动完成之后再执行查看 zookeeper 的运行状态的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh status</span><br></pre></td></tr></table></figure>

<p><img src="/images/zk-start.png" alt="运行结果如下"></p>
<p>也可以通过客户端命令来连接 zookeeper 服务来判断是否启动成功，如果是 zookeeper 是在本机上那么直接执行以下命令就好：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh</span><br></pre></td></tr></table></figure>
<p>如果是跨机器连接的话则需要加参数，-server 后面加上要连的服务 IP 和端口，IP 是你要连的 zookeeper 服务所在机器的 IP，端口就是刚才 zoo.cfg 中的 clientPort=2181 配置的端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure>

<p><img src="/images/zoo-cli.png" alt="运行结果如下"></p>
<p>连接成功之后我们就可以对 zookeeper 服务上的节点以及节点中的数据进行增删改查了，这里提一下，zookeeper 中的节点结构类似于 Linux 系统下的文件路径，都是树形结构。到这里单机模式的搭建就已经完了，接下来我们再尝试着搭建 zookeeper 伪集群模式。</p>
<h2 id="zookeeper-伪集群搭建"><a href="#zookeeper-伪集群搭建" class="headerlink" title="zookeeper 伪集群搭建"></a>zookeeper 伪集群搭建</h2><p>有了之前单机模式下搭建过程，伪集群其实也差不多，之所以说是伪集群，是因为是在同一台电脑上模拟出来的多台服务，这里以三台为例进行模拟搭建，当然如果你条件够宽裕，也可以直接在三台电脑上进行搭建，当然这三台电脑需要互相可访问，因为他们之间需要通信。下面是在单台电脑上搭建伪集群的过程：</p>
<p>首先我们将之前用到的 zoo.cfg 拷贝三份放在 conf 目录下，分别命名为 zoo1.cfg，zoo2.cfg，zoo3.cfg，然后分别修改这三个文件，下面我先贴出第一个服务 zoo1.cfg 的配置内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data1</span><br><span class="line">dataLogDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log1</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line">server.1&#x3D;192.168.1.108:2881:3881</span><br><span class="line">server.2&#x3D;192.168.1.108:2882:3882</span><br><span class="line">server.3&#x3D;192.168.1.108:2883:3883</span><br></pre></td></tr></table></figure>
<p>其他两个文件只需要修改其中一个客户端端口和两个路径就好，其他的和上面配置内容一致。<br>zoo2.cfg 不同部分配置内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data2</span><br><span class="line">dataLogDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log2</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2182</span><br></pre></td></tr></table></figure>
<p>zoo3.cfg 不同部分配置内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dataDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data3</span><br><span class="line">dataLogDir&#x3D;&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log3</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2183</span><br></pre></td></tr></table></figure>

<p>看了上面三个文件的配置内容，我们应该能猜到接下来我们还需要在对应路径下创建几个文件夹，分别是：data1，data2，data3 以及 log1，log2，log3，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data1</span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data2</span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;data3</span><br><span class="line"></span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log1</span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log2</span><br><span class="line">&#x2F;home&#x2F;zhouxh&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;log3</span><br></pre></td></tr></table></figure>
<p>同时我们还注意到每个配置文件都多了一小部分内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.1&#x3D;192.168.1.108:2881:3881</span><br><span class="line">server.2&#x3D;192.168.1.108:2882:3882</span><br><span class="line">server.3&#x3D;192.168.1.108:2883:3883</span><br></pre></td></tr></table></figure>
<p>这部分内容中 server 后面的那个数字是区分各个不同服务的，这个数字还需要在我们刚才新建的那三个文件夹 data1，data2，data3 下面分别新建三个文件，文件名为 myid，这个文件就只写入这个数字就好，也就是 data1 目录下的文件 myid 内容为 1，data2 目录下的文件 myid 内容为 2，data3 目录下的文件 myid 内容为 3，当然如果是三台不同的机器的话，就是把刚才创建三份的文件夹以及文件在每台机器上配置一份就好，内容可以不变，端口那些可以自己定，也可以完全按照上面的方式配置。到这里配置部分就结束了，接下来我们就可以测试我们的配置是否正确了。</p>
<p>首先我们依次将三个 zookeeper 服务分别启动起来，每启动一台查看一下当前启动的 zookeeper 的运行状态，切换到 zookeeper 的 bin 目录下进行启动，启动命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh start ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo1.cfg</span><br><span class="line">.&#x2F;zkServer.sh status ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo1.cfg</span><br></pre></td></tr></table></figure>
<p>上面将第一台 zookeeper 服务先启动，启动后紧接着查看其运行状态发现会报如下一个错。</p>
<p><img src="/images/zoo1-start.png" alt="运行结果如下"></p>
<p>这是由于其他两台还没启动，所以我们先不管，继续启动另外两台服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkServer.sh start ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo2.cfg</span><br><span class="line">.&#x2F;zkServer.sh status ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo1.cfg</span><br><span class="line"></span><br><span class="line">.&#x2F;zkServer.sh start ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo3.cfg</span><br><span class="line">.&#x2F;zkServer.sh status ~&#x2F;software&#x2F;zookeeper-3.4.12&#x2F;conf&#x2F;zoo3.cfg</span><br></pre></td></tr></table></figure>
<p>不出意外的话，当启动第二台后再查看第一台服务状态时会打印如下信息：</p>
<p><img src="/images/zoo2-start.png" alt="运行结果如下"></p>
<p>这表明我们已经启动成功了，继续启动第三台就好，当三台全部启动成功后说明我们的伪集群搭建成功了。</p>
<p>我们也可以尝试用 zkCli.sh 命令去连接这个集群看看能不能连上，由于这三台已经是集群模式，我们任意连接其中一台都是一样的，以连接第一台为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<p>出现如下信息表示连接成功:</p>
<p><img src="/images/zoo-client.png" alt="运行结果如下"></p>
<p>上面就是我们搭建的整个过程，搭建完成后最好回顾一下，如果中间遇到什么问题可以直接网上搜索，肯定能找到的，现在我们只是初步了解了 zookeeper 服务的搭建过程，具体这些配置文件中的含义以及为什么要搭建集群，为什么选择三台进行模拟集群，这样做有什么好处；还有就是 zookeeper 到底应该怎么用，哪些情况下需要用到 zookeeper，下一篇将会详细介绍。</p>
]]></content>
      <categories>
        <category>Zookeeper</category>
      </categories>
  </entry>
  <entry>
    <title>你还在习惯的使用 keys * 查看 redis 中的所有数据吗</title>
    <url>/%E4%BD%A0%E8%BF%98%E5%9C%A8%E4%B9%A0%E6%83%AF%E7%9A%84%E4%BD%BF%E7%94%A8-keys-%E6%9F%A5%E7%9C%8B-redis-%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%90%97/</url>
    <content><![CDATA[<p>redis 在我们的日常开发中其实还是用的比较多的，常用来做缓存或者存放一些热点数据，主要为了提高系统的响应速度。在我们平常使用中，我们可能都习惯的使用 keys * 命令来查询数据库中的数据存储情况。</p>
<a id="more"></a>
<p>这时也许我们都是在开发环境执行，开发环境 redis 中的数据量不是很多，redis 也很快的能给我们响应。但是如果你要查询的 redis 中存储了非常大的数据量，这时候你还能愉快的使用这个命令吗？</p>
<p>首先，我们来大概了解下 keys 命令是用来干嘛的，它是用来查找所有符合给定模式 pattern 的 key ，上面的 * 表示匹配所有数据，同时还有下面几种用法:</p>
<ul>
<li>keys re?is 匹配 redis，recis</li>
<li>keys re*is 匹配 redis, reddddis</li>
<li>keys re[cd]is 匹配 redis，recis，不匹配 reais，reddis</li>
</ul>
<p>keys 命令的时间复杂度是 O(N)，N 是 redis 库中的数据量，也就是说这个命令的执行时间是随着库中的数据量增多呈正比的，数据量越大，执行时间越长。所以尽管这个命令的速度很快，但如果是一个数据量很大的库，还是会造成性能问题的。</p>
<p>我之前就在一次项目上线演练时，当时在一个 redis 库中初始化一批数据，当时我为了验证数据库中是否已经初始化过了这些数据，我顺手就敲了一个 keys abc*，其中 abc 是我要初始化的这批数据的 key 前缀(当然不是真的就是 abc，这里是随便起的一个)。</p>
<p>然后并没有像往常开发中一样很快给我响应，我立马就意识到不对了，这个 redis 库数据量很大，不能使用 keys 命令去查询，我随即立马按下 command + c 尝试终止，但其实已经没什么用了，因为 redis 已经在执行我刚才发送的命令，终端已经没响应，我记得我我当时还索性把终端都给关了，这纯属病急乱投医了。</p>
<p>随后呢我另起一个终端，尝试连接 redis，看看刚才的命令是否执行完了，但不幸的是我连都连不上，连接命令敲完没反应，当时这会心里真的慌了。</p>
<p>不过幸运的是这只是一次新系统正式上线前的演练，而且并没有用户在使用。至于为什么没有用户在用怎么有这么多数据在里面，那是因为在我初始化我这批数据之前，我同事已经将老系统中的数据迁移过来了。</p>
<p>但我还是很慌的原因是我具体不知道老系统迁移过来有多少数据，只知道数据量很大，不知道要执行多久。然后虽然说那只是新系统正式上线前一次演练而已，但是我们这次上线是有很多流程，所以才有了这次演练。</p>
<p>对于流程中的每个环节都要记录操作时间，下次正式上线时需要按之前演练上线的流程来执行，正式上线时如果某一环节出问题了，就要采取回滚流程进行回滚，下次上线要是因为我这个数据初始化环节出问题了，那这锅岂不背定了。</p>
<p>所以说当时真的是慌的一匹，但最后还是过了两三分钟之后我重新连上了，此时应该是将我刚才的命令执行完了，随后我也不管里面是不是已经初始化了，直接初始化数据，大不了覆盖好了，反正 key 是相同的，因为这部分数据只有我的程序要用到，所以没什么问题。后面正式上线时有了演练的教训，也就没有出啥问题，也没有再作死去敲 keys 命令了。</p>
<p>如果我们真的要在大数据量的 redis 库中查询匹配的数据怎么办呢？其实 redis 是有相应的替代命令的，就是 scan 命令，以及对应的数据类型的 sscan，hscan 和 zscan，他们都用于增量地迭代库中的元素。</p>
<ul>
<li>scan 命令用于迭代当前库中的所有 key</li>
<li>sscan 命令用于迭代集合键中的元素</li>
<li>hscan 命令用于哈希键中的键值对</li>
<li>zscan 命令用于迭代有序集合中的元素(包括元素成员和元素分值)</li>
</ul>
<p>上面的命令都是支持增量式迭代，每次执行都只会返回少量元素，这些命令每次执行的时间复杂度是 O(1)，完整的一次迭代过程才是 O(N)，因此它是可以在生产环境中执行的，而不会像 keys 命令一样，如果正在处理的是一个大数据量的库，会阻塞 redis 服务很久。</p>
<p>scan 命令它是一个基于游标的迭代器(cursor based iterator)，scan 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 scan 命令的游标参数， 以此来延续之前的迭代过程。当 scan 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示一次完整的迭代过程结束。</p>
<p>scan 命令是迭代库中所有的 key，基本使用方式是: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count] </span><br></pre></td></tr></table></figure>

<p>而 sscan 命令、 hscan 命令和 zscan 命令的第一个参数是一个数据库键:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SSCAN/HSCAN/ZSCAN key cursor [MATCH pattern] [COUNT count] </span><br></pre></td></tr></table></figure>

<p>cursor 就是游标参数，初始我们可以设置 0，开始一次迭代过程，一次迭代后的返回值作为下次迭代的游标值，当我们看到 redis 的返回值是 0 时，意味着完整的迭代过程结束。</p>
<p>看到这里你应该能发现，如果在迭代的中间过程中，redis 的数据发生了变化，那么我们得到的数据可能是不正确的，这是无法得到保证的。</p>
<p>而 scan 命令只会给我们保证在整个遍历过程中，一直存在于数据集中的元素都会被遍历返回，也就是说，如果一个元素如果在遍历开始到结束都存在于要遍历的数据集中，那么这个元素肯定会在某一次迭代过程中得到返回。</p>
<p>后面两个中括号中的参数是可选的，可通过 match 来指定只返回匹配对应模式的元素，而 count 可以指定每次迭代返回的元素最大数量，默认值是 10。</p>
<p>但要注意虽然指定了返回的元素最大数量，这个 count 参数只是用户给 scan 迭代命令的一种提示，尽管这种提示在很多情况下是有效的，但也要注意不一定每次都是返回指定的数量，有可能会比指定的要多一些。</p>
<p>对于 scan 以及其相关的 sscan，hscan，zscan 命令都会返回两个元素，第一个元素是下次迭代的初始游标，第二个元素是本次迭代返回的结果。</p>
<ul>
<li>scan 得到的结果是库中键元素 key</li>
<li>sscan 得到的结果是集合中的成员</li>
<li>hscan 得到的结果是键值对</li>
<li>zscan 得到的结果是有序元素集合，集合中元素由一个成员和一个分值组成。</li>
</ul>
<p>上面就是 scan 命令的大体介绍，我是觉得这个命令其实很适合清理 redis 中无效数据，通过 scan 命令扫一遍 redis 库，很容易就做到数据清理的工作。</p>
<p>后来想想那次小事故其实就是因为自己平时用 keys 命令用习惯了，也没多想不假思索随手就敲下去了。所以说我们在日常 redis 的使用中，不能只是简单的就想也不想的就直接 keys 命令敲下去，长期以往会出事故的，我还好不是在线上使用的系统中执行的这个命令，不然后果真的很严重。</p>
<p>试想如果是在线上，在 redis 阻塞的那段时间，系统的访问请求继续打到 redis 服务器上，导致 redis 服务器 CPU 直接飙涨，很有可能服务器就直接宕机了，再进一步的话，程序无法从 redis 中获取数据，所有的请求都直接一下全到数据库去了，也有可能造成数据库直接挂了。</p>
<p>所以说我们应该养成这样的习惯，在需要用 keys 查询 redis 中的数据时，脑海里先确认下当时的环境以及库中的数据量大小。</p>
<p>当然 redis 不仅仅是只有 keys 这一个比较危险的命令，还有 hgetall，lrange，smembers，zrange 等命令，这些命令的时间复杂度都是 O(N)，使用这些命令都需要注意 N 的大小。当然其实线上对于 keys，flushdb，flushall 这几个命令最好是通过配置文件 redis.conf 来直接禁用它，以防万一。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Docker 运行 MySQL 服务</title>
    <url>/%E4%BD%BF%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-MySQL-%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>对于 MySQL 数据库，我们基本上都用得到，在工作上有些情况下不太想连云上的库，比如说网络比较慢，或者我们只是刚开始开发，还没来得及在云上建立数据库，这时候在本地跑一下 MySQL 服务也许比较方便，但是呢 MySQL 安装下来占的内存还是比较大的，像我们不是经常连本地的库开发的在本地电脑安装一个 MySQL 确实有点浪费空间了，再加上可能本来笔记本电脑内存就不是非常富余的情况下再去安装，实在是有些肉疼。</p>
<a id="more"></a>

<p>这时候我们就可以通过 Docker 启动一个 MySQL 容器来运行 MySQL 服务，在我们需要的时候启动容器就好，不需要的时候直接关了，这样就不用在本机上安装 MySQL，而且在需要别的软件的时候也可以通过 Docker 启动容器的方式去运行，这样我们自己的电脑就会看起来非常清爽，不会有各种软件充斥着你的电脑，专注我们正在做的事情。</p>
<p>首先，我们需要在本地安装 Docker，Docker 的安装很简单，可以在这里 <a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a> 下载对应系统的 Docker 软件进行安装，安装完毕之后，就可以从 Docker Hub 上拉取相应的镜像了。Docker Hub 网站是 Docker 提供的一项服务，主要用于查找和共享容器镜像，有点类似于 GitHub，不同的是 GitHub 维护的主要是代码，而 Docker Hub 维护的是主要是容器镜像。<br>声明: 由于我本地环境是 Mac 环境，下面命令和软件都是基于 Mac 下运行的。<br>安装好了之后可以在终端运行下面的命令看看是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>

<p>如果打印出了 Docker 的版本信息就可以了。接下来继续执行 docker images 命令查看本地有哪些镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>如果刚安装，之前没有从网站拉过镜像的话，打印出来的镜像应该是空的，我这里是已经拉过一些镜像了。由于我们要运行 MySQL，我们需要从 Docker Hub 上拉取 mysql-server 镜像, 执行一下命令拉取 mysql-server 的最新版镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql/mysql-server</span><br></pre></td></tr></table></figure>

<p>这时候如果你们没有配置镜像源地址的话，默认是国外的地址，会觉得很慢，这个我们可以通过配置国内的镜像源来解决。<br>打开 preferences -&gt; Docker Engine， 在右边配置框里面加上国内镜像源的配置，然后 Apply &amp; Restart ，待重启完毕后，可以执行下面的 docker info 命令验证是否添加成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>上面的第一行是我在阿里云里面申请的一个镜像地址，这个自己注册了阿里云账号的话也可以去申请一个，后面两个分别是国内的科大和网易的镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https://docker.mirrors.ustc.edu.cn/</span><br><span class="line">https://hub-mirror.c.163.com/</span><br></pre></td></tr></table></figure>

<p>添加成功之后再去终端执行 docker pull mysql/mysql-serve 命令会感觉拉取速度快了许多。待镜像下载完毕之后就可以根据镜像来启动容器了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3307:3306 --name mysql-service mysql/mysql-server</span><br></pre></td></tr></table></figure>

<p>执行完命令之后，如果执行成功应该会有很长一串的 ID 打印出来，这是启动的容器 ID，后期可以通过这个 ID 来对容器执行启动，停止，重启，删除，查看日志，进入容器等一些列操作。我们可以通过 docker ps 命令来查看本地正在运行的容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>可以看到 STATUS 那一栏，health 状态处于 starting 状态，待状态变成 healthy 之后，说明容器启动完成，接下来就可以使用了，不过我们是不是还不知道 mysql 的 root 连接密码，我们需要通过查看容器的启动日志得到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs 1d0da81a71ec 2&gt;&amp;1 | grep GENERATED</span><br></pre></td></tr></table></figure>

<p>执行命令之后可以看到容器启动的日志中生成了一个密码，不过这个密码只是一个临时的密码，通过这个密码连接到数据库之后，还是需要修改密码之后才能继续操作数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 1d0da81a71ec mysql -uroot -p</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;root&#x27;;</span><br></pre></td></tr></table></figure>

<p>上面我们是通过进入到容器内执行 mysql 命令连接 MySQL 服务，如果想要在宿主机上连接容器内的 MySQL 服务，首先需要配置 root 用户能够通过 IP 进行远程连接，连上数据库修改 root 用户的 host 字段。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select user, host from mysql.user;</span><br><span class="line">update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>修改成功之后就可以在宿主机上通过 IP 以及映射到宿主机的端口号连接容器内的 MySQL 数据库了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3307 -uroot -p</span><br></pre></td></tr></table></figure>

<p>到这里我们发现有个问题就是，每次启动之后需要查看日志获取密码，其实我们可以通过参数 -e MYSQL_ROOT_PASSWORD=password 来指定 root 用户的密码，这样我们就不用启动后再去查看日志获取密码，以及需要修改密码之后才能继续操作数据库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root --name mysql-service mysql/mysql-server</span><br></pre></td></tr></table></figure>

<p>这时候如果我们使用完了停掉了容器或者删除了容器，下次如果还想启动，就会发现之前创建的数据库结构都没了，我们又得重新执行一遍数据库的创建脚本，再次构造数据，如果一次两次还好，如果经常要用的话，每次都这样做的话就显得太傻了。</p>
<p>有一种办法就是我们把容器内的保存数据的目录挂载到宿主机上，这样就可以避免容器删除了，容器内的数据也随着没了，只要在启动的时候加上 -v 参数指定要挂载的目录即可，这里注意我在末尾添加的 mysqld –lower_case_table_name=0 这一串参数，这是我在挂载数据目录后运行报错了，应该是跟我的目录包含大写字母的目录有关，和配置文件里面指定的不一样，需要加上后面那一串指定 mysql 区分表名大小写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -v /Users/zhouxh/docker/mysql/data:/var/lib/mysql --name mysql-container mysql/mysql-server mysqld --lower_case_table_names=0</span><br></pre></td></tr></table></figure>

<p>这样执行完之后再连上数据库创建的数据库表结构就会保存到宿主机上，不会随着容器的销毁而销毁。这样就实现了在我们想要连本地库时，启动容器即可，不想用了，停止或者删除容器都没关系，库里面的数据都已经保存在宿主机上了，下次启动时只要挂载对应的目录即可。</p>
<p>到这里，就基本上实现了通过 Docker 来运行 MySQL 服务的功能了，和本地安装一个 MySQL 使用的区别不是很大，并且也很方便。类似的，nginx 服务，各种队列(rabbitMq，rocketMq，kafka)，或者我们只是想做一个临时的测试，需要用到某个环境，我们都可以通过指定相应环境的镜像来启动容器的方式来做。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>使用 JdbcTemplate 的 queryForObject 方法时需注意的地方(二)</title>
    <url>/%E4%BD%BF%E7%94%A8-JdbcTemplate-%E7%9A%84-queryForObject-%E6%96%B9%E6%B3%95%E6%97%B6%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9-%E4%BA%8C/</url>
    <content><![CDATA[<p>上一篇文章中提到了 JdbcTemplate 的 queryForObject 方法在使用时需要注意的地方，其实这里还有一个地方也是我们在使用时容易忽略的，为了避免踩坑，这里我也一并提出来。</p>
<p>同样的，继续用活动的状态表来举例，在上次的例子中我们是通过活动 id 查询活动的浏览量这一列数据，但是如果我们想要一并查出活动的浏览量，作品数和用户数。先让我们同样使用 queryForObject 方法，然后把 SQL 改成查询所有列的数据,返回类型改成实体类。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">findByActivityId</span><span class="params">(String activityId)</span> </span>&#123;</span><br><span class="line">   String selectSql = <span class="string">&quot;select * from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">   ActivityStat activityStat = <span class="keyword">this</span>.jdbcTemplate.queryForObject(selectSql, ActivityStat.class,</span><br><span class="line">            activityId);</span><br><span class="line">   <span class="keyword">return</span> timesViewed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行之后会发现报错了，错误信息如下:</p>
<p><img src="/images/execute_error.png" alt="execute error"></p>
<p>从字面意思看是提示查询结果列的数量不正确，期望值是 1，但实际是 4。</p>
<p>是不是感觉有点奇怪，看代码好像也没啥问题，我们找到报错的位置看看为什么会出现这种结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        <span class="keyword">int</span> nrOfColumns = rsmd.getColumnCount();</span><br><span class="line">        <span class="keyword">if</span> (nrOfColumns != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectResultSetColumnCountException(<span class="number">1</span>, nrOfColumns);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object result = <span class="keyword">this</span>.getColumnValue(rs, <span class="number">1</span>, <span class="keyword">this</span>.requiredType);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.requiredType != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.requiredType.isInstance(result)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.convertValueToRequiredType(result, <span class="keyword">this</span>.requiredType);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var7) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TypeMismatchDataAccessException(<span class="string">&quot;Type mismatch affecting row number &quot;</span> + rowNum + <span class="string">&quot; and column type &#x27;&quot;</span> + rsmd.getColumnTypeName(<span class="number">1</span>) + <span class="string">&quot;&#x27;: &quot;</span> + var7.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以看到在将结果集映射到我们指定的实体类型的时候有个对结果集的 column count 的判断，当 column count 不等于 1 的时候就会抛出 IncorrectResultSetColumnCountException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">queryForObject</span><span class="params">(String sql, Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.queryForObject(sql, args, <span class="keyword">this</span>.getSingleColumnRowMapper(requiredType));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实从 queryForObject 方法的方法体也可以看出，里面调用了一个叫 getSingleColumnRowMapper 的方法，然后将我们指定的返回数据类型传进去，而方法的名字就是体现了方法的含义，返回一个单列的 row mapper。也就是 SingleColumnRowMapper 这个类，它实现了 RowMapper 接口，实现了接口里面的 mapRow 方法，也就是上面我们看到的报错的地方。</p>
<p>这时我们应该可以知道对于 queryForObject 方法当我们指定返回值类型的时候，它只适合用来查单列结果，也就是类似于下面的 SQL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select column1 from table;</span><br><span class="line">select count(*) from table;</span><br></pre></td></tr></table></figure>

<p> 再回到 queryForObject 方法，间接也说明我们设置返回类型的时候只能指定基本数据类型，而不能指定我们自定义的复杂数据类型。</p>
<p> 但如果我们依然需要查询结果并返回我们自定义的数据类型的时候，我们可以使用 queryForObject 重载的方法，自定义 RowMapper，自己实现 mapRow 方法，在方法里面取出结果映射到实体类就可以了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityStat <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;select * from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> Object[]&#123;id&#125;, (rs, i) -&gt; &#123;</span><br><span class="line">            ActivityStat activityStat = <span class="keyword">new</span> ActivityStat();</span><br><span class="line">            activityStat.setActivityId(rs.getLong(<span class="string">&quot;activity_id&quot;</span>));</span><br><span class="line">            activityStat.setTimesViewed(rs.getLong(<span class="string">&quot;times_viewed&quot;</span>));</span><br><span class="line">            activityStat.setWorksCount(rs.getLong(<span class="string">&quot;works_count&quot;</span>));</span><br><span class="line">            activityStat.setUserCount(rs.getLong(<span class="string">&quot;user_count&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> activityStat;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里其实就是一个坑，稍不注意就会觉得代码好像也没啥问题，怎么会报错呢，同样的对于 queryForList 方法也会有这个问题，如果我们使用指定返回类型的话也是只能查询单列结果，需要返回多列时也需要我们自定义 RowMapper，感兴趣的可以自己去试试看。</p>
]]></content>
      <categories>
        <category>JdbcTemplate</category>
      </categories>
  </entry>
  <entry>
    <title>使用 JdbcTemplate 的 queryForObject 方法时需注意的地方(一)</title>
    <url>/%E4%BD%BF%E7%94%A8-JdbcTemplate-%E7%9A%84-queryForObject-%E6%96%B9%E6%B3%95%E6%97%B6%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
    <content><![CDATA[<p>我们应该都使用过 JdbcTemplate 来查询数据库，一般用在配置了多数据源的情况下，在一个服务里面需要简单查询多个数据库的数据，这时通过 JdbcTemplate 来构建 SQL 查询数据库往往比较方便快捷些，不需要用封装的 repository 那一套东西。</p>
<p>举一个简单的例子，比如查询一个活动的浏览量。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">findByActivityId</span><span class="params">(String activityId)</span> </span>&#123;</span><br><span class="line">   String selectSql = <span class="string">&quot;select times_viewed from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">   Long timesViewed = <span class="keyword">this</span>.jdbcTemplate.queryForObject(selectSql, Long.class,</span><br><span class="line">            activityId);</span><br><span class="line">   <span class="keyword">return</span> timesViewed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实我们咋一看上面这段代码，好像也没多大问题，只是一个普通的查询而已。在有数据的情况下，经过测试，程序也运行正常。但是如果你把你要查询的那个活动 id 的那条数据删除，这时再去测试会发现程序抛异常了，抛的异常类是 EmptyResultDataAccessException，从类的名字我们就可以看出，查询结果为空异常。</p>
<p>这里为什么会产生这种情况呢，我们深入查看下源码就知道了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">queryForObject</span><span class="params">(String sql, SqlParameterSource paramSource, RowMapper&lt;T&gt; rowMapper)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;T&gt; results = getJdbcOperations().query(getPreparedStatementCreator(sql, paramSource), rowMapper);</span><br><span class="line">        <span class="keyword">return</span> DataAccessUtils.nullableSingleResult(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们点进去查看 queryForObject 的方法体可以看到，在返回查询结果前调用了 DataAccessUtils 类的 nullableSingleResult 方法，那么再继续点进去查看 nullableSingleResult 的方法体:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">nullableSingleResult</span><span class="params">(<span class="meta">@Nullable</span> Collection&lt;T&gt; results)</span> <span class="keyword">throws</span> IncorrectResultSizeDataAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(results)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyResultDataAccessException(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (results.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectResultSizeDataAccessException(<span class="number">1</span>, results.size());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> results.iterator().next();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 nullableSingleResult 的方法体中可以看到，当查询的结果为空的时候，手动抛了一个 EmptyResultDataAccessException 异常，同时我们还可以看到当查询结果记录数大于 1 时，手动抛了一个 IncorrectResultSizeDataAccessException 异常，这时候我们就要注意了，如果当前我们要执行的 SQL 的查询结果可能为空，或者结果集可能大于 1 时就需要根据我们的业务需求来进行手动处理这两个异常，不然程序会由于异常无法进行下去。</p>
<p>在这里个人觉得结果大于 1 的情况抛出异常还能理解，但是结果为空，其实在很多情况下我们都是希望代码正常运行下去，而不是直接抛出异常，有可能我们还有别的业务需要执行。所以不太清楚这里为什么需要做这个处理。</p>
<p>对于结果为空时抛出异常的情况，处理方式也很简单，在调用 queryForObject 方法的地方用 try catch 包起来，对 EmptyResultDataAccessException 异常进行捕获，同时忽略异常信息就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">queryByActivityId</span><span class="params">(String activityId)</span> </span>&#123;</span><br><span class="line">    String selectSql = <span class="string">&quot;select times_viewed from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">    Long timesViewed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        timesViewed = <span class="keyword">this</span>.jdbcTemplate.queryForObject(selectSql, Long.class,</span><br><span class="line">                activityId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (EmptyResultDataAccessException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> timesViewed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，如果对结果集可能大于 1 的情况也要特殊处理的话，我们就直接捕获 IncorrectResultSizeDataAccessException 异常就好，因为你可以看到 EmptyResultDataAccessException 是继承 IncorrectResultSizeDataAccessException 的。所以就直接捕获 IncorrectResultSizeDataAccessException 就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">queryByActivityId</span><span class="params">(String activityId)</span> </span>&#123;</span><br><span class="line">    String selectSql = <span class="string">&quot;select times_viewed from activity_stats where activity_id = ?&quot;</span>;</span><br><span class="line">    Long timesViewed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        timesViewed = <span class="keyword">this</span>.jdbcTemplate.queryForObject(selectSql, Long.class,</span><br><span class="line">                activityId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IncorrectResultSizeDataAccessException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> timesViewed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里再提下 JdbcTemplate 和 NamedParmeterJdbcTemplate 的主要区别:<br>对于 JdbcTemplate，sql 的查询条件参数是使用占位符 ? 表示，受到了顺序的限制，如果是需要多个参数，在传入数组参数的时候，必须按照占位符的顺序传入参数，一旦传入的顺序错误就可能会造成非预期的结果。</p>
<p>而 NamedParmeterJdbcTemplate，在 sprintJdbc 框架中，通过这个 NameParameterJdbcTemplate 使用具名参数的方式来绑定 Sql 参数。具名参数的格式为 “ :parameterName”，多个具名参数通过 Map key value 的方式传入，key 和 parameterName 保持一致，这种情况下就和参数的顺序没有关系了，主要是通过 Map 的 key 来取值。</p>
]]></content>
      <categories>
        <category>JdbcTemplate</category>
      </categories>
  </entry>
  <entry>
    <title>关于批量插入的数据重复问题</title>
    <url>/%E5%85%B3%E4%BA%8E%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在上一篇文章中我们谈到了数据库批量插入，如果你已经亲自实践过了的话你会发现有个问题，就是我们在第一次执行完测试之后，再次执行的话会报错，除非你删掉数据库中的数据再执行。</p>
<p>那是因为 activity_stats 表中 activity_id 是表的主键，第二次执行的话就会因为主键重复而报错了，当然你也可以选择去掉这个主键的限制来进行测试。</p>
<a id="more"></a>

<p>但真正在项目中可就不能这么做了，项目中我们可能就是想要 activity_id 字段作为主键，不允许插入重复数据。</p>
<p>虽然说一般情况下不会有重复的，但毕竟是一般情况下，对于特殊情况我们也是需要考虑的。比如说 excel 中就是因为运营人员粗心弄了多条相同的数据，或者再次将同样的 excel 文件拿来上传，这时候就会有问题了。</p>
<p>所以对于这种情况我们需要做到兼容，尽量给用户好的体验，不然说因为几条重复的数据就让用户去修改再次上传。对于这种普通的数据，可能就需要系统自动去重了，当然如果是涉及到金钱方面的数据那还是需要人工再次确认过的。</p>
<p>下面我们就讨论下 key 重复的几种不同处理方式:<br>1.忽略重复 key 的数据，由于主键或者唯一键重复的记录，数据库自动忽略，在 insert 后面加上 ignore 关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> activity_stats (activity_id, times_viewed, works_count, user_count)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>上面的 SQL 执行时，如果主键重复或者唯一键重复，会忽略掉新插入的数据，受影响行数为0，表数据不变，这是比较简单暴力的方式，但对于大部分情况下都是适用的，具体看业务情况而定。</p>
<p>2.使用最新数据，<br>对于 key 重复的数据，我们希望插入最新的数据到数据库中。要做到这个有两种方式: 一种是对重复数据进行更新，另一种是先删掉旧数据，然后再插入新数据。</p>
<p>先看第一种: ON DUPLICATE KEY UPDATE</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> activity_stats (activity_id, times_viewed, works_count, user_count)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DUPLICATE</span> <span class="keyword">KEY</span> </span><br><span class="line"><span class="keyword">UPDATE</span> times_viewed = <span class="keyword">values</span>(times_viewed), works_count = <span class="keyword">values</span>(works_count), user_count = <span class="keyword">values</span>(user_count);</span><br></pre></td></tr></table></figure>
<p>这种方式就是对于有重复的数据采取更新操作，要更新的字段跟在 UPDATE 关键字后面。</p>
<p>这里要注意一个受影响的行数的问题:</p>
<ul>
<li>没有重复 key 数据，直接插入新数据，受影响的行数为 1。</li>
<li>有重复 key 数据并且要更新的新数据和已经存在的旧数据不一样，受影响的行数为 2(???)，这里可能有点不好理解为什么是 2，这里我们先暂时记下是 2，待会我会详细说明。</li>
<li>有重复 key 数据并且要更新的新数据和已经存在的旧数据一致，受影响的行数为 1(???)，这个可能也不是很好理解，同样暂时先记下，马上为你娓娓道来。</li>
</ul>
<p>好了，现在看上面有两个地方打上了问号，这两个地方都是和我们正常所想的有点不一样。先看第一个打了问号的地方，也就是上面的第二点，按我们所想，key 重复，然后进行数据更新，这里只是进行了更新操作，受影响的行数应该是 1 才对，刚开始我对这个也是不太理解，后来通过查资料发现在 MySQL 的文档中关于 ON DUPLICATE KEY UPDATE 的使用中有下面这样一句话:<br>文档链接:<br><a href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html">https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if the row is inserted as a new row, 2 if an existing row is updated, and 0 if an existing row is set to its current values.If you specify the CLIENT_FOUND_ROWS flag to the mysql_real_connect() C API function when connecting to mysqld, the affected-rows value is 1 (not 0) if an existing row is set to its current values.</span><br></pre></td></tr></table></figure>

<p>上面这句话前半句就能为我解答为什么我们在第二点中提到的疑惑，前半句的大概意思就是:<br>对于 ON DUPLICATE KEY UPDATE 的使用，如果没有 key 重复的新数据插入，每行受影响的行数是 1，如果有 key 重复的新数据更新，返回受影响的行数是 2，如果有 key 重复的数据并且存在的旧数据和要更新的数据一致，受影响的行数是 0。</p>
<p>看到这里我们应该就能明白为什么受影响的行数是 2 了，我们可以理解为是 MySQL 为了在 ON DUPLICATE KEY UPDATE 的使用中区分插入和更新，所以对于插入返回 1，更新返回 2。</p>
<p>但是不是说 “如果是有 key 重复的数据并且存在的旧数据和要更新的数据一致，受影响的行数是 0” 吗？可是我们在上面第三点中 MySQL 返回的受影响的行数是 1，而这也正是我们第三点所疑惑的地方，我们再去看上面那句话的后半句，大概意思是:<br>在连接 mysqld 的时候如果你为 mysql_real_connect() API 函数指定了 CLIENT_FOUND_ROWS 标志，那么对于已经存在的旧数据和要更新的数据一致时，受影响的数值为 1 而不是 0。</p>
<p>对于第二个疑问，我们也大概明白为什么受影响的行数是 1 了，是因为我们使用的 MySQL 指定了 CLIENT_FOUND_ROWS 标志，而 mysql_real_connect 函数指定 CLIENT_FOUND_ROWS 标志的意思就是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLIENT_FOUND_ROWS: Return the number of found (matched) rows, not the number of changed rows.</span><br></pre></td></tr></table></figure>
<p>这段文字在上面文档链接中可以点击 mysql_real_connect 跳转到对 mysql_real_connect 函数的描述页面，里面有 CLIENT_FOUND_ROWS 相应介绍。感兴趣的可以去研究研究。</p>
<hr>
<p>再回到使用最新数据方式上，上面已经描述了对 key 重复的数据进行更新的方式，接下来我们看第二种:<br>对于 key 重复，先删掉旧数据，然后再插入新数据:  REPLACE INTO </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> activity_stats (activity_id, times_viewed, works_count, user_count)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>这种方式就是如果没有重复 key，直接插入，效果和 insert into 一样，但如果有重复 key，它会先删除旧数据，再插入新数据。同样这种方式受影响的行数也有以下几种情况:</p>
<ul>
<li>没有重复 key 数据，直接插入新数据，受影响的行数为 1。</li>
<li>有重复 key 数据并且要更新的新数据和已经存在的旧数据不一样，受影响的行数为 2。这个很好理解，先删除旧数据，然后再插入新数据，所以受影响的行数为 2。</li>
<li>有重复 key 数据并且要更新的新数据和已经存在的旧数据一致，受影响的行数为 1。这里应该是数据没有发生变化，至于返回 1，我的理解是和上面一样的，返回匹配到的行数，并不是发生改变的行数(暂时没找到有关文档描述)。</li>
</ul>
<p>关于重复 key 数据的处理方式主要有上面提到的三种，忽略重复数据的 INSERT IGNORE，使用更新的方式插入最新数据的 ON DUPLICATE KEY UPDATE，还有先删除再插入最新数据的 REPLACE INTO。</p>
<p>在我们使用这三种方式来避免插入重复数据的过程中，我们还需要注意下面几个问题:<br>首先，使用这三种方式的前提都是表中需要存在主键冲突或唯一键冲突，不然这三种都跟直接 INSERT INTO 没什么区别。</p>
<p>第二，要注意存在多个键冲突(插入的数据既可能存在主键冲突，也可能存在其他唯一键冲突或者存在多个唯一键冲突)的情况，在这种情况下使用可能会出现其他结果(可以自己测试看看)，所以这种情况下不太建议使用。</p>
<p>第三，这点比较重要，上面我的 activity_stats 表是有一个 activity_id 字段作为主键，这是存在主键冲突的情况。但如果我把 activity_id 字段改成唯一键并且新增一个字段 id 作为主键自增长，插入语句不变，这里因为 id 是自增长的，不存在冲突，所以这里是满足单一键冲突的情况，但是这里有个坑要注意，这种情况下使用上面三种方式都会产生主键 id 自增长不连续的问题。</p>
<p>目前的 SQL 语句是这样的: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> activity_stat (<span class="keyword">id</span>, activity_id, times_viewed, works_count, user_count)</span><br><span class="line"><span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">或者</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于 INSERT IGNORE 和 ON DUPLICATE KEY UPDATE，在存在 unique key 重复时，前者虽然重复的记录被忽略了没有执行插入操作，但是 id 还是会 +1。而后者是在 key 重复时执行更新操作，但 id 同样也会 +1，也就是说在存在 unique key 重复的情况下这两种方式不管有没有插入数据，自增长 id 都会增加。</p>
<p>这样的话在主从库的场景下就会出现主从的 auto_increment 不一致，因为 slave 并不会同步 master 的 auto_increment，一旦当前 master 挂了，任意一个 slave 被选举为 master，再次执行 insert 语句就可能导致主键冲突。</p>
<p>至于这里为什么会出现没有插入记录 auto_increment 却依然 +1 的情况，和 innodb_autoinc_lock_mode 的值有关。可以通过下面的 SQL 语句查看:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@innodb_autoinc_lock_mode;</span><br></pre></td></tr></table></figure>

<p>它的值可能是 0，1，2 其中一种，默认是 1，具体各个值的特征可以参看官方文档中的描述，下面是文档地址:<br><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-modes">https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html#innodb-auto-increment-lock-modes</a></p>
<p>而对于 REPLACE INTO，那是因为在存在 unique key 重复时，会先删除再插入，执行了插入操作，id 肯定会增加。问题就在于重新插入了一条数据 id 发生了变化。如果别的表关联了这个表的主键 id 的话就会出现数据查找不到的情况。</p>
<p>总之就是对于这三种避免插入重复数据的方式，如果是由于主键冲突的情况，基本上没什么问题，但如果是唯一键冲突的情况，都会导致 master 和 slave 的 auto_increment 不一致的问题，一旦主从的 auto_increment 不一致(这里是 master 的 auto_increment 要大于 slave)，只要 master 出现问题，任意一个 slave 升级成 master，由于当前新的 master 的 auto_increment 是小于数据中的 id 的值，所以再进行插入时就可能发生主键冲突。</p>
]]></content>
      <categories>
        <category>JdbcTemplate</category>
      </categories>
  </entry>
  <entry>
    <title>如何通过 Redis 来实现消息延迟队列</title>
    <url>/%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-Redis-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>延迟队列或许大家都听过，可能也用过，一种比较常见的应用场景就是用户下单后，超过 10 分钟未支付将用户订单取消，这种其实就可以通过延迟队列来实现，这里先不考虑订单数量特别大的情况。大概流程就是用户下单后，订单服务创建订单保存后同时将这笔订单信息放入延迟队列中，设置延迟时间为 10 分钟，10 分钟后从队列中取出来判断支付状态，未支付则将这笔订单取消。</p>
<a id="more"></a>

<p>实现延迟队列的方式或许有很多种，如果用 redis 来实现一个延迟队列功能应该怎么做呢，主要是通过 redis 里面的 Zset 集合来实现，Zset 自带的 score 值排序特性就非常适合用来做时间戳排序，当消息的时间戳值小于等于当前时间戳，将该消息取出来进行消费，执行相应的业务逻辑。</p>
<p>实现原理大致如下：</p>
<p>主要分为三大块，生产者，调度器，消费者，生产者负责往 redis 里面生产消息，调度器定时从 Zset 中取出已经到了执行时间的消息并移到 List 集合中，同时消费者负责不断将 List 集合中的消息取出来进行消费。</p>
<ul>
<li>Producer<ol>
<li>首先将消息原始内容保存到 redis 中，key，val 结构，key 是消息体的唯一标识，val 是消息体内容</li>
<li>将消息 key 根据延迟时间设置对应 score 值添加到 Zset 有序集合中，key 为消息体 topic，score 为当前时间戳加上延迟时间，member 为消息 key</li>
</ol>
</li>
<li>Broker<ol>
<li>定时遍历所有 topic，从 Zset 有序集合中通过 zrangebyscore 命令取出每个 topic 下 score 值小于等于当前时间戳的消息 key</li>
<li>将取出来的消息 key push 放入已经就绪可消费的消息 List 集合中</li>
</ol>
</li>
<li>Consumer<ol>
<li>定时遍历所有消息就绪的 topic，取出每个 topic 下可消费的消息 key</li>
<li>根据消息 key 从 redis 中取出消息体内容，执行相应业务逻辑</li>
</ol>
</li>
</ul>
<p>存储结构设计：</p>
<ul>
<li>消息内容存储: (key，val) 结构，例：(msgId1, msgBody)</li>
<li>zset 消息 key 存储：(key, score, member)，例：(topic1，time，msgId1)</li>
<li>List 集合消息 key 存储：(key，[value…])，例：(topic1，[msgId1，msgId2])</li>
</ul>
<p>上面 Zset 和 List 里面的消息根据不同 topic 作为 key 进行存储，这样可以避免将所有消息都放到一个 topic 下，当消息量比较多的时候出现 redis 里面的大 key 问题，导致存储和查询性能降低。</p>
<p>核心流程图如下：</p>
<p><img src="/images/redis_delay_queue.png" alt="redisDelayQueue"></p>
<p>redis 实现延迟队列的优缺点：</p>
<ul>
<li>优点<ol>
<li>消息存储在内存中，存储查询速度都比较快</li>
<li>对于一些简单的应用场景，redis 实现的延迟队列足够轻量，也基本能够符合业务需求</li>
</ol>
</li>
<li>缺点<ol>
<li>由于消息是存储在内存中，因此一旦服务器宕机，存在丢失数据的可能性，尽管 redis 具备持久化的功能，但要做到消息完全不丢失，那么 redis 的持久化策略就需要配置的更严格，但随之带来的就是性能的降低</li>
<li>消息的 Ack 机制缺失，如果要做到严格的 Ack 功能，则需要通过业务代码来实现，但随之带来的也就是复杂性的提高 </li>
</ol>
</li>
</ul>
<p>总之没有绝对最好的技术实现，只有相对更适合业务需求的技术实现，任何特性在特定场景下可能是优点，而在另外一种场景可能就是缺点了。</p>
<p>核心代码实现：</p>
<p>Broker 调度实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueBroker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; topicList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisDataStore redisDataStore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ScheduledExecutorService scheduledThreadPool = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, Executors.defaultThreadFactory());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayQueueBroker</span><span class="params">(List&lt;String&gt; topicList, RedisDataStore redisDataStore)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.topicList = topicList;</span><br><span class="line">        <span class="keyword">this</span>.redisDataStore = redisDataStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> RouteThread(), <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                topicList.forEach(topic -&gt; &#123;</span><br><span class="line">                    List&lt;String&gt; topicKeyList = redisDataStore.zRangeByScore(topic, System.currentTimeMillis());</span><br><span class="line">                    <span class="keyword">if</span>(!CollectionUtils.isEmpty(topicKeyList))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;执行时间到了的topicKeyList=&quot;</span> + JSON.toJSONString(topicKeyList));</span><br><span class="line">                        redisDataStore.lPushAll(topic, topicKeyList);</span><br><span class="line">                        redisDataStore.zRem(topic, topicKeyList);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consumer 消费实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; topicList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisDataStore redisDataStore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, DelayQueueSubscriber&gt; subscriberMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">1</span>, Executors.defaultThreadFactory());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayQueueConsumer</span><span class="params">(List&lt;String&gt; topicList, Map&lt;String, DelayQueueSubscriber&gt; subscriberMap, RedisDataStore redisDataStore)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.topicList = topicList;</span><br><span class="line">        <span class="keyword">this</span>.subscriberMap = subscriberMap;</span><br><span class="line">        <span class="keyword">this</span>.redisDataStore = redisDataStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(<span class="keyword">new</span> DelayQueueConsumer.ConsumeThread(), <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            topicList.forEach(topic -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;String&gt; topicKeyList = redisDataStore.lRange(topic, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">                    topicKeyList.forEach(msgKey -&gt; &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;执行时间到了, msgKey=&quot;</span> + msgKey);</span><br><span class="line">                        DelayQueueSubscriber subscriber = subscriberMap.get(topic);</span><br><span class="line">                        DelayMessage delayMessage = redisDataStore.get(msgKey);</span><br><span class="line">                        subscriber.consume(delayMessage);</span><br><span class="line">                        redisDataStore.lRem(topic, msgKey);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务消费接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 延迟消息消费业务逻辑实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DelayQueueSubscriber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(DelayMessage delayMessage)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Producer 生产实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueSender</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> RedisDataStore redisDataStore;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayQueueSender</span><span class="params">(RedisDataStore redisDataStore)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisDataStore = redisDataStore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(DelayMessage delayMessage)</span></span>&#123;</span><br><span class="line">        redisDataStore.set(delayMessage);</span><br><span class="line">        redisDataStore.zAdd(delayMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据存储层实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDataStore</span> <span class="keyword">extends</span> <span class="title">AbstractDataStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MSG_KEY_PREFIX = <span class="string">&quot;MSG_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZSET_KEY_PREFIX = <span class="string">&quot;ZSET_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LIST_KEY_PREFIX = <span class="string">&quot;LIST_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟过期时间.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> DELAY_EXPIRED_MILL_SECONDS = <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisDataStore</span><span class="params">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(DelayMessage message)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(MSG_KEY_PREFIX + message.getKey(), JSON.toJSONString(message),</span><br><span class="line">                message.getTimestamp() - System.currentTimeMillis() + DELAY_EXPIRED_MILL_SECONDS, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DelayMessage <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = redisTemplate.opsForValue().get(MSG_KEY_PREFIX + key);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.parseObject(value, DelayMessage.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">zAdd</span><span class="params">(DelayMessage message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForZSet().add(ZSET_KEY_PREFIX + message.getTopic(), message.getKey(), message.getTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">zRangeByScore</span><span class="params">(String key, <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; tupleSet = redisTemplate.opsForZSet()</span><br><span class="line">                .rangeByScoreWithScores(ZSET_KEY_PREFIX + key, <span class="number">0</span>, timestamp);</span><br><span class="line">        List&lt;String&gt; msgKeyList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (tupleSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tupleSet.forEach(item -&gt; &#123;</span><br><span class="line">                String val = item.getValue();</span><br><span class="line">                Double score = item.getScore();</span><br><span class="line">                <span class="keyword">if</span> (score != <span class="keyword">null</span> &amp;&amp; score.longValue() &lt; timestamp) &#123;</span><br><span class="line">                    msgKeyList.add(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msgKeyList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">zRem</span><span class="params">(String key, List&lt;String&gt; values)</span> </span>&#123;</span><br><span class="line">        Long result = redisTemplate.opsForZSet().remove(ZSET_KEY_PREFIX + key, values.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> result != <span class="keyword">null</span> &amp;&amp; result.intValue() == values.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lPushAll</span><span class="params">(String key, List&lt;String&gt; values)</span> </span>&#123;</span><br><span class="line">        Long result = redisTemplate.opsForList().leftPushAll(LIST_KEY_PREFIX + key, values);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lRem</span><span class="params">(String key, String value)</span></span>&#123;</span><br><span class="line">        Long result = redisTemplate.opsForList().remove(LIST_KEY_PREFIX + key, <span class="number">0</span>, value);</span><br><span class="line">        <span class="keyword">return</span> result != <span class="keyword">null</span> &amp;&amp; result.intValue() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">lRange</span><span class="params">(String key, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(LIST_KEY_PREFIX + key, start, end);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别启动运行 Broker，Consumer，最后就可以往延迟队列里面添加消息了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     RedisDataStore redisDataStore = <span class="keyword">new</span> RedisDataStore(stringRedisTemplate);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; topicList = Arrays.asList(<span class="string">&quot;DELAY_QUEUE_TOPIC1&quot;</span>, <span class="string">&quot;DELAY_QUEUE_TOPIC2&quot;</span>);</span><br><span class="line">        DelayQueueBroker broker = <span class="keyword">new</span> DelayQueueBroker(topicList, redisDataStore);</span><br><span class="line">        broker.start();</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, DelayQueueSubscriber&gt; subscriberMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        subscriberMap.put(<span class="string">&quot;DELAY_QUEUE_TOPIC1&quot;</span>, <span class="keyword">new</span> Topic1MessageSubscriber());</span><br><span class="line">        subscriberMap.put(<span class="string">&quot;DELAY_QUEUE_TOPIC2&quot;</span>, <span class="keyword">new</span> Topic2MessageSubscriber());</span><br><span class="line"></span><br><span class="line">        DelayQueueConsumer consumer = <span class="keyword">new</span> DelayQueueConsumer(topicList, subscriberMap, redisDataStore);</span><br><span class="line">    consumer.start();</span><br><span class="line">    </span><br><span class="line">    DelayQueueSender sender = <span class="keyword">new</span> DelayQueueSender(redisDataStore);</span><br><span class="line">    DelayMessage delayMessage = <span class="keyword">new</span> DelayMessage();</span><br><span class="line">    delayMessage.setKey(<span class="string">&quot;TOPIC1_KEY_&quot;</span> + i);</span><br><span class="line">    delayMessage.setTopic(<span class="string">&quot;DELAY_QUEUE_TOPIC1&quot;</span>);</span><br><span class="line">    delayMessage.setTimestamp(System.currentTimeMillis() + i * <span class="number">1000</span>);</span><br><span class="line">    delayMessage.setContent(<span class="string">&quot;TOPIC2_CONTENT_&quot;</span> + i);</span><br><span class="line">    sender.add(delayMessage);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过 redis 来实现延迟队列的大致原理就如上面所描述，但这样肯定是还没办法用到实际生产业务中去，首先 redis 执行命令的原子性就没有做保证，比如说将消息 lpush 放到 List 中成功了，而 Zset 中 zrem 失败了就会出现消息多次消费的情况，上面整个的描述和一些简单实现示例就是为了把实现原理介绍清楚，距离真正应用到业务生产中还有很多需要优化的地方，比如说引入 Lua 脚本来做到批量命令执行的原子性，加入消息消费的重试策略，Broker 和 Consumer 定时任务优化，避免在没有消息要处理的时候存在很多无效的 redis 请求。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title>对象和数组的创建简单实践</title>
    <url>/%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>在《Java 中对象和数组的创建》一文中提到了很多 JVM 的理论知识，而且里面可能还有很多关联的 JVM 知识点没有介绍到，所以可能初次看起来都比较抽象，但是没关系，先硬着头皮坚持看下去，对这些东西有个初步的印象，等到后面关联的这些知识点都提到了之后你再回过头来看可能就会有种打通任督二脉的感觉了。这里为了加深一下这些理论知识的印象，下面就来看下上一篇文章中提到的有关理论知识的简单实践和验证。</p>
<a id="more"></a>

<h3 id="加载加密之后的-Class-文件"><a href="#加载加密之后的-Class-文件" class="headerlink" title="加载加密之后的 Class 文件"></a>加载加密之后的 Class 文件</h3><p>关于类的加载过程中加载阶段，通过上篇文章中我们已经知道是需要借助类加载器来完成的，而类加载器除了 Java 提供的这些类加载器，我们也可以自定义我们自己的类加载器。怎么来实现呢，下面就来看下如何自定义一个类加载器来加载经过 Base64 加密之后的 Class 文件，直接上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClassLoader1</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = getClassBytes();</span><br><span class="line">        <span class="keyword">if</span>(bytes.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;the provided byte file is illegal&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes()&#123;</span><br><span class="line">        <span class="comment">// Hello 类编译后的 class 文件加密之后的字符串</span></span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;java-basic-sample/src/main/resources/Base64Hello.blass&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 替换掉最后生成的换行符，否则解密可能会失败</span></span><br><span class="line">            String str = <span class="keyword">new</span> String(fileInputStream.readAllBytes(), StandardCharsets.UTF_8).replaceAll(<span class="string">&quot;[\r\n]&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">// 解密</span></span><br><span class="line">            <span class="keyword">return</span> Base64.getDecoder().decode(str.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义类加载器首先继承 ClassLoader 类，然后重写 findClass 方法，在该方法中读取我们加密好的 class 文件，然后进行解密再将解密之后的字节数组作为参数调用 defineClass 方法即可。</p>
<p>这里有个替换换行符的操作，主要是因为我在 Mac 终端下使用 Base64 命令加密生成的文件最后一个换行，导致解密时失败，所以先将换行符替换掉再进行解密。上面代码中我加密的 Hello 类代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译该类生成 Hello.class 文件，然后再加密生成 Base64Hello.blass 文件，命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac net/gittab/basic/jvm/practice/Hello.java</span><br><span class="line">Base64 -i Hello.class -o Base64Hello.blass</span><br></pre></td></tr></table></figure>

<p>测试的 main 方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  HelloClassLoader classLoader = <span class="keyword">new</span> HelloClassLoader();</span><br><span class="line">  Class&lt;?&gt; helloClass = classLoader.findClass(<span class="string">&quot;net.gittab.basic.jvm.practice.Hello&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Object hello = helloClass.getDeclaredConstructor().newInstance();</span><br><span class="line">    Method method = helloClass.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">    method.invoke(hello);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码中主要就是创建自定义的类加载器对象，加载 Hello 类，创建 Hello 对象，最后调用 Hello 类中的 sayHello 方法打印出 Hello World。</p>
<h3 id="类的初始化顺序简单验证"><a href="#类的初始化顺序简单验证" class="headerlink" title="类的初始化顺序简单验证"></a>类的初始化顺序简单验证</h3><p>先准备两个类，一个 Parent 类和一个 Sub 类，其中 Sub 类继承 Parent 类，两个类的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> parent = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getParent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sub = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过 new 创建对象时会触发类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="keyword">new</span> Parent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：打印 parent 字符串。</p>
</li>
<li><p>访问类的静态变量或者调用静态方法会触发类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(Parent.parent);</span><br><span class="line">  <span class="comment">// System.out.println(Parent.getParent());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：打印 parent 字符串。</p>
</li>
<li><p>子类的初始化会触发父类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(Sub.sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：先打印 parent，再打印 sub，最后输出 2。</p>
</li>
<li><p>通过子类调用父类中的静态变量则只会触发父类初始化</p>
<p>还是利用上面的父子类，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(Sub.parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：只会先打印 parent，再输出 1，而不会打印 sub 出来。</p>
</li>
<li><p>通过反射创建类的对象会触发该类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Class&lt;Parent&gt; clazz = Parent.class;</span><br><span class="line">  Object object = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：打印 parent 字符串。</p>
</li>
<li><p>调用类中的静态常量不会触发该类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(Parent.FINAL_PARENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：打印输出 2。</p>
</li>
<li><p>定义指定元素类型的数组不会触发该元素类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Parent[] parents = <span class="keyword">new</span> Parent[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：没有任何输出</p>
</li>
</ul>
<p>上面给了一个自定义类加载器的例子，加载经过 Base64 加密之后的 Class 文件，然后再通过加载的类创建对象的过程，然后是对于类加载过程中的初始化顺序的验证，根据类的初始化会执行静态代码块的特性验证了一些关于类的初始化的触发规则，通过这些例子可以让我们加深对类加载过程的印象同时也对类加载有进一步的认识。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>异步接口实践之 DeferredResult</title>
    <url>/%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E5%AE%9E%E8%B7%B5%E4%B9%8B-DeferredResult/</url>
    <content><![CDATA[<p>前两篇文章主要讨论了关于异步接口在 SrpingMVC 体系下的实现过程，通过查看源码的方式大概梳理了异步走过的整个流程，简要的总结就是：</p>
<a id="more"></a>

<ol>
<li>接口的返回值是 Callable，WebAsyncTask，DeferredResult 等类型。</li>
<li>SpringMVC 在解析接口的返回值的时如果发现是上面的类型，找到能处理该返回值类型的 returnValueHandler 处理器。</li>
<li>在相应的 returnValueHandler 里面有一个处理返回值的方法，在这个方法中开启异步的方式来执行接口返回值里面真正的获取处理结果的方法。</li>
<li>第三步里面以异步的方式执行，容器中处理请求的线程继续往下执行，然后容器线程被释放，response 还是处于打开状态。</li>
<li>第三步里面异步执行结束得到结果后再次请求容器线程，继续处理真正结果，由于真正的结果不是上面的类型，一般匹配到 RequestResponseBodyMethodProcessor,这时会将 Callable，WebAsyncTask，DeferredResult 异步执行的结果返回给客户端，前端拿到结果之后，本次请求结束。</li>
</ol>
<p>至于 Callable 和 WebAsyncTask，DeferredResult 这三种类型作为接口的返回值有什么区别呢，之前的文章中也已经大概说了。其中 DeferredResult 是三者中最灵活的，因为他的异步执行完全是由你自己来控制的，接下来我就用它来模拟一个异步购买商品的接口。</p>
<p>这里假设我们商品购买和支付的流程是这样的：</p>
<ol>
<li>用户在前端点击购买，请求订单服务购买接口，接口的返回值就是 DeferredResult</li>
<li>订单服务的购买接口里面首先创建订单信息</li>
<li>往支付请求队列里面发送一个支付请求消息，同时保存要返回的 DeferredResult 实例</li>
<li>支付服务监听支付请求队列，收到消息后根据订单金额往对应的网关发起支付请求</li>
<li>支付成功之后，支付服务将支付结果发送到支付响应队列</li>
<li>订单服务监听支付响应队列，收到支付结果消息后，更新订单状态信息，取出第三步中保存的 DeferredResult，将支付结果设置给 DeferredResult</li>
<li>前端获取到支付结果，整个购买请求结束</li>
</ol>
<p>上面算是一个简化版的商品购买支付流程，由于支付的那一步是相对要耗时一点的，因为要调用第三方网关发起支付请求，所以购买的接口我返回了 DeferredResult。</p>
<p>当然在这个接口你也可以直接先给前端返回一个待支付订单信息的临时结果，然后前端再通过订单 id 轮询的请求后台接口支付结果。</p>
<p>这种方式其实不是很好，首先有一个是结果返回不及时，因为后端在产生结果之后，前端不会立马得到，需要在下一次轮询中才能得到。</p>
<p>还一个就是，如果同一时间下单的用户比较多，就会有大量的轮询请求，后端容器会频繁的创建线程来处理轮询请求，在结果产生前，这些轮询请求都是无意义的，有点浪费资源。</p>
<p>那么接下来看下通过 DeferredResult 怎么实现，大概流程我上面已经描述了，下面我们看下主要的代码实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;purchase&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;PurchaseResultVO&gt; <span class="title">purchase</span><span class="params">(<span class="meta">@PathVariable(&quot;productId&quot;)</span> Long productId)</span></span>&#123;</span><br><span class="line">    DeferredResult&lt;PurchaseResultVO&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line">    Order order = <span class="keyword">this</span>.orderService.purchase(productId, deferredResult);</span><br><span class="line">    deferredResult.onError((throwable) -&gt; &#123;</span><br><span class="line">        log.error(<span class="string">&quot;purchase error&quot;</span>, throwable);</span><br><span class="line">        <span class="keyword">this</span>.deferredResultStore.remove(order.getUserId(), order.getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    deferredResult.onTimeout(() -&gt; <span class="keyword">this</span>.deferredResultStore.remove(order.getUserId(), order.getId()));</span><br><span class="line">    deferredResult.onCompletion(() -&gt; <span class="keyword">this</span>.deferredResultStore.remove(order.getUserId(), order.getId()));</span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，提供一个商品购买的接口，接口的返回值是 DeferredResult，接口调用 orderService 处理购买流程，同时配置 DeferredResult 的三个回调，在三个回调中都调用了 deferredResultStore 中的 remove 方法，主要是在发生错误，超时，支付完成时将保存在内存中的 DeferredResult 移除掉，标志本次请求结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, DeferredResult&gt; DEFERRED_RESULTS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Long userId, Long orderId, DeferredResult&lt;PurchaseResultVO&gt; deferredResult)</span> </span>&#123;</span><br><span class="line">    DEFERRED_RESULTS.putIfAbsent(assembleKey(userId, orderId), deferredResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult <span class="title">get</span><span class="params">(Long userId, Long orderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DEFERRED_RESULTS.get(assembleKey(userId, orderId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Long userId, Long orderId)</span> </span>&#123;</span><br><span class="line">    DEFERRED_RESULTS.remove(assembleKey(userId, orderId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">assembleKey</span><span class="params">(Long userId, Long orderId)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;purchase:&quot;</span> + userId + <span class="string">&quot;:&quot;</span> + orderId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deferredResultStore 这个主要是通过一个 map 来存储购买接口在请求完成之前产生的 DeferredResult，当支付完成时再从 map 里面取出来设置支付结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">purchase</span><span class="params">(Long productId, DeferredResult&lt;PurchaseResultVO&gt; deferredResult)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// FIXME 获取当前用户 id</span></span><br><span class="line">    Long currentUserId = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// FIXME 模拟查询商品，得到价格信息</span></span><br><span class="line">    <span class="comment">// 构建订单信息</span></span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.setId(<span class="number">1L</span>);</span><br><span class="line">    order.setStatus(<span class="number">0</span>);</span><br><span class="line">    order.setProductId(productId);</span><br><span class="line">    order.setAmount(<span class="number">50L</span>);</span><br><span class="line">    order.setUserId(currentUserId);</span><br><span class="line">    <span class="comment">// FIXME 保存订单数据到数据库</span></span><br><span class="line">    <span class="comment">// 构建支付请求</span></span><br><span class="line">    PayRequest payRequest = <span class="keyword">new</span> PayRequest();</span><br><span class="line">    payRequest.setGateway(<span class="string">&quot;we_chat&quot;</span>);</span><br><span class="line">    payRequest.setProfileId(<span class="number">1L</span>);</span><br><span class="line">    payRequest.setAmount(order.getAmount());</span><br><span class="line">    payRequest.setOrderDTO(OrderConverter.INSTANCE.domain2DTO(order));</span><br><span class="line">    <span class="comment">// 发送支付请求到队列请求支付</span></span><br><span class="line">    <span class="keyword">this</span>.requestRabbitMQSender.send(payRequest);</span><br><span class="line">    <span class="comment">// 临时保存待响应的结果</span></span><br><span class="line">    <span class="keyword">this</span>.deferredResultStore.put(currentUserId, order.getId(), deferredResult);</span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>orderService 里面的 purchase 方法处理订单的持久化，向支付队列发送支付请求消息，保存接口生成的 deferredResult。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;$&#123;spring.rabbitmq.listener-request-queue&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(PayRequest message)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;=============== request queue received message -&gt;&#123;&#125;&quot;</span>, message.toString());</span><br><span class="line">    <span class="comment">// 根据支付请求模拟网关支付</span></span><br><span class="line">    log.info(<span class="string">&quot;发起网关支付 -&gt; &#123;&#125;&quot;</span>, message.toString());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 然后将支付结果放到队列</span></span><br><span class="line">    PayResponse response = <span class="keyword">new</span> PayResponse();</span><br><span class="line">    response.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">    response.setPayId(<span class="number">1L</span>);</span><br><span class="line">    response.setOrderDTO(message.getOrderDTO());</span><br><span class="line">    log.info(<span class="string">&quot;=============== 网关支付成功，将结果放到结果队列 -&gt;&#123;&#125;&quot;</span>, message.toString());</span><br><span class="line">    <span class="keyword">this</span>.responseRabbitMQSender.send(response);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时支付服务在监听支付请求消息队列，这里只是模拟，所以都在同一个工程里面。收到支付请求消息之后，向网关发起扣款，扣款成功后再将结果塞回支付响应队列里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;$&#123;spring.rabbitmq.listener-response-queue&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(PayResponse message)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;=============== response queue received message -&gt;&#123;&#125;&quot;</span>, message.toString());</span><br><span class="line">    <span class="comment">// 根据支付结果，查询并且更新数据库订单状态</span></span><br><span class="line">    OrderDTO orderDTO = message.getOrderDTO();</span><br><span class="line">    log.info(<span class="string">&quot;查询数据库订单信息 -&gt; &#123;&#125;&quot;</span>, orderDTO.toString());</span><br><span class="line">    Order order = OrderConverter.INSTANCE.dto2Domain(orderDTO);</span><br><span class="line">    <span class="keyword">boolean</span> success = message.getSuccess();</span><br><span class="line">    <span class="keyword">if</span>(success)&#123;</span><br><span class="line">        order.setStatus(<span class="number">1</span>);</span><br><span class="line">        order.setPayId(message.getPayId());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        order.setStatus(-<span class="number">1</span>);</span><br><span class="line">        order.setErrorMsg(message.getErrorMsg());</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;保存订单最新状态信息 -&gt; &#123;&#125;&quot;</span>, order.toString());</span><br><span class="line">    <span class="comment">// 设置支付返回结果</span></span><br><span class="line">    DeferredResult&lt;PurchaseResultVO&gt; deferredResult = <span class="keyword">this</span>.deferredResultStore.get(order.getUserId(), order.getId());</span><br><span class="line">    <span class="keyword">if</span>(deferredResult == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PurchaseResultVO resultVO = <span class="keyword">new</span> PurchaseResultVO();</span><br><span class="line">    resultVO.setSuccess(success);</span><br><span class="line">    resultVO.setProductId(order.getProductId());</span><br><span class="line">    resultVO.setErrorMsg(message.getErrorMsg());</span><br><span class="line">    log.info(<span class="string">&quot;设置支付结果返回 -&gt; &#123;&#125;&quot;</span>, resultVO.toString());</span><br><span class="line">    deferredResult.setResult(resultVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，订单服务在监听支付响应的消息队列，收到支付结果消息后更新订单状态，从 deferredResultStore 中取出刚才保存的 deferredResult，设置支付结果，然后前端收到购买结果，刷新页面信息，整个购买请求结束。</p>
<p>在整个过程中，我们可以看到一旦订单服务收到支付结果消息，就会立马放到 deferredResult 中，前端也能够立马得到响应，前端不需要做额外的轮询操作，同样后台也不用再提供轮询的接口，而且支付结果并不会像轮询一样有延迟。</p>
<p>还有就是避免了大量的轮询请求，而且在后台处理支付的过程中，接收购买请求的线程已经被释放了，并不会占额外的资源，在收到结果后才重新请求容器线程来返回支付结果给前端。</p>
<p>但是这个其实也有一个问题，因为是异步的，必然有线程之前的切换的过程，首先，前端请求到后台容器线程，容器线程开启异步执行处理，容器线程释放，异步执行结束，又再重新请求到容器线程，容器线程返回结果给前端。</p>
<p>这里面有好几次的线程切换，这其实相对来说也是比较耗时的。这就看你的异步执行的过程是不是需要一定时间才能执行完，如果是需要一定时间的话，相对于线程间的切换这一点时间的话还是可以接受的，毕竟这样也带来我上面说到的这些好处。</p>
<p>上面就是使用 DeferredResult 来实现了异步接口模拟了商品购买支付的一个流程，虽然说里面没有更详细的数据库操作以及购买的时候的真正扣款，扣库存的那些操作，但整体流程已经很清晰了，通过这个例子应该能对异步接口有进一步的了解。</p>
<p>上面例子的代码我也已经提交到 GitHub 了，感兴趣的可以去下载查看。地址是：<a href="https://github.com/rookiedev-z/sample">blog sample code</a></p>
<p>这里面也包含了之前的 JdbcTemplate 操作的样例代码，之后我也会把文章中的样例代码上传到这个工程中，建议 star。</p>
<p>同时，没有看过前面两篇异步解析的文章也强烈建议去看下，这样有助于理解。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="好的开始是成功的一半"><a href="#好的开始是成功的一半" class="headerlink" title="好的开始是成功的一半"></a><center>好的开始是成功的一半</center></h2><h1 id="欢迎使用Markdown编辑器写博客"><a href="#欢迎使用Markdown编辑器写博客" class="headerlink" title="欢迎使用Markdown编辑器写博客"></a>欢迎使用Markdown编辑器写博客</h1><p>本Markdown编辑器使用<a href="https://github.com/benweet/stackedit">StackEdit</a>修改而来，用它写博客，将会带来全新的体验哦：</p>
<a id="more"></a>

<ul>
<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>
<li><strong>代码块高亮</strong></li>
<li><strong>图片链接和图片上传</strong></li>
<li><strong><em>LaTex</em>数学公式</strong></li>
<li><strong>UML序列图和流程图</strong></li>
<li><strong>离线写博客</strong></li>
<li><strong>导入导出Markdown文件</strong></li>
<li><strong>丰富的快捷键</strong></li>
</ul>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>加粗    <code>Ctrl + B</code> </li>
<li>斜体    <code>Ctrl + I</code> </li>
<li>引用    <code>Ctrl + Q</code></li>
<li>插入链接    <code>Ctrl + L</code></li>
<li>插入代码    <code>Ctrl + K</code></li>
<li>插入图片    <code>Ctrl + G</code></li>
<li>提升标题    <code>Ctrl + H</code></li>
<li>有序列表    <code>Ctrl + O</code></li>
<li>无序列表    <code>Ctrl + U</code></li>
<li>横线    <code>Ctrl + R</code></li>
<li>撤销    <code>Ctrl + Z</code></li>
<li>重做    <code>Ctrl + Y</code></li>
</ul>
<h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</p>
</blockquote>
<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net/">链接</a>等，详细语法参考帮助？。</p>
<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href="https://github.com/jmcmanus/pagedown-extra" title="Pagedown Extra">Github</a>.  </p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>Computer</td>
<td>$1600</td>
</tr>
<tr>
<td>Phone</td>
<td>$12</td>
</tr>
<tr>
<td>Pipe</td>
<td>$1</td>
</tr>
</tbody></table>
<p>可以使用冒号来定义对齐方式：</p>
<table>
<thead>
<tr>
<th align="left">项目</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Computer</td>
<td align="right">1600 元</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left">Phone</td>
<td align="right">12 元</td>
<td align="center">12</td>
</tr>
<tr>
<td align="left">Pipe</td>
<td align="right">1 元</td>
<td align="center">234</td>
</tr>
</tbody></table>
<p>###定义列表</p>
<dl><dt><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A</dt><dd>定义 B</dd></dl><dl><dt>项目３</dt><dd>定义 C</dd></dl><p>:   定义 D</p>
<pre><code>&gt; 定义D内容</code></pre>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>
<p>[TOC]</p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/">math.stackexchange.com</a>.</p>
<ul>
<li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li>
<li>块级公式：</li>
</ul>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">这儿</a>.</p>
<h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">张三-&gt;李四: 嘿，小四儿, 写博客了没?</span><br><span class="line">Note right of 李四: 李四愣了一下，说：</span><br><span class="line">李四--&gt;张三: 忙得吐血，哪有时间写。</span><br></pre></td></tr></table></figure>

<p>或者流程图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">e&#x3D;&gt;end: 结束</span><br><span class="line">op&#x3D;&gt;operation: 我的操作</span><br><span class="line">cond&#x3D;&gt;condition: 确认？</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

<ul>
<li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/">这儿</a>,</li>
<li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li>
</ul>
<h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>
<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>
<p>博客发表后，本地缓存将被删除。　</p>
<p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>
</blockquote>
<p>##浏览器兼容</p>
<ol>
<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>
<li>IE９以下不支持</li>
<li>IE９，１０，１１存在以下问题<ol>
<li>不支持离线功能</li>
<li>IE9不支持文件导入导出</li>
<li>IE10不支持拖拽文件导入</li>
</ol>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title>接口采用异步的方式执行</title>
    <url>/%E6%8E%A5%E5%8F%A3%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h3 id="不需要返回结果的接口"><a href="#不需要返回结果的接口" class="headerlink" title="不需要返回结果的接口"></a>不需要返回结果的接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;asyncEndpoint&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncEndpoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;========== received async endpoint request&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.taskService.asyncExecute();</span><br><span class="line">    log.info(<span class="string">&quot;========== the servlet thread that received the request has been released&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;========== task async execute start&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    log.info(<span class="string">&quot;========== task async execute end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 asyncEndpoint 是一个不需要返回结果的接口，主要是通过 @Async 注解来实现的，请求到了后台，从 Tomcat 服务器处理请求的线程池中获取一个线程 A 处理该请求，在该线程中执行到调用 asyncExecute 方法的时候，由于 asyncExecute 方法的上面由 @Async 注解所标注，这样的话该方法会以异步的方式来执行，也就是说在 asyncEndpoint 方法中调用 asyncExecute 方法以异步的方式执行，asyncExecute 方法中的代码在另一个线程 B 中执行，线程 A 继续往下执行，打印完最后一行日志之后，整个请求就结束了，线程 A 也就释放了，可以继续处理其他的请求了。 而比较耗时的方法 asyncExecute 继续在线程 B 中执行。</p>
<p>请求 asyncEndpoint 接口，通过以下日志可以看出来：</p>
<p><img src="/images/asyncEndpoint_log.png" alt="asyncEndpoint_log"></p>
<h3 id="有返回值的接口之-Callable-作为返回值"><a href="#有返回值的接口之-Callable-作为返回值" class="headerlink" title="有返回值的接口之 Callable 作为返回值"></a>有返回值的接口之 Callable 作为返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;callableEndpoint&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">callableEndpoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;========== received callable endpoint request&quot;</span>);</span><br><span class="line">    Callable&lt;String&gt; callable = <span class="keyword">this</span>.taskService ::execute;</span><br><span class="line">    log.info(<span class="string">&quot;========== the servlet thread that received the request has been released&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> callable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;========== task execute start&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    log.info(<span class="string">&quot;========== task execute end&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;task execute success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 callableEndpoint 接口，它的返回值是 Callable<String>，这里就需要注意了，他在这里同样也会以异步的方式将结果返回给客户端请求，但这里和上面的这种方式又有所不同，这种方式稍微复杂一点。上面的方式更多的是由于我们不关心方法执行的返回值，我们自己在业务逻辑层面来控制方法以异步的方式执行，然后处理请求的线程执行结束，应用程序线程继续异步执行。</p>
<p>而在这里，主要是利用了 Servlet 3.0 中引入了对于异步的支持，至于 Servlet 3.0 中引入的对异步的支持，下次再用一篇文章详细介绍下，我们先大概了解以 Callable 作为返回值的接口为什么会以异步的方式执行。</p>
<p>这里首先后台收到 asyncEndpoint 请求后，同样从 Tomcat 容器处理请求的线程池中获取一个线程处理该请求。这里大概说下，我们是使用的 SpringMVC 的那一套请求执行流程，SpringMVC 中有一个 DispatcherServlet 类里面的 doDispatch 方法是请求的统一入口，通过它来协调其它组件来处理前端请求。</p>
<p>比如说通过处理器映射器 HandlerMapping 查找对应的 Handler 处理器 Controller，然后再通过请求适配器 HandlerAdapter 对处理器进行执行，在处理器执行之后得到一个返回值结果，SpringMVC 里面有一些处理返回值的 Handler 来对结果进行解析，根据返回值类型选取合适的 returnValueHandler 来处理。下面是直接到了处理器执行获取执行结果的代码。</p>
<p><img src="/images/handler_return_value.png" alt="handler_return_value"></p>
<p>至于选择处理范湖结果的 handler 的过程通过下面代码可以看出，是根据返回值的类型来从已经注册的 returnValueHandler 选择能处理当前返回值类型的 handler，</p>
<p><img src="/images/handler_select_handler.png" alt="handler_select_handler"></p>
<p><img src="/images/select_handler.png" alt="select_handler"></p>
<p><img src="/images/support_return_value.png" alt="support_return_value"></p>
<p>从上面第三段代码中可以看到由于返回值类型 Callable，最终会匹配到 CallableMethodReturnValueHandler 这个返回值处理器，在这个类中还有一个方法 handleReturnValue，也就是在选择好匹配的 returnValueHandler 之后调用的那个方法，异步的处理也就是在这个方法的最后一行代码中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(callable, mavContainer);</span><br></pre></td></tr></table></figure>

<p>这行代码先是调用 getAsyncManager 获取到 WebAsyncManager，然后调用 startCallableProcessing 开始 Callable 结果的处理流程，而在 startCallableProcessing 方法里面又是调用了一个内部重载的方法，通过 WebAsyncTask 包装了以下 Callable 作为参数</p>
<p><img src="/images/startCallableProcessing.png" alt="startCallableProcessing"></p>
<p><img src="/images/set_concurrent_result_dispatch.png" alt="set_concurrent_result_dispatch"></p>
<p>在 startCallableProcessing 方法中可以清楚的看到将 callable 交给 taskExecutor 来执行，然后设置并发执行得到的结果并且调用 dispatch 方法将请求再次分派到容器，以便应用程序线程中并发执行之后的恢复处理，其实也就是将并发执行的结果再次交给容器线程来恢复刚才的请求，将刚才的流程再执行一次。</p>
<p>只不过在处理器执行的时候调用的不再是 Contrller 里面的方法，而是直接调用 Callable 的 call 方法拿刚才执行的结果，等到再执行到 handleReturnValue 方法的时候，这时由于 return value 是一个字符串，所以匹配到的 returnValueHandler 是 RequestResponseBodyMethodProcessor,这时会将 callable 的执行结果返回给客户端，本次请求结束。</p>
<p>需要注意的是，应用程序的异步任务的执行时间过长会导致超时的问题，还记得上面的 startCallableProcessing 方法里面有 addTimeoutHandler，addErrorHandler，addCompletionHandler 三个回调，分别是超时，发生错误以及异步执行完成的回调处理。里面其实会去读 WebAsyncTask 中设置的超时时间，但里面没有设置，但我测试是有一个默认的超时时间 30s(我通过测试，发现 30s 没执行完就会 timeout)。</p>
<p>还有一个就是需要注意的是在整个的处理过程中，服务端和客户端的连接是一直保持着的，所以需要注意连接超时的问题，虽然默认没有设置的话是无限的，但如果设置了就需要注意了，这个的超时时间必然要比异步执行里面的超时时间要大一些。</p>
<p>上面的 taskExecutor 是 SpringBoot 中 TaskExecutionAutoConfiguration 自动配置的 ThreadPoolTaskExecutor，对于这个类的配置也可以在配置文件中进行配置，线程数，queue capacity 等。</p>
<p>最终的执行打印日志如下：<br><img src="/images/callableEndpoint_log.png" alt="callableEndpoint_log"></p>
<h3 id="有返回值的接口之-WebAsyncTask-作为返回值"><a href="#有返回值的接口之-WebAsyncTask-作为返回值" class="headerlink" title="有返回值的接口之 WebAsyncTask 作为返回值"></a>有返回值的接口之 WebAsyncTask 作为返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;webAsyncTaskEndpoint&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">webAsyncTaskEndpoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;========== received web async task endpoint request&quot;</span>);</span><br><span class="line">    Callable&lt;String&gt; callable = () -&gt; <span class="keyword">this</span>.taskService.execute();</span><br><span class="line">    WebAsyncTask&lt;String&gt; webAsyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">3000</span>, callable);</span><br><span class="line">    webAsyncTask.onCompletion(() -&gt; log.info(<span class="string">&quot;========== execute finish&quot;</span>));</span><br><span class="line"></span><br><span class="line">    webAsyncTask.onTimeout(() -&gt; <span class="string">&quot;execute timeout&quot;</span>);</span><br><span class="line"></span><br><span class="line">    webAsyncTask.onError(() -&gt; <span class="string">&quot;execute error&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;========== the servlet thread that received the request has been released&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> webAsyncTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在理解了 Callable 作为接口返回值之后，就能够很好地理解这个流程了，大体的流程是一样的，只不过就是返回值的 Handler 处理器不一样，这里用到的处理器是 AsyncTaskMethodReturnValueHandler，在这个类中 handleReturnValue 方法调用的 startCallableProcessing 传的参数就是 Controller 里面返回的这个 webAsyncTask，这个 webAsyncTask 定义了三个回调函数，方便做特殊的处理。</p>
<p>这里需要注意的是 onError 的回调并不是说异步任务里面执行出错了的回调，其实异步任务里面的出错的话已经 try catch 了，并且将异常信息作为结果返回，所以说如果异步任务里面抛异常了，并不会回调到这里，而且这里回调的是 onCompletion，只不过得到的结果是抛出的异常。至于这里的 onError 是哪里出现异常的回调呢，看 WebAsyncTask 类的 onError 方法上面的 doc 描述有一段这样的话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This method is called from a container thread when an error occurred while processing an async request before the &#123;@code Callable&#125; has completed</span><br></pre></td></tr></table></figure>
<p>看意思是在异步任务执行完成之前，处理异步请求的过程中发生的异常会回调，具体有待测试。</p>
<p>所以说 WebAsyncTask 作为接口返回值的话，扩展性更强一些，提供了更完善的超时，异常，异步执行完成的回调处理。</p>
<p>最终的执行打印日志如下:</p>
<p><img src="/images/webAsyncTaskEndpoint_log.png" alt="webAsyncTaskEndpoint_log"></p>
<h3 id="有返回值的接口之-DeferredResult-作为返回值"><a href="#有返回值的接口之-DeferredResult-作为返回值" class="headerlink" title="有返回值的接口之 DeferredResult 作为返回值"></a>有返回值的接口之 DeferredResult 作为返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;deferredResultEndpoint&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">deferredResultEndpoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;========== received deferred result endpoint request&quot;</span>);</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line">    CompletableFuture.supplyAsync(<span class="keyword">this</span>.taskService ::execute)</span><br><span class="line">            .whenCompleteAsync((result, throwable) -&gt; deferredResult.setResult(result));</span><br><span class="line">    log.info(<span class="string">&quot;========== the servlet thread that received the request has been released&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个接口的返回值是 DeferredResult，那么请求的处理流程和 Callable 是一样的，不同的地方也是在于<br>返回值的 Handler 处理器不一样，这里用到的处理器是 DeferredResultMethodReturnValueHandler，而且这个类里面的 handleReturnValue 方法和上面的 CallableMethodReturnValueHandler 以及 AsyncTaskMethodReturnValueHandler 方法又不一样，这里调用的是 WebAsyncManager 类中 startDeferredResultProcessing 方法</p>
<p><img src="/images/startDeferredResultProcessing.png" alt="startDeferredResultProcessing"></p>
<p>startDeferredResultProcessing 方法和 startCallableProcessing 差不多，前面都是设置超时时间，设置超时，错误，完成的回调，最后有点不同，在 startCallableProcessing 方法里面是开始通过 taskExecutor 来执行异步任务。</p>
<p>而在这里是为 deferredResult 设置了一个 resultHandler，然后在 resultHandler 里面调用 setConcurrentResultAndDispatch，来设置结果并且将请求再次分派到容器恢复请求过程返回结果给客户端。至于这里的 resultHandler 的用处是 Controller 里面异步任务执行完成后为 deferredResult 设置结果的时候调用 setResult 方法里面会用到。</p>
<p><img src="/images/setResult.png" alt="setResult"></p>
<p>从上面可以看出在设置结果之后，会调用在 startDeferredResultProcessing 设置好的 resultHandler ，也就是执行 setConcurrentResultAndDispatch，到这里就又和上面的流程一样了，调用 dispatch 方法将请求再次分派到容器，执行之后的恢复过程返回结果给客户端。</p>
<p>对于 DeferredResult 作为接口返回值还有个不同的地方就是异步任务的执行完全是由开发人员自己控制了，而不是像之前的那样交给应用程序默认的 ThreadPoolTaskExecutor 来执行，这其实就给开发人员很大的灵活性了。</p>
<p>采用这种异步方式的好处：<br>一般来说，我们写的更多的是阻塞同步式的接口，但有时候如果我们碰到比较耗时任务的接口，这时候我们如果还采用阻塞同步式的写法的话，那么前端请求到后台，首先 Tomcat 服务器从处理请求的线程池中获取一个线程 A 来处理该请求，</p>
<p>然后由于这个接口要执行的任务耗时比较长，耗时任务一直在线程 A 中执行，直到任务执行完成才得到释放，对于并发量比较小的程序来说那还好，线程占着也就占着了，但如果是并发量比较大的程序，容器中大量的处理请求的线程将一直被占用，如果突然请求的高峰到来，那么容器中处理请求的线程有可能被耗尽，就不能再处理更多请求了，也就是说这严重影响了系统的并发吞吐量。</p>
<p>而如果我们采取的是异步的方式来处理的话，这时就像我们前面所介绍的一样，请求到了后台，由于是异步的方式，处理请求的线程在处理完请求之后就被释放了，可以继续处理其他请求，等到异步任务执行完之后再移交给容器线程返回结果给客户端，这样的话就很大的提高了系统的并发量。</p>
<p>最终的执行打印日志如下：<br><img src="/images/deferredResultEndpoint_log.png" alt="deferredResultEndpoint_log"></p>
<h3 id="各自的适用场景，"><a href="#各自的适用场景，" class="headerlink" title="各自的适用场景，"></a>各自的适用场景，</h3><p>首先一个前提就是要执行的任务是耗时的任务，或者需要等第三方的通知的任务</p>
<ol>
<li>通过 @Async 注解的方式</li>
</ol>
<ul>
<li>不需要关注任务执行的结果</li>
</ul>
<ol start="2">
<li>以 Callable 作为接口的返回值</li>
</ol>
<ul>
<li>需要知道任务执行的结果，并且将该结果返回给前端</li>
</ul>
<ol start="3">
<li>以 WebAsyncTask 作为接口的返回值</li>
</ol>
<ul>
<li>需要知道任务执行的结果，并且将该结果返回给前端，同时希望控制异步任务的超时时间，任务执行结束时要做特殊处理，以及捕获处理请求的过程中发生了异常的回调。</li>
</ul>
<ol start="4">
<li>以 DeferredResult 作为接口的返回值</li>
</ol>
<ul>
<li><p>需要知道任务执行的结果，并且将该结果返回给前端，同时希望控制异步任务的超时时间，任务执行结束时要做特殊处理，以及捕获处理请求的过程中发生了异常的回调。</p>
</li>
<li><p>需要控制异步任务的执行，自己维护处理返回结果的线程。</p>
</li>
</ul>
<p>比如说，接口需要等第三方服务的处理结果才能设置返回给前端的结果。Client 请求服务 A，服务 A 通过消息队列发送任务给服务 B，同时监听服务 B 的处理结果队列，服务 B 处理完成之后将结果塞回给服务 A 的结果队列，服务 A 收到结果后再返回给 Client，这个流程就很适合用采用 DeferredResult 作为接口的返回值。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>日常开发中常用命令之 nohup 命令</title>
    <url>/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B-nohup-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>之前几篇文章分享了异步接口的实现和原理，基本上都是需要查看源码来辅助理解，说实话，看懂之后可能觉得还好，但是在一开始不太清楚的时候阅读源码确实有点枯燥，尤其是在你不是很想去了解这个的时候。只有当我们真正想去了解这个东西的时候可能才会愿意花精力去研究，这时候就不会那么无聊了，反而会觉得在探索的过程中很有趣。</p>
<a id="more"></a> 

<p>接下来我开始分享稍微轻松一点但又不那么无聊而且很实用的东西，那就是日常中我们肯定会用到很多命令，有一部分是我们用的比较频繁，而且又是必备的命令，这些命令我们需要熟练掌握，这有利于提高我们日常的工作效率。</p>
<p>首先我们要知道所有的命令都是为了帮助我们完成一件或多件事情的，也就是在计算机系统中，我们想要做什么，都需要通过相对应的命令来告诉计算机我们的需求，如果某个命令经常用，也就说明这个命令所做的事情我们经常需要做，下面我们就根据常见需求来引出相对应的命令。</p>
<p>后台启动 SpringBoot 项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar usercenter.jar --spring.profiles.active=development &gt; usercenter.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>作为后台开发人员来说，日常应该经常需要启动项目程序，只不过平常本地都是通过 idea 来启动，如果现在需要将 usercenter 项目打包部署到一台用于开发测试的服务器上，那么这时候我们需要将 usercenter 打包，然后拷贝到服务器上，拷贝上去之后再通过 ssh 命令连接到服务器终端，这里假设服务器都已经是安装好了 Java 的运行时环境。接下来我们就可以启动刚才拷贝上来的 jar 包了。正常前台启动的命令是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar usercenter.jar --spring.profiles.active=development</span><br></pre></td></tr></table></figure>
<p>但是这种方式是前台启动，日志直接输出到终端，这对于一次性启动的项目那还好，启动完测试好了直接关闭终端断开服务器连接就好，但是如果想要在我们退出终端后让它保持继续运行的话就不行了，因为上面的这种方式在我们退出终端的同时程序也停止运行了。这时候就有必要通过后台启动的方式来让程序保持在后台继续运行，也就是 nohup 命令。</p>
<p>nohup 英文全称是 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。nohup 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。</p>
<p>语法格式：nohup Command [ Arg … ] [&amp;]<br>参数说明：<br>Command：要执行的命令。<br>Arg：一些参数，可以指定输出文件。<br>&amp;：让命令在后台执行，终端退出后命令仍旧执行。</p>
<p>上面这一段是菜鸟教程里面对 nohup 命令的介绍，对于上面描述的默认情况下输出一个名叫 nohup.out 的文件到当前目录说的是我们没有将 nohup 命令的输出重定向到其他文件的话会输出到当前目录下一个默认的名叫 nohup.out 的文件中，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。</p>
<p>也就是如果以下面的方式执行则会在当前目录下产生一个 nohup.out 的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar usercenter.jar --spring.profiles.active=development &amp;</span><br></pre></td></tr></table></figure>
<p>但如果在当前目录下我们需要启动多个项目的话，项目启动的日志就都输出到 nohup.out 文件中了，不利于我们查看日志，这时候我们可能需要进行日志重定向来区分不同项目的日志输出，这样也有利于我们后期再次登录服务器时通过文件名区分不同项目的日志输出。</p>
<p>于是我们就用到了下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar usercenter.jar --spring.profiles.active=development &gt; usercenter.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>为了帮助更好地理解上面这个命令，我们先了解下关于终端输入输出一个概念：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">0&lt; – stdin (standard input，标准输入) ，简写 &lt;</span><br><span class="line">1&gt; – stdout (standard output，标准输出)，简写 &gt;</span><br><span class="line">2&gt; – stderr (standard error，标准错误输出)</span><br></pre></td></tr></table></figure>

<p>对于上面这个命令，中间 java -jar 那一部分自然就是我们要执行的项目启动命令，nohup 以及末尾的 &amp; 表示在后台不挂断的执行 java -jar 命令，即使终端退出后命令仍继续执行，&gt; usercenter.log 表示将命令的标准输出重定向到 usercenter.log 文件，2&gt;&amp;1 表示将标准错误输出也重定向到标准输出中，也就是说命令执行的标准输出和标准错误输出都输入到 usercenter.log 文件中。</p>
<p>当然如果我们不关心命令执行的输出结果，也不想要默认生成的那个 nohup.out 文件，这时候我们可以将输出重定向到 /dev/null，/dev/null 是一个特殊的文件，它接受并丢弃写入其中的所有输入。一般对于那种可能产生大量的日志输出时，这个就比较有用了，避免日志文件占据大量空间。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>日常开发中常用命令之 ps 命令</title>
    <url>/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B9%8B-ps-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在上一篇文章中我分享了关于 nohup 命令的使用，通过 nohup 命令在后台运行我们的程序，就算我们退出了终端程序也会继续在后台运行。</p>
<p>现在假如我们通过 nohup 命令在服务器上已经启动好了我们的后台程序，然后前端通过我们给的接口地址进行调试，这时前端跟你说接口调不通，于是我们去服务器上看下我们的日志文件以确认程序是否真的起来了，<br>如果我们在日志文件中看到类似于下面这种日志：</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Started JdbctemplateSampleApplication in 1.574 seconds (JVM running for 7.127)</span><br></pre></td></tr></table></figure>
<p>说明我们的程序看起来确实启动成功了，那为什么调不通呢？那就让我们通过命令看下服务器上是否真的存在刚才启动的程序进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure>
<p>上面的命令是显示目前系统上连同命令行等所有的进程信息，并且通过 grep 来筛选出和 Java 相关的进程。当然你可以使用更精确的筛选条件，或者再接着使用管道符 | 继续加上筛选条件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep java|grep JdbctemplateSampleApplication</span><br></pre></td></tr></table></figure>
<p>然后看看是否存在我们刚才启动的那个程序的进程，如果有的话说明程序确实在运行着，如果没有的话有可能是因为内存不足或者其他原因导致我们的程序启动成功后又停止了。这时可以再次通过 nohup 命令来启动程序，不出意外的话，前端应该可以调通了。</p>
<p>接下来我们可以继续开发接口，过了两天加了几个接口然后需要再次部署到服务器上，这时我们需要先停掉之前正在运行的程序然后再启动新的程序，毕竟程序使用的端口是一样的，如果不停掉正在运行的程序而直接启动将会因为端口被占用而导致程序启动失败。</p>
<p>好了，那我们就还是先找到上次运行的程序进程 id，再通过 kill 命令杀掉那个进程然后就可以启动了。同样的我们还是用 ps 命令来找到程序的进程：<br><img src="/images/ps_output_no_head.png" alt="output_no_head"><br>从上面截图中可以看到我们确实找到了我们所运行的程序所在的那个进程，但是却不知道标记的那几个数字哪个是进程的 id，当然熟悉 ps 命令的可能都知道第二列是进程 id，但如果这时恰好我们忘了哪一列是进程 id 咋办呢？</p>
<p>其实如果我们不带筛选条件的话，打印到终端的结果中第一行为每一列的列表标题，表示每一列的字段含义，有点类似 MySQL 中查询得到的结果中第一行代表的是每一列字段的含义。<br><img src="/images/ps_output_with_head.png" alt="output_with_head"><br>但是由于我们带上了筛选条件，所以将第一行标题也过滤掉了，那我们能不能想办法在每次输出的结果中都带上第一行的标题行呢？其实是可以的，下面就是两种每次输出都带上标题行的方法:</p>
<ol>
<li>使用 ‘grep’ 的扩展 ‘egrep’</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|egrep &#x27;java|PID&#x27;|grep -v egrep</span><br></pre></td></tr></table></figure>
<p>上面是通过使用 egrep 来对 ps -ef 得到的结果进行过滤，由于 egrep 允许管道 | 具有特殊含义 OR，因此，最终匹配到的结果包含标题行中的 PID，这样也就将标题行打印出来了，最后的 grep -v egrep 是将 egrep 本身的进程过滤掉。</p>
<ol start="2">
<li>先提取标题行再进行筛选</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|head -1;ps -ef|grep java</span><br></pre></td></tr></table></figure>
<p>上面则是先通过 ps -ef 的命令提取出首行的标题行，然后再进行 ps -ef 带筛选条件，但是不是觉得好像敲了两遍 ps -ef 有点不舒服，那就稍微优化下(优化后的命令如果感兴趣的可以去研究下分组命令):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意左大括号后面有个空格，右大括号前记得加分号</span></span><br><span class="line">ps -ef|&#123; head -1;grep java;&#125;</span><br></pre></td></tr></table></figure>
<p>这两种方法看个人习惯吧，如果觉得第一种有点影响了筛选条件的话那就使用第二种方式，而第二种方式就命令有点长，可能有的同学不太想敲这么多字符。</p>
<p>通过上面的命令找到程序运行的进程 PID 之后就可以直接杀掉进程了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -9 PID 或 kill -15 PID</span><br></pre></td></tr></table></figure>
<p>-9 表示直接杀死一个进程，-15 表示正常停止一个进程。</p>
<p>上面说了这么多，其实呢整个过程就是找到进程 ID 然后杀掉那个进程，那么如果我们在 ps 命令中能明确找到那个进程的前提下是否可以通过管道符直接一步到位一个命令行就解决了，也就是查找进程杀死进程，答案当然是可以的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep java|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -9</span><br></pre></td></tr></table></figure>

<p>上面的整个命令就是通过管道符 | 传递上一个命令的执行结果，然后利用 awk 命令 以空格为默认分隔符将每行进行切片，然后只打印出每行第二列的内容，也就是进程 PID，之后再交给 xargs 命令 将所有行数据转为单行以空格分开，然后再将结果作为 kill 命令的参数，这样就做到了一步到位，查找进程杀死进程，这在我们需要批量杀死进程的时候还是非常便利的，省去了一个一个去找到进程 id，再一个一个去杀死进程。</p>
<p>当然里面的 xargs 命令还是非常强大的，其实是由于很多命令不支持管道符 | 来传递参数，所以就用到了它的将管道或标准输入数据转换成命令行参数，上面的 Kill -9 就不支持管道符来传递参数，所以就通过 xargs 命令将上一个命令的执行结果作为 kill -9 的参数，当然这里还用到了 xargs 命令的多行变单行的作用。</p>
<p>我放一张上面这个命令分开执行的效果图，有利于我们更好地理解上面完整的命令。</p>
<p><img src="/images/ps_awk_xargs.png" alt="ps_awk_xargs"></p>
<p>注意这里为了方便看出整体的效果，我筛选的是系统进程，所以我就没有执行最后加上 kill -9 的完整命令，不然系统的进程都被我杀死了，我系统都要错乱了。理解了上面的命令执行过程之后你可以换一个筛选条件，筛选出可以关掉的进程拿来测试看看效果。</p>
<p>上面说的都是通过 ps 命令，然后加上对应的筛选条件来查找我们在这台服务器上运行的程序进程，那如果这台服务器运行的 Java 程序很多，筛选之后还需要人工来确认才知道是哪一个，又或者如果服务器上的程序是你前同事部署的，这时你可能都不知道怎么去筛选，但是呢通过前端请求的地址你能知道程序运行占用的端口号。那么我们就能根据端口号来找到对应的进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i:8081</span><br></pre></td></tr></table></figure>
<p>上面的 lsof 命令就是列出谁在使用某个端口，其实这个命令还有很多功能，而我用的最多的就是上面这个，当然感兴趣的话可以自己去研究下这个命令的其他功能。</p>
<p><img src="/images/lsof.png" alt="lsof"></p>
<p>是不是觉得很方便，反正我是经常使用这个命令来查找后台运行的程序的，因为很简单，敲得的字符也少，还能精确定位到相关的进程，真的是爱了爱了。</p>
<p>然后呢到这里 ps 命令就分享完了，当然我只是列举了它的一小部分常用的，更多功能还是需要我们在平常使用中去探索。同时我还提到了 lsof 命令，说实话，这个命令在我知道之后使用频率真的是非常非常高了，可以说很有用的一个命令，希望同样对你也很有帮助。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>极力推荐的博文排版指南</title>
    <url>/%E6%9E%81%E5%8A%9B%E6%8E%A8%E8%8D%90%E7%9A%84%E5%8D%9A%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>作为程序员来说，养成写博客的习惯真的是一件值得去做的事，尽管刚开始可能没有那么高质量的知识输出，但是不是有这样一句话吗？「知识的输入应转化为输出」，也就是说你应该把你所学到的都转化为输出，只有这样你才能更好的掌握你所学的知识，并且在这个过程中你也会对你所学的知识点进行很好的补充。既然要写博文，是不是刚开始就随便写写呢？当然不是，一篇排版好内容不是很好的博文相比于内容好排版很乱的博文能够让人更乐于看下去，尤其是那些对代码有洁癖的程序员我相信你更看不下去，那么以下便是我极力推荐的博客排版指南：</p>
<a id="more"></a>

<h3 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h3><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。」</p>
<ol>
<li><p>中英文之间加空格<br>eg. 相信每个程序员都会去全球最大的同性交友网站 GitHub 上逛逛。</p>
</li>
<li><p>中文和数字之间加空格<br>eg. 那些排版很乱的博文估计你连 1 分钟都看不下去。</p>
</li>
<li><p>数字和单位之间不加空格<br>eg. 现在的安卓手机运行内存没有 6G 都装不了几个应用了。<br>eg. 今天的气温又超过了 40°。<br>eg. 之前买的基金昨天一天跌了 5%。</p>
</li>
<li><p>推荐在链接前后加一个空格<br>eg.  我的公众号和博客名称都是 rookiedev，搜索 rookiedev 关注我，点击这里 <a href="http://www.rookiedev.top/">rookiedev</a> 访问个人博客。</p>
</li>
</ol>
<h3 id="标点符号的细节"><a href="#标点符号的细节" class="headerlink" title="标点符号的细节"></a>标点符号的细节</h3><ol>
<li><p>不用为了夸张重复使用标点符号<br>eg. 今年法国夺冠了，华帝刚开始打的一手好牌到最后却变成了一副烂牌，你敢信吗？</p>
</li>
<li><p>中文段落中尽量使用中文标点符号<br>eg. 一篇好的博文绝对离不开好的排版，所以这篇博文应该算是好文了吧。</p>
</li>
<li><p>推荐将引号换成直角引号<br>eg. 你竟然没看过「Java 编程思想」这本书。</p>
</li>
<li><p>推荐引号中还有引号替换成直角双引号<br>eg. 经常有人带着疑惑的目光对我说「你竟然没看过『Java 编程思想』这本书？」</p>
</li>
<li><p>完整的英文整句使用英文标点符号<br>eg. 引用乔布斯说的那句话：「Stay hungry, stay foolish.」</p>
</li>
</ol>
<h3 id="专有名词大小写尽量规范"><a href="#专有名词大小写尽量规范" class="headerlink" title="专有名词大小写尽量规范"></a>专有名词大小写尽量规范</h3><p>eg. Java、MySQL 都是后端开发人员必须要会的，当然也要会一些前端的技术，比如说：HTML5、CSS、JavaScript、jQuery。</p>
<p>还有就是对于一些博文可能存在一篇博文下来就只有一段，看起来很紧凑，如果说在每写完一个知识点隔开一行看起来是不是会更好看些呢，这样一来对于我们从小养成的每一段首行空两格的习惯是不是也可以改了呢，其实你去注意一下那些排版比较好的博文，应该大部分都是这么做的，当然这取决于个人，不喜勿喷。</p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/538faa30b17d">https://www.jianshu.com/p/538faa30b17d</a><br><a href="https://github.com/mzlogin/chinese-copywriting-guidelines">https://github.com/mzlogin/chinese-copywriting-guidelines</a></p>
]]></content>
      <categories>
        <category>写作</category>
      </categories>
  </entry>
  <entry>
    <title>检测端口是否存活除了 telnet 还有 nc 命令</title>
    <url>/%E6%A3%80%E6%B5%8B%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%E9%99%A4%E4%BA%86-telnet-%E8%BF%98%E6%9C%89-nc-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>在之前使用 Windows 系统的时候，我感觉我使用最频繁的两个命令就是 ping 和 telnet。其中 ping 是用来检测是否与主机连通，telnet 用来检测对方主机的端口是否畅通。这两个命令通用的使用场景可能是下面这样的：</p>
<a id="more"></a>

<p>比如说用 A 代表我们本地用来开发的电脑， B 代表远程其中一台服务器，上面部署了我们的后端应用，你在 A 上去访问 B 上部署的应用相关接口，这时候出现访问不了的情况。那么我们可能需要先检查下 A 和 B 的网络是否通畅，也就是说 A 是否能正常访问 B，这时我们可能会用 ping 命令来检查，如果能 ping 通，说明 A 和 B 之间的网络是通畅的，否则需要进一步检查为什么两者网络不通了，当然也不排除服务器设置了禁 ping。</p>
<p>如果能 ping 通的话，接下来可能就需要检测端口是否畅通，也就是使用 telnet 命令来检测，如果端口不通，可以检查下部署的应用是否已经挂了，或者是否有防火墙配置。</p>
<p>但是 telnet 命令的作用是执行 telnet 指令开启终端机阶段作业，并登入远端主机。也就是说当你执行下面的命令之后，会根据指定的端口建立连接，连接成功也就成功了，它不会自己断开。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet server.rookiedev.top 80</span><br></pre></td></tr></table></figure>

<p>后来我在使用 Ubuntu 系统的时候呢，这个命令让我有点苦恼，每次执行这个命令之后都会进入交互模式占据了当前终端，由于它不会自动断开，这就需要我每次测试完了之后自己来手动断开，可是我找了许多断开退出的操作方式，比如说：ctrl + c 或者 ctrl + ] + q，但有时都无法退出来，以至于我每执行一次这个命令都需要关掉一个终端才能断开，然后再另起一个终端来继续操作。当你需要频繁测试的时候，这就太麻烦了。</p>
<p>再到后来使用 macOS 系统的时候，macOS 10.13.1 之后就已经没有这个命令了，需要你自己去安装，不过不知道在 Mac 上面使用这个命令的体验怎么样，至少在 Ubuntu 系统上给我的感觉不太好，当然也有可能是我使用的姿势不对。</p>
<p>至于为什么说不知道在 Mac 上面这个命令的体验怎样呢，因为我遇到了更好的替代命令，也就是今天要说的 Netcat(nc) 命令。如果需要检测对方主机端口是否畅通，可以使用下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -zv server.rookiedev.top 80</span><br></pre></td></tr></table></figure>

<p>其中 -z 表示使用 0 输入/输出模式，只在扫描通信端口时使用，连接成功后立即断开，-v 表示显示指令执行过程。同时看下面截图，命令的打印输出结果也让我们一眼就能判断出端口是否通畅，而且命令执行完之后自动断开连接，不会进入交互模式占据终端的使用权。</p>
<p><img src="/images/nc_host_port.png" alt="nc_host_port"></p>
<p>说实话，这个命令用来检测端口是否通畅可以说是非常方便了，不过这个命令可谓是非常强大，可以实现的功能远不止这么一点，下面就来简单介绍一下该命令。</p>
<p>Netcat（或<code>nc</code>）是一个使用 TCP 或 UDP 协议跨网络连接读取和写入数据的命令行工具，可以用来调试和监控网络连接，扫描端口的开放情况，传输数据等。同时这个命令在 macOS，Ubuntu，Debian，CentOS 上都已经预安装好了。</p>
<p>语法：nc [options] host port</p>
<p>options 有很多，列举比较常用的一些 options 含义：</p>
<ul>
<li>-h 在线帮助。</li>
<li>-i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。</li>
<li>-l 使用监听模式，管控传入的资料。</li>
<li>-n 直接使用IP地址，而不通过域名服务器。</li>
<li>-p&lt;通信端口&gt; 设置本地主机使用的通信端口。</li>
<li>-u 使用 UDP 传输协议。</li>
<li>-v 显示指令执行过程。</li>
<li>-w&lt;超时秒数&gt; 设置等待连线的时间。</li>
<li>-z 使用 0 输入/输出模式，只在扫描通信端口时使用。</li>
</ul>
<p>常见的使用方式有：</p>
<h3 id="开放端口扫描"><a href="#开放端口扫描" class="headerlink" title="开放端口扫描"></a>开放端口扫描</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -zv 192.168.1.104 20-80</span><br></pre></td></tr></table></figure>

<p><img src="/images/nc_scan_port.png" alt="nc_scan_port"></p>
<p>该命令同时还可以接管道符 | 添加过滤条件过滤出开放的端口，在扫描的端口比较多的时候就很用了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -z -v 192.168.1.104 20-80 2&gt;&amp;1 | grep succeeded</span><br></pre></td></tr></table></figure>

<p><img src="/images/nc_scan_port_grep.png" alt="nc_scan_port_grep"></p>
<p>注意：该命令默认情况下和主机建立的是 TCP 连接，如果需要 UDP 的可以通过 -u 参数指定。</p>
<h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p>假如说我们现在想从 A 传输文件 test.txt 到 B，A 的 IP 是 192.168.1.107，B 的 IP 是 192.168.1.104， 那么这时可以在 A 上通过 nc 命令开启监听模式，并且输入为你要传输的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -l 8080 &lt; test.txt</span><br></pre></td></tr></table></figure>

<p> 然后在 B 上建立与 A 的连接，并且将输出重定向到指定的文件，这样一旦连接建立成功就会收到 A 发过来的文件并且重定向到你所指定的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -v 192.168.1.104 8080 &gt; test.txt</span><br></pre></td></tr></table></figure>

<p>接下来你就可以在 B 上看到传输过来的 test.txt 文件了。</p>
<h3 id="聊天会话"><a href="#聊天会话" class="headerlink" title="聊天会话"></a>聊天会话</h3><p>对于聊天会话其实和文件传输差不多，这里也假设 A 发起了监听，然后 B 和 A 建立连接，当连接建立成功之后就可以发起聊天了。在 A 上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -l 8080</span><br></pre></td></tr></table></figure>

<p>在 B 上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc 192.168.1.104 8080</span><br></pre></td></tr></table></figure>

<p>接下来在 A 上输入的内容将会被传输到 B 上，同时 B 上传输的内容会被传输到 A 上，注意下面截图中 server.rookiedev.top 是我用我自己的服务器测试的，你可以用本地的两天主机进行测试，就像上面命令中指定的内网地址一样。</p>
<p><img src="/images/nc_chat_online.png" alt="nc_chat_online"></p>
<p>上面算是列举了几种关于 Netcat 命令的简单用法，至于更复杂的一些用法，感兴趣的话可以去研究看看，总之 Natcat 这个命令还是非常强大的，可以做到的事情非常多。</p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/32c8f9ea0ed9">https://www.jianshu.com/p/32c8f9ea0ed9</a></p>
<p><a href="https://linuxize.com/post/netcat-nc-command-with-examples/">https://linuxize.com/post/netcat-nc-command-with-examples/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式的基本运用</title>
    <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<p>正则表达式，听起来就很高大上，用起来其实挺复杂的，毕竟人家也算是一门语言，但我们在日常开发中如果会一点正则，你会发现有意想不到的效果，对我们开发的效率还是有一定的提高的。刚开始我一直想学习一下一些简单的正则，但每次看完一些资料当时好像明白怎么回事了，但过一段时间没用又忘了，其实说到底就是自己就根本没掌握好，加上又没去实践，当时理解了，长时间不用自然就忘了。所以说学到的知识需要用起来，这样才能加深理解，也不容易忘记。下面主要说一下正则表达式的简单运用，更加高深的正则可能需要花好些时间去系统的学习一番。</p>
<a id="more"></a>

<p>测试正则表达式是否正确可以去这个网址，下面的测试都是基于它测试出来的，地址如下：</p>
<p><a href="https://regex101.com/">正则测试</a></p>
<h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>这是最简单的正则，也就是平常我们习惯的搜索，根据指定字符去文本中搜索完全匹配的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“dee”        ==&gt;    Regular expressions are a <code>dee</code>p language.<br>“deep”    ==&gt;    Regular expressions are a <code>deep</code> language.</p>
</blockquote>
<h2 id="正则中的元字符"><a href="#正则中的元字符" class="headerlink" title="正则中的元字符"></a>正则中的元字符</h2><table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>点号匹配任意单个字符除了换行符</td>
</tr>
<tr>
<td>[ ]</td>
<td>字符种类，匹配方括号内的任意字符</td>
</tr>
<tr>
<td>[^]</td>
<td>否定的字符种类，匹配除了方括号里的字符外其他任意字符</td>
</tr>
<tr>
<td>*</td>
<td>量词符号，表示 &gt;= 0,即匹配 &gt;=0 个在 * 号前的字符</td>
</tr>
<tr>
<td>+</td>
<td>量词符号，表示 &gt;= 1,即匹配 &gt;=1 个在 + 号前的字符</td>
</tr>
<tr>
<td>?</td>
<td>量词符号，表示 &gt;=0,&lt;=1,即 + 号前的字符可出现可不出现</td>
</tr>
<tr>
<td>{n,m}</td>
<td>大括号之前的字符出现 n 到 m 次</td>
</tr>
<tr>
<td>(abc)</td>
<td>字符集, 匹配与 xyz 完全相等的字符串</td>
</tr>
<tr>
<td>&#124;</td>
<td>或运算符,匹配符号前或后的字符</td>
</tr>
<tr>
<td>\</td>
<td>转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \ &#124;</td>
</tr>
<tr>
<td>^</td>
<td>从文本的头部开始匹配</td>
</tr>
<tr>
<td>$</td>
<td>匹配到文本的结尾</td>
</tr>
</tbody></table>
<p>以下面这句话为例，大致说明一下上面表格中的元字符的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<p>1.匹配 e 字符后面接上任意一个字符，包括空格。</p>
<blockquote>
<p>“e.”  ==&gt;  R<code>eg</code>ular <code>ex</code>pr<code>es</code>sions ar<code>e</code> a d<code>ee</code>p languag<code>e.</code>  </p>
</blockquote>
<p>2.匹配 e 字符后面接上包含在中括号中的任意一个字符。</p>
<blockquote>
<p>“e[g,x,e]”  ==&gt;  R<code>eg</code>ular <code>ex</code>pressions are a d<code>ee</code>p language.  </p>
</blockquote>
<p>3.匹配 e 字符后面接上不包含在中括号中的任意一个字符，这里需要注意的是中括号中不能既加上包含字符，又加上不包含的字符，也就是不能这样写：”e[g,^x,^e]” 这样匹配出来的结果和上面匹配的结果一致，如果是把不包含的字符写在前面的话：”e[^g,x,e]” 这样匹配的结果则和下面的结果一致。</p>
<blockquote>
<p>“e[^g,^x,^e]”  ==&gt;  Regular expr<code>es</code>sions ar<code>e</code> a de<code>ep</code> languag<code>e.</code>  </p>
</blockquote>
<p>4.匹配 e 字符后面接上包含中括号中 s 字符任意次，包括 0 次，就是也可以没有字符。</p>
<blockquote>
<p>“e[s]*”  ==&gt;  R<code>e</code>gular <code>e</code>xpr<code>ess</code>ions ar<code>e</code> a d<code>e</code> <code>e</code>p languag<code>e</code>.</p>
</blockquote>
<p>5.匹配 e 字符后面接上包含中括号中 s 字符 1次或多次，就是最少要出现一次。</p>
<blockquote>
<p>“e[s]+”  ==&gt;  Regular expr<code>ess</code>ions are a deep language.</p>
</blockquote>
<p>6.匹配 e 字符后面接上包含中括号中 s 字符 0 次或 1 次，就是可有可无，注意和第 4 个的区别。</p>
<blockquote>
<p>“e[s]?”  ==&gt;  R<code>e</code>gular <code>e</code>xpr<code>es</code>sions ar<code>e</code> a d<code>e</code> <code>e</code>p languag<code>e</code>.</p>
</blockquote>
<p>7.匹配 e 字符后面接上包含中括号中 s 字符指定次数，次数在大括号中指定，可以是一个固定数字，也可以是一个范围。</p>
<blockquote>
<p>“e[s]{1}”  ==&gt;  Regular expr<code>es</code>sions are a deep language.<br>“e[s]{2,3}”  ==&gt;  Regular expr<code>ess</code>ions are a deep language.</p>
</blockquote>
<p>8.匹配 ee 这个字符集出现 1 次到 2 次。</p>
<blockquote>
<p>“(ee){1,2}”  ==&gt;  Regular expressions are a d<code>ee</code>p language.</p>
</blockquote>
<p>9.匹配 ee 这个字符集出现 1 次到 2 次或者匹配 ss 这个字符集出现 1 次到 2 次。</p>
<blockquote>
<p>“(ee){1,2}|ss{1,2}”  ==&gt;  Regular expre<code>ss</code>ions are a d<code>ee</code>p language.</p>
</blockquote>
<p>10.匹配 e. 这两个字符，注意这里的点号并不是表示任意字符，经过转义后只是单纯的一个点号。</p>
<blockquote>
<p>“e\.”  ==&gt;  Regular expressions are a deep languag<code>e.</code></p>
</blockquote>
<p>11.下面第一个表示忽略大小写全局匹配 Re 这个两个字符，第二个表示忽略大小写全局匹配以 Re 开头的字符串。</p>
<blockquote>
<p>“Re/gi”  ==&gt;  <code>Re</code>gular exp<code>re</code>ssions a<code>re</code> a deep language.<br> “^Re/gi”  ==&gt;  <code>Re</code>gular expressions are a deep language.</p>
</blockquote>
<p>12.下面第一个表示忽略大小写全局匹配 re 加上任意字符，第二个表示忽略大小写全局匹配以 re 加上任意字符结尾的字符串。</p>
<blockquote>
<p>“[r,g]e./gi”  ==&gt;  <code>Reg</code>ular exp<code>res</code>sions a<code>re</code> a deep langua<code>ge.</code><br> “[r,g]e.$/gi”  ==&gt;  Regular expressions are a deep langua<code>ge.</code></p>
</blockquote>
<h2 id="正则中的简写字符集"><a href="#正则中的简写字符集" class="headerlink" title="正则中的简写字符集"></a>正则中的简写字符集</h2><table>
<thead>
<tr>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>除换行符外的所有字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有字母数字, 等同于 [a-zA-Z0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>匹配所有非字母数字, 即符号, 等同于: [^\w]</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字: [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字: [^\d]</td>
</tr>
<tr>
<td>\s</td>
<td>匹配所有空格字符, 等同于: [\t\n\f\r\p{Z}]</td>
</tr>
<tr>
<td>\S</td>
<td>匹配所有非空格字符: [^\s]</td>
</tr>
</tbody></table>
<h2 id="前后关联约束"><a href="#前后关联约束" class="headerlink" title="前后关联约束"></a>前后关联约束</h2><p>1.前置约束存在和前置约束排除：(?=…) 和 (?!…)</p>
<p>通俗点说就是对指定格式的前面的元素进行约束，前者是匹配到的元素后面跟着指定格式，后者是匹配到的元素后面不是跟着指定格式。结合例子可能更好理解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“ar(?=\s)” ==&gt;  Regul<code>ar</code> expressions are a deep language //匹配 ar 字符串后面跟着的是空格。<br>“ar(?!\s)” ==&gt;  Regular expressions <code>ar</code>e a deep language//匹配 ar 字符串后面跟着的不是空格。</p>
</blockquote>
<p>上面两个正则都是对匹配到的 ar 字符串进行约束，前者是跟着的是空格，后者跟着的不是空格；前者约束存在，书写格式为 (?=…)，后者约束不存在，书写格式为 (?!…)。</p>
<p>2.后置约束存在和后置约束排除：(?&lt;=…) 和 (?&lt;!…)</p>
<p>和上面的相对应，对指定格式的后面的元素进行约束，前者是匹配到的元素前面跟着指定格式，后者是匹配到的元素前面不是跟着指定格式。同样结合例子理解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“(?&lt;=\s)ar”  ==&gt;  Regular expressions <code>ar</code>e a deep language //匹配 ar 字符串前面跟着的是空格。<br>“(?&lt;!\s)ar”  ==&gt;  Regul<code>ar</code> expressions are a deep language//匹配 ar 字符串前面跟着的不是空格。</p>
</blockquote>
<p>上面两个正则同样都是对匹配到的 ar 字符串进行约束，前者的前面要是空格，后者的前面要不是空格，同样的前者约束存在，书写格式为 (?&lt;=…)，后者约束不存在，书写格式为 (?&lt;!…)，相比上面多了个小于号。</p>
<h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫修饰语, 它是用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是正则表达式的一部分，常用的标志有三种：g，i，m，分别表示全局搜索，忽略大小写，多行匹配。</p>
<p>1.全局搜索 g</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<p>匹配测试结果如下：</p>
<blockquote>
<p>“ar”  ==&gt;  Regul<code>ar</code> expressions are a deep language<br>“ar/g”  ==&gt;  Regul<code>ar</code> expressions <code>ar</code>e a deep language</p>
</blockquote>
<p>上面两者的区别在于第一个是只搜索匹配到的第一个结果，第二个是全局搜索，将所有匹配的结果全部搜索出来。</p>
<p>2.忽略大小写 i</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<p>匹配测试结果如下：</p>
<blockquote>
<p>“Reg”  ==&gt; <code>Reg</code>ular expressions are a deep language<br>“REG/i”  ==&gt; <code>Reg</code>ular expressions are a deep language</p>
</blockquote>
<p>上面两者的区别在于第一个是只搜索字符完全匹配的结果，第二个是搜索忽略大小写的匹配结果。</p>
<p>3.多行匹配 m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg. Regular expressions are a deep language,</span><br><span class="line">Regular expressions are a deep language,</span><br><span class="line">Regular expressions are a deep language.</span><br></pre></td></tr></table></figure>
<p>“^Reg/g” 匹配结果如下：</p>
<blockquote>
<p><code>Reg</code>ular expressions are a deep language,<br>Regular expressions are a deep language,<br>Regular expressions are a deep language.</p>
</blockquote>
<p>“^Reg/gm” 匹配结果如下：</p>
<blockquote>
<p><code>Reg</code>ular expressions are a deep language,<br><code>Reg</code>ular expressions are a deep language,<br><code>Reg</code>ular expressions are a deep language.</p>
</blockquote>
<p>这样一对比两者的区别其实就已经出来了，第一个是全局搜索匹配到的结果，匹配的是第一行的开头，而第二个也是全局搜索匹配到的结果，只不过它是匹配每一行的开头。</p>
<p>以上就是正则表达式的一些基础运用，有了上面的基础，然后在平常开发中积极去尝试写出一些稍微复杂的正则，加强练习，不然只会像我刚开始一样，看完之后过一段时间就忘了，只有不断练习，慢慢的才会对正则有一些感觉。这些正则的基础也是我在 github 上找到一个关于学习正则的项目，然后通过这个项目的学习所掌握的，下面就是这个项目的地址：</p>
<p><a href="https://github.com/zeeshanu/learn-regex">学习正则表达式</a></p>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">整数: ^-?\d+$</span><br><span class="line">正整数: ^\d+$</span><br><span class="line">负整数: ^-\d+$&#96;</span><br><span class="line">纯小写字母: ^([a-z])*$</span><br><span class="line">纯大写字母: ^([A-Z])*$</span><br><span class="line">用户名: ^[\w\d_.]&#123;4,16&#125;$</span><br><span class="line">数字和英文字母: ^[a-zA-Z0-9]*$</span><br><span class="line">数字和英文字母和空格: ^[a-zA-Z0-9 ]*$</span><br><span class="line">密码: ^(?&#x3D;^.&#123;6,&#125;$)((?&#x3D;.*[A-Za-z0-9])(?&#x3D;.*[A-Z])(?&#x3D;.*[a-z]))^.*$</span><br><span class="line">邮箱: ^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;)*$</span><br><span class="line">IP4 地址: ^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</span><br><span class="line">URL: ^(((http|https|ftp):\&#x2F;\&#x2F;)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\&#x2F;+&#x3D;%&amp;_\.~?\-]*))*$</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 MySQL 索引(一)</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MySQL-%E7%B4%A2%E5%BC%95-%E4%B8%80/</url>
    <content><![CDATA[<h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>在日常开发中，如果遇到一个 SQL 查询比较慢的时候，我们可能会说给这个 SQL 的查询字段加个索引，那为什么给字段加个索引查询就变快了，索引到底是什么？或许只有清楚的知道索引是什么我们才能明白为什么加上索引之后查询就变快了。</p>
<a id="more"></a>

<p>索引，简单的来说就像是一本书的目录，通过目录你能很快就知道其中一篇文章具体是在哪一页，而如果没有目录的话那你只能随机去翻，或者一页一页去翻直到翻到你想找的那篇文章为止。当然这样对比来说的话你可能只是脑子里有这样一个概念，知道索引可以加快查找速度而已，但其实还是没有弄清楚索引到底是什么。</p>
<p>更具体的来说，索引其实是一种数据结构模型，我们常用的有数组，哈希，链表，栈，队列，还有一些我们可能用的不多但是又比较重要的，比如说堆，树，跳表等，这些数据结构都有各自自己的特性。</p>
<p>简单的拿数组来说，数组查询较快，插入删除则比较慢，因为需要移动插入位置或者删除位置元素后面的所有元素；</p>
<p>链表，元素之间通过指针链接在一起，每次只能通过第一个元素依次遍历才能找到需要的元素，因此查询比较慢，但这种结构反而插入删除元素更快，插入或删除元素只需要改变插入元素位置前后元素的指针即可，而不需要挪动其他元素；</p>
<p>哈希结构其实就是我们 Java 中常用的 Map 的结构了，通过 key-value 的方式进行存储，存储的时候用 key 按照指定的函数来计算出 value 的存储位置，需要查询的时候也是通过 key 来计算出存储位置，然后再根据计算出的位置读取 value，这种结构更多的是用在需要等值查询的地方。</p>
<p>其他结构这里就不一一介绍了，从前面简单的介绍可以看出，每种结构都有它自己的特性，日常使用中可以根据我们的需要来选择具体的结构。</p>
<h4 id="InnoDB-的索引结构模型是什么"><a href="#InnoDB-的索引结构模型是什么" class="headerlink" title="InnoDB 的索引结构模型是什么"></a>InnoDB 的索引结构模型是什么</h4><p>上面已经提到索引是一种数据结构模型，那 MySQL 的索引是什么数据结构模型？在前面的文章中已经介绍过 MySQL 是由 Server 层和存储引擎层组成，而索引是由存储引擎层实现的，MySQL 的存储引擎又有很多种，比如 InnoDB、MyISAM、Memory 等，不同的存储引擎采用的索引数据结构也不一样，我们最常用的则是 InnoDB，InnoDB 的索引它采用的是 B+ 树的数据结构。什么是 B+ 树，它其实是树结构中的一种，当然树有很多种，二叉树，二叉查找树，平衡二叉树，B 树，B+ 树等等。</p>
<p>那为什么选择 B+ 树，先来看如果选择二叉树，根据二叉树的特点，每个节点都只有左右两个子节点，对于数据量很大的话，这棵索引树的高度也就很高了。如果我们要查找一条数据，则需要从根节点开始向下遍历，由于索引也是存储在磁盘上的，而刚好你要查找的数据可能在叶子节点，那每一次向下查找子节点的过程都要读取一次磁盘，那么在一次查询中，树的高度就决定了需要读取多少次磁盘，读取磁盘其实是很慢的操作，尤其是在以前还是机械硬盘的时代，这种查询效率肯定是不能接受的，因此就需要减少读取磁盘的次数，也就是减少树的高度，这样的话就只能采用多叉树。</p>
<p><img src="/Users/xxx-xifan/Dropbox/drawio/images/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p>
<p>B 树和 B+ 树都是多叉树，又为什么选择 B+ 树而没有选择 B 树，其实对于 B 树来说，它的所有节点大小都是一样的，而且都存储索引的值和还有具体的数据，每一个索引键都只出现在一个节点中，因此查询数据时每次读取一个节点到内存进行判断，如果不是要查询的数据，则读取下一个节点到内存，替换当前的节点内容，这种查询效率其实是不稳定的，最好的查询是数据刚好在根节点，一次读取就能够查到，最差的查询是数据在叶子节点或者不存在，则需要频繁的进行内存数据交换，直到读到叶子节点的数据或没有查到数据。</p>
<p><img src="/Users/xxx-xifan/Dropbox/drawio/images/B%E6%A0%91.png" alt="B树"></p>
<p>由于 B 树的查询效率不够稳定，且每个节点都存放数据，存放的索引内容就很有限，所以在 B 树的基础上对 B 树进行了改进，引入了 B+ 树，B+ 树它所有的内部节点都不存储数据，只存储索引键值，数据都统一存放在叶子节点，因此一个内部节点中能够存储的索引键就大大增加了，而且这样一来，查询效率基本上是一致的，都需要根据索引键值从根节点依次扫描到叶子节点获取数据，同时 B+ 树将所有的叶子节点通过指针链接起来，这样也就能够实现索引的区间查询。</p>
<p><img src="/Users/xxx-xifan/Dropbox/drawio/images/B+%E6%A0%91.png" alt="B+树"></p>
<h4 id="主键索引和非主键索引的区别"><a href="#主键索引和非主键索引的区别" class="headerlink" title="主键索引和非主键索引的区别"></a>主键索引和非主键索引的区别</h4><p>我们应该都知道索引又分为主键索引和非主键索引，也叫聚簇索引和非聚簇索引，从上面我们已经知道 B+ 树所有的内部节点都不存储数据，只存储索引键值，数据统一存储在叶子节点，对于主键索引来说，叶子节点存储的就是整行数据记录，而对于非主键索引来说叶子节点存储的是主键的值。</p>
<p><img src="/Users/xxx-xifan/Dropbox/drawio/images/%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95.png" alt="非主键索引"></p>
<p>通过这点我们也就知道我们平常为什么最好通过主键字段来进行查询，因为通过主键索引字段来查询，可以直接查询到叶子节点中整行数据记录，而通过非主键索引字段进行查询，则需要先从非主键索引树中查询到叶子节点中主键的值，然后再通过主键的值去主键索引树中查询到整行数据记录，这也就是我们日常所说的回表查询的过程。</p>
<h4 id="索引是否越多越好"><a href="#索引是否越多越好" class="headerlink" title="索引是否越多越好"></a>索引是否越多越好</h4><p>索引既然能提高我们的查询效率，那是不是涉及到每一个字段的查询，都给该字段建一个索引，这样不就极大提高查询效率了吗，但事实却并非如此，像这样虽然能够提高查询效率，但索引是需要维护的。</p>
<p>因为我们的数据并非是一直不变，我们在一张表上不仅有查询，还会有新增，更新，删除，比如说新增一条数据，如果说这条数据涉及到的索引键字段需要插入到某个索引节点内的中间位置，这时就需要将该位置后面的索引依次往后移动，空出位置给新的索引键，更差的是刚好这个索引节点所在页满了，那则需要新申请一个页，然后将该页的部分数据移到新的页上去，这个过程也称为页分裂，本来数据是存在一个页上，现在需要两个页来存储，整体的空间利用率就下降了。</p>
<p>更新也是一样的，如果更新的是索引键字段，而且更新之后为了保证索引键有序，这个索引键可能就不应该放在原来的位置，这时也需要进行移动，移动的过程中同样也可能会涉及到页分裂。</p>
<p>对于删除则会导致页上的利用率降低，当利用率降低到一定程度后，为了提高页的利用率，会将相邻两个页上的数据合并到一个页上，这个过程则称为页合并。这些内部的操作其实都会影响数据新增，更新，删除的性能，索引建的越多，每一次的新增，更新和删除调整索引的时间也会更多，这样一来就会间接影响我们的新增，更新和删除性能，所以说并不是索引建的越多就越好，还是需要平衡之后做出取舍。</p>
<h4 id="为什么主键都建议采用自增"><a href="#为什么主键都建议采用自增" class="headerlink" title="为什么主键都建议采用自增"></a>为什么主键都建议采用自增</h4><p>在我们的数据库表中，一般每张表都有设置一个主键字段，就算没有设置，InnoDB 也会默认帮我们创建一个 RowId 的自增主键字段。对于主键字段我们通常会采用自增的方式，那么我们有去考虑过为什么这样做吗？</p>
<p>其实通过上面对索引的介绍已经能够知道答案，对于自增的主键字段，它可以避免主键索引发生频繁的页分裂和页合并，因为是自增长的，所以字段天然就是有序的，在新增数据的时候都是直接在索引节点内部的最后面直接追加，不用考虑往中间插入的情况，而如果采用业务字段作为主键字段的话，业务字段很难保证每次新增的数据都是有序的，那么就会涉及到内部节点索引的移动，间接带来页分裂和页合并的问题。</p>
<p>尤其是有的表使用 UUID 来当做主键，这种主键不仅是无序的，而且可识别性很差，同时生成的 UUID 字段长度还很长，占用的空间无疑比自增的数字要大，对于非主键索引的叶子节点存的又都是主键的值，这也无形中增加了数据库的存储空间。也就是说主键字段采用自增的数字不仅从性能上来说更好，同时也能够减少一定的存储空间。</p>
<p>当然有些情况下我们还是会采用业务字段来作为主键字段，比如说整个表就只有一个索引字段，并且是唯一索引，也没有其他的非主键索引，同时又需要频繁的通过该字段来查询数据，那这时我们就可以直接将该字段设为主键索引字段，这样可以减少频繁的回表过程，提高查询效率，这时牺牲一点存储空间也无所谓了。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 MySQL 索引(二)</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MySQL-%E7%B4%A2%E5%BC%95-%E4%BA%8C/</url>
    <content><![CDATA[<h4 id="索引字段的查询方式"><a href="#索引字段的查询方式" class="headerlink" title="索引字段的查询方式"></a>索引字段的查询方式</h4><p>上篇文章我们介绍了什么是索引，索引的结构以及一些关于索引的细节问题，那  MySQL 又是怎么利用索引进行查询的，来看一个具体的查询示例，下面是 users 表的建表语句:</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;users&#96; (</span><br><span class="line">  &#96;id&#96; bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;identity&#96; varchar(18) NOT NULL COMMENT &#39;身份证号&#39;,</span><br><span class="line">  &#96;name&#96; varchar(32) NOT NULL COMMENT &#39;用户名&#39;,</span><br><span class="line">  &#96;age&#96; int DEFAULT &#39;0&#39; COMMENT &#39;年龄&#39;,</span><br><span class="line">  &#96;sex&#96; tinyint(1) NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;性别 0：男，1：女&#39;,</span><br><span class="line">  &#96;birthday&#96; date DEFAULT NULL COMMENT &#39;生日&#39;,</span><br><span class="line">  &#96;address&#96; varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;地址&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;idx_identity&#96; (&#96;identity&#96;),</span><br><span class="line">  KEY &#96;idx_name&#96; (&#96;name&#96;, &#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;0 COMMENT&#x3D;&#39;用户表&#39;;</span><br><span class="line"># 初始化数据</span><br><span class="line">INSERT INTO users VALUES</span><br><span class="line">(1, &#39;362422199401014501&#39;, &#39;张三&#39;, 40, 0, &#39;1994-01-01&#39;, &#39;&#39;),</span><br><span class="line">(2, &#39;362422199402024502&#39;, &#39;李四&#39;, 27, 0, &#39;1994-02-02&#39;, &#39;&#39;),</span><br><span class="line">(3, &#39;362422199403034503&#39;, &#39;王五&#39;, 27, 1, &#39;1994-03-03&#39;, &#39;&#39;),</span><br><span class="line">(4, &#39;362422199404044504&#39;, &#39;赵六&#39;, 27, 1, &#39;1994-04-04&#39;, &#39;&#39;),</span><br><span class="line">(5, &#39;362422199505054505&#39;, &#39;王五&#39;, 26, 1, &#39;1994-05-05&#39;, &#39;&#39;);</span><br></pre></td></tr></table></figure>

<p>从建表语句可以看到 users 表有三个索引，主键索引 id，两个普通索引 idx_identity 和 idx_name，假设这三棵索引树目前对应的索引结构分别如下:</p>
<p><img src="/Users/xxx-xifan/Dropbox/drawio/images/id%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%A0%91.png" alt="id主键索引树"></p>
<p>![identity 索引树](/Users/xxx-xifan/Dropbox/drawio/images/identity 索引树.png)</p>
<p>![name, age 联合索引树](/Users/xxx-xifan/Dropbox/drawio/images/name, age 联合索引树.png)</p>
<p>现在有这样一个 SQL 查询语句，根据身份证号查询用户信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users where identity &#x3D; &#39;362422199403034503&#39;;</span><br></pre></td></tr></table></figure>

<p>在 identity 条件字段上建有索引，于是可以利用索引加快搜索，通过 idx_identity 索引树定位到第二个叶子节点，取出第一条记录 4502，小于 4503 不满足条件，取下一个值 4503，满足条件，取出主键 id = 3，然后回到主键索引树中查询得到 id = 3 的数据 data3，再取下一个值 4504，大于 4503 不满足条件，查询结束，最终查到 identity = ‘362422199403034503’ 的数据记录 data3。</p>
<p>在上面的查询过程中，通过 idx_identity 索引树查询到主键值后，由于我们需要查询这条记录完整的数据值，因此还需要利用主键字段的值回到主键索引树再搜索一次才能得到具体的数据，这个过程就是回表的过程。</p>
<h4 id="索引的几种优化方式"><a href="#索引的几种优化方式" class="headerlink" title="索引的几种优化方式"></a>索引的几种优化方式</h4><ol>
<li><p>索引覆盖<br>在上面的查询中，如果我们的业务需求主要是根据身份证查询用户姓名，而不需要其他字段的值，比如下面的 SQL 语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name from users where identity &#x3D; &#39;362422199403034503&#39;;</span><br></pre></td></tr></table></figure>

<p>这时我们就可以建一个 (identity, name) 的联合索引，达到索引已经包含要查询的字段，这时就可以利用索引覆盖的特性，而不需要再到主键索引树中查询该记录完整的数据，减少回表的过程，极大的提高了查询效率。当然建立联合索引也是有代价的，首先存储空间毫无意外增加了，同时索引的维护代价也增加了，现在需要维护两个字段的索引，任意一个字段发生变化都有可能需要调整索引的结构，但一般如果对性能的提升很大的话，牺牲一点存储空间也就无所谓了。<br>接着看下面两个 SQL 语句是否也能使用索引覆盖的特性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. select id, identity, name from users where identity &#x3D; &#39;362422199403034503&#39;;</span><br><span class="line">2. select id, identity, name from users where identity &#x3D; &#39;362422199403034503&#39; and age &#x3D; 30;</span><br></pre></td></tr></table></figure>

<p>对于 SQL1 来说，我们需要查询 id，identity，name 三个字段的值，(identity,name) 联合索引已经包含了 identity，name 两个字段，id 也是可以从叶子节点中直接获取得到，因此是可以使用到索引覆盖的特性。</p>
<p>对于 SQL2 来说，虽然查询的字段值都已经覆盖了，但还有一个 age = 30 的条件，age 字段的值光从联合索引是没办法拿到的，只能通过先找到满足 identity 条件的主键的值，再通过主键值搜索主键索引树拿到整条记录的值来判断 age 是否满足条件，满足条件则返回，不满足则丢弃，接着继续获取下一个满足 identity 条件的值。</p>
</li>
</ol>
<p>   值得注意的是覆盖索引指的不仅仅是要覆盖查询的字段，同时条件字段也需要覆盖才能够利用索引覆盖的特性。</p>
<ol start="2">
<li><p>最左前缀<br>假设现在系统里面既有根据 name 字段查询用户信息，又有根据 name 和 age 字段的高频查询，这时我们就可以直接建 (name, age) 的联合索引，而不需要在 name 字段上单独建一个索引，因为根据最左前缀原则，不管是满足索引的左边字段的一部分还是左边一部分字段或者是完整的索引字段都能够利用该索引来定位记录。比如说 (name, age) 的联合索引对于下面的 SQL 语句来说都能够使用该索引来加快搜索:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users where name like &#39;王%&#39;;</span><br><span class="line">select * from users where name &#x3D; &#39;王七&#39;;</span><br><span class="line">select * from users where name &#x3D; &#39;王七&#39; and age &#x3D; 27;</span><br></pre></td></tr></table></figure>

<p>但如果后期发现还需要根据 age 字段来查询用户信息的需求，对应 SQL 语句如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users where age &#x3D; 26;</span><br></pre></td></tr></table></figure>

<p>可以发现上面的 SQL 已经没法使用到 (name, age) 的联合索引了，于是你不得不再建一个单独的字段索引，这时你可能就直接在 age 字段上建一个索引，这样就既可以根据 name 字段查询用户信息，又可以满足 name 和 age 字段的联合查询，同时也满足了根据 age 字段查询用户信息的需求。</p>
</li>
</ol>
<p>   但其实还有一种组合方式，建一个 (age, name) 的联合索引，然后在 name 字段上单独建一个索引，这种组合也是可以满足上面的查询需求的，这时我们应该怎么去选择呢，其实可以根据字段的长度来看，由于 name 字段明显要比 age 字段占用的空间要大，而 (age, name) 联合索引加 name 单字段的索引组合，两棵索引树上都要存储 name 字段，这时总的占用空间就比 (name, age) 联合索引加 age 单字段索引的占用空间要大了，因此考虑到空间占用就可以采用第一种组合方式。</p>
<ol start="3">
<li><p>索引下推<br>在上面的 users 表中，我们建了一个 (name, age) 的联合索引，但现在系统中又有下面这样的查询语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users where name like &#39;王%&#39; and age &#x3D; 26;</span><br></pre></td></tr></table></figure>

<p>![name, age 联合索引树](/Users/xxx-xifan/Dropbox/drawio/images/name, age 联合索引树.png)</p>
<p>这时你会发现满足最左前缀的原则，使用 ‘王’ 去 (name, age) 联合索引树上定位到第一个满足 name 字段以王字打头的记录，然后依次遍历下去，寻找同时满足 age = 26 的记录。</p>
</li>
</ol>
<p>   对于上面这种情况在 MySQL 5.6 之前，它的的执行过程是这样的:</p>
<p>   1.使用 ‘王’ 去 (name, age) 联合索引树上定位到第一个满足 name 字段以王字打头的记录</p>
<p>   2.这时定位到第二个叶子节点，找到 (王五, 26) 的主键值 5</p>
<p>   3.通过主键值 5 再去主键索引树中搜索得到整条记录的值，判断 age = 26 是否成立</p>
<p>   4.再取下一个满足 name 字段以王字打头的记录 (王五, 27) 的主键值 3</p>
<p>   5.重复第三步的过程，发现 age = 26 不成立，结束查询</p>
<p>   你可以看到每次查询得到满足 name 字段以王字打头的记录时都需要回到主键索引树上去查询得到完整数据后，再判断 age = 26 的条件是否成立，但其实对于联合索引 (name，age) 来说，从索引中的值就已经可以知道 age = 26 的条件是否成立，对于不满足条件的可以直接丢弃，取下一个记录进行判断，而不用频繁的进行回表。</p>
<p>   因此在 MySQL 5.6 之后做了一个索引下推(ICP)的优化，在 “仅能利用最左前缀索引的场景” 下(无法能利用全部联合索引)，对不在最左前缀索引中的其他联合索引字段加以利用，在遍历索引时，由只传入可以利用到的字段值，改成了多传入下推字段值进行过滤，过滤会减少遍历索引查出的主键条数，从而减少回表次数，提升整体性能。引入索引下推优化之后，执行过程变成下面这样:</p>
<p>   1.使用 ‘王’ 去 (name, age) 联合索引树上定位到第一个满足 name 字段以王字打头的记录</p>
<p>   2.定位到第二个叶子节点，找到 (王五, 26)，判断 age = 26 满足条件，取主键值 5 的记录回表查询整条数据的值</p>
<p>   3.再取下一个满足 name 字段以王字打头的记录 (王五, 27)，判断 age = 26 条件不满足，直接丢弃，结束查询</p>
<p>   可以看到通过引入索引下推的优化之后，由之前的回表两次变成了仅回表一次，尤其当满足最左前缀而其他索引字段不满足条件的数据记录很多的时候，就会大大减少回表的次数，性能提升更明显。</p>
<p>MyISAM 和 InnoDB 存储引擎索引实现</p>
<p>上次只提到了 InnoDB 的索引实现，这里再补充下 MyISAM 存储引擎的索引实现，首先 MyISAM 和 InnoDB 两个存储引擎的索引实现方式都是基于 B+ 树，不同点是:<br>MyISAM：不管主键索引还是二级索引，叶子节点 data 存放的都是数据记录的地址，因此对于 MyISAM 存储引擎来说，就不存在回表这一说，通过二级索引可以直接获取到完整的数据值，二级索引在结构上和主键索引没有任何区别，只不过主键索引要求 key 是唯一的，而二级索引的 key 可以重复。<br>InnoDB：InnoDB 的数据文件本身就是索引文件，主键索引树的叶子节点 data 保存了完整的数据记录，而二级索引树 data 存放的则是相应记录主键的值，所以每次只能通过主键的值去回到主键索引树上查询得到完整的数据。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>谈谈 Java 中的引用</title>
    <url>/%E8%B0%88%E8%B0%88-Java-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>Java 中除了八种基本类型(byte, short, int, long, float, double, char, boolean)之外就是引用类型，而引用类型又有强引用，软引用，弱引用和幻象引用。可能我们平常代码中用到最多的是强引用，对于其他的一般用的很少，但有些框架中还是会用到的，所以我们还是有必要去了解下这块的东西，这有利于我们更好地去理解相关的框架原理。下面我们就来分别看下这几类引用都各有什么特性：</p>
<a id="more"></a>

<p>声明：下面的代码测试是基于 java 11.0.8 版本下运行。</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>强引用算是我们经常使用的，也是我们平常代码中常见的普通对象引用，比如说下面代码中的对象引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceObject referenceObject1 = <span class="keyword">new</span> ReferenceObject();</span><br><span class="line">referenceObject1 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中 ReferenceObject 是一个普通的对象，referenceObject1 就是强引用，强引用所引用的对象实例不会被 GC 回收，JVM 宁愿抛出OutOfMemoryError 运行时错误让程序异常终止，也不会回收强引用所指向的对象实例。随后显式地将 referenceObject1 赋值为 null 之后，那么当第一行中创建的对象实例已经没有引用指向该实例了，那么 GC 将会回收该对象实例所在的内存空间。</p>
<p>除了强引用之外，剩下的软引用，弱引用，幻象引用(虚引用)都是继承自 Reference 抽象类，对应的类分别是 SoftReference，WeakReference，PhantomReference，下面我们一个一个看下这几个引用。</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用，也就是通过 SoftReference 来实现，这类引用相对强引用来说更弱一些，这类引用在内存充足的情况下不会被回收，通常是在内存不足产生 OutOfMemoryError 之前 GC 将决定回收这类引用所指向的对象实例。下面让尝试模拟这种情况的发生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String soft = <span class="keyword">new</span> String(<span class="string">&quot;soft&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(soft);</span><br><span class="line">soft = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// print soft</span></span><br><span class="line">System.out.println(softReference.get());</span><br></pre></td></tr></table></figure>

<p>上面代码中第一行创建的 String 对象实例在将 soft 强引用显式地赋值为 null 之后就只有 softreference 软引用指向该对象实例了，然后就算我们主动发起 GC，GC 在内存充足的情况下也不会去回收软引用指向的这个对象实例，这时是还可以通过 softReference 的 get 方法来获取该对象的。接下来我们创建更多的对象实例模拟消耗更多的内存，直到内存不足产生 OutOfMemoryError 之前 GC 将会回收 softReference 指向的对象实例，一旦 GC 决定回收这类引用指向的对象实例，那么我们再去通过 get 方法获取该对象将会返回 null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">  String string = <span class="keyword">new</span> String(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">  list.add(string);</span><br><span class="line">  <span class="comment">// 只有当 JVM 发现堆中内存不够用了，快要发生 OOM 时才会去回收软引用</span></span><br><span class="line">  <span class="keyword">if</span>(softReference.get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// print true</span></span><br><span class="line">    System.out.println(softReference.get() == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中是模拟创建无限多的对象来占用更多的内存，直到 GC 决定将 softReference 引用指向的对象实例才停止创建，也就是我们通过 get 方法得到的是个 null 来判断 GC 已经决定将该对象实例进行回收。</p>
<p>注意：上面的代码最好是加上 JVM 启动参数 ‘-Xms3m -Xmx3m’ 来配置堆内存的初始大小和最大堆内存为 3m，不然可能需要执行有一段时间才会停下来。</p>
<p>软引用一般适合用来缓存那些在内存中比较难以构建的数据，一旦构建之后就会缓存下来，一般也不会将该缓存删掉，只会在内存不足的情况下才会移除该缓存。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用是通过 WeakReference 实现，和 SoftReference 比较类似，只是它相对软引用来说更弱，在下一次的 GC 就会将这类引用指向的对象回收掉，而不会像软引用一样只会在内存不足的情况下才决定回收。同样的看下面代码测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String weak = <span class="keyword">new</span> String(<span class="string">&quot;weak&quot;</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(weak);</span><br><span class="line">weak = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// print weak</span></span><br><span class="line">System.out.println(weakReference.get());</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 在经过一次 GC 标记之后，弱引用所指向的对象内存实例将会被回收</span></span><br><span class="line"><span class="comment">// print true</span></span><br><span class="line">System.out.println(weakReference.get() == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中 weakReference 所指向的对象实例在发起一次 GC 之后再次通过 get 方法返回的就是 null 了。</p>
<p>对于弱引用 Java 还提供了一个 WeakHashMap 的数据结构，和我们常用的 HashMap 很像，区别就是它是使用 WeakReference 作为 key，而且如果 WeakHashMap 中 key 被 GC 回收之后，对应的 entry 也会被自动移除。可以通过下面的代码来验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String weakKey = <span class="keyword">new</span> String(<span class="string">&quot;weakKey&quot;</span>);</span><br><span class="line">WeakHashMap&lt;String, Boolean&gt; weakHashMap = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">weakHashMap.put(weakKey, <span class="keyword">true</span>);</span><br><span class="line">weakKey = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 在经过一次 GC 之后，GC 就已经决定将弱引用所指向的对象进行回收，</span></span><br><span class="line"><span class="comment">// 对应的 entry 也会被自动移除，weakHashMap 为空</span></span><br><span class="line"><span class="comment">// print true</span></span><br><span class="line">System.out.println(weakHashMap.isEmpty());</span><br></pre></td></tr></table></figure>

<p>通过上面的代码测试可以看到在 GC 决定将弱引用所指向的对象进行回收之后，相应的 weakHashMap 中的 entry 也被自动移除了，weakHashMap 的大小为 0。这个特性其实可以用于创建本地锁，锁在使用时不会被回收，一旦锁使用完了之后一段时间就可能会被回收掉了，下次再次获取时不存在则创建，存在则直接返回即可，也就是将创建的锁资源交给 JVM 来管理，这样就避免了大量锁创建之后没有得到及时的回收占用太多的内存空间。</p>
<p>同样的，和软引用一样，弱引用也适合用来作缓存，只不过适用的场景不一样，弱引用则适合那种资源创建快速，同时缓存时间较短的情况。</p>
<h3 id="幻象引用"><a href="#幻象引用" class="headerlink" title="幻象引用"></a>幻象引用</h3><p>对于幻象引用，也可以称为虚引用，这类引用通过 get 方法得到的始终是个 null，防止恢复一个几乎已经删除的对象。幻象引用一般是配合引用队列一块使用，不然好像也没有什么其他用处了，当幻象引用所指向的对象的物理内存被回收时，幻象引用将会进入队列，接下来就可以轮询该队列做一些对象内存被回收之后的动作。可通过下面的代码测试验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferenceObject referenceObject = <span class="keyword">new</span> ReferenceObject();</span><br><span class="line">ReferenceQueue&lt;ReferenceObject&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">PhantomReference&lt;ReferenceObject&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(referenceObject, referenceQueue);</span><br><span class="line"><span class="comment">// print null</span></span><br><span class="line">System.out.println(phantomReference.get());</span><br><span class="line">referenceObject = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">// print true</span></span><br><span class="line">System.out.println(phantomReference.isEnqueued());</span><br><span class="line"><span class="comment">// print true</span></span><br><span class="line">System.out.println(referenceQueue.poll() == phantomReference);</span><br></pre></td></tr></table></figure>

<p>从上面代码中可以看到幻象引用调用 get 方法得到的是个 null，在产生 GC 之后，幻象引用指向的对象物理内存被回收，幻象引用进入队列，通过队列的 poll 方法拿到的和幻象引用的地址是相同的。</p>
<p>注：这里你可以尝试在 ReferenceObject 类中重写 finalize 方法，finalize 方法中先采用空实现看上面的运行结果，然后在 finalize 方法中加上调用父类的 finalize 方法的操作，这时再看运行结果，可以去研究下为什么会出现这种情况(我也还没搞懂为啥，可能和 JVM 的优化有关吧)。</p>
<p>幻象引用的作用主要是能够确定对象何时从内存中删除，当我们有一个业务操作需要分配比较大的内存时，我们就可以采用幻象引用来监视这个操作，通过幻象引用来实现只有当上一个业务操作分配的大内存被回收了之后才进行下一次的大内存分配操作，这样就能避免上一个业务操作分配的大内存还没被回收再次分配一个大内存有可能导致 OOM 的情况发生。</p>
<p>好了，到这里引用的四种类型就已经介绍完了，从上面的整体描述来看，引用类型主要是和 GC 回收引用指向的对象的时机有关，不同的引用类型所指向的对象实例在不同的时间点，不同的条件下被回收，然后我们就可以根据这些特性来做匹配我们业务类型的事情，其实我是想通过这个来引出接下来我想写的和锁有关的知识点，上面弱引用中我已经稍微提到了，下篇文章开始我们就一起来看下和锁相关的介绍。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java 中常见的细粒度锁实现</title>
    <url>/Java-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%86%E7%B2%92%E5%BA%A6%E9%94%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>上篇文章大致说了下 ReentrantLock 类的使用，对 ReentrantLock 类有了初步的认识之后让我们一起来看下基于 ReentrantLock 的几种细粒度锁实现。</p>
<a id="more"></a>

<p>这里我们还是接着用之前 <a href="https://mp.weixin.qq.com/s/LhDnmnE5fy2tcgB5a0xI4g">synchronized 关键字加锁实现线程安全</a> 文章中举的账户扣款的例子好了，不过这里为了更贴近系统的功能实现，我们换一下思路，功能实现不变，只是把钱转换成我们系统中的使用的礼券好了，用户每次在系统中购买某项功能需要支付一定的礼券。那既然要实现细粒度锁，那就意味着不同用户账户扣除礼券的操作互不影响，只需要保证相同账户下的礼券扣除操作是线程安全的即可，而且仅仅是扣除礼券的那一小部分的代码块，对于账户的校验我们可以接受并发执行。</p>
<p>–分段锁</p>
<p>我们先来想象这样一个场景好了，可能我们的系统只有那么一小部分的忠实用户，他们更愿意在我们的系统中通过礼券购买，从而使用一些特殊的功能，更多的用户只是在使用我们系统的基本功能。接下来我们需要考虑这样两种情况：</p>
<ul>
<li>同一用户在同一时间通过礼券购买系统的付费功能，也就是在扣款时需要保证线程安全的情况</li>
<li>不同用户在同一时间通过礼券购买系统的付费功能，这是系统的付费用户并发量，这个和我们需要创建的细粒度锁的数量有关。</li>
</ul>
<p>基于上面我们描述的场景可以看出，对于第一种情况只要有礼券消费就可能存在，虽然不常出现但肯定存在，那么我们就需要通过细粒度锁来控制礼券的扣除操作。而第二种情况也是存在的，但是由于付费用户的基数不是很大，所以这种情况也可以说很少了，这也就意味着在同一时间我们实际要创建的锁的数量并不是很多。这里稍微解释一下，因为在礼券消费的时候我们肯定是要创建锁来保证线程安全，而且锁是和用户绑定的，同一时间对于同一用户只会创建一把锁，而同一时间如果很多用户都在消费礼券，那这一刻就是有多少用户就需要创建多少把锁了。</p>
<p>好了，通过上面的分析我们来看下分段锁是如何实现细粒度锁的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SegmentLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认预先创建的锁数量.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_LOCK_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Integer, ReentrantLock&gt; lockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SegmentLock</span><span class="params">(Integer count, <span class="keyword">boolean</span> isFair)</span> </span>&#123;</span><br><span class="line">        init(count, isFair);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Integer count, <span class="keyword">boolean</span> isFair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="keyword">null</span> &amp;&amp; count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.DEFAULT_LOCK_COUNT = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 预先初始化指定数量的锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.DEFAULT_LOCK_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lockMap.put(i, <span class="keyword">new</span> ReentrantLock(isFair));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReentrantLock <span class="title">get</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.lockMap.get((key.hashCode() &gt;&gt;&gt; <span class="number">1</span>) % DEFAULT_LOCK_COUNT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">this</span>.get(key);</span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">this</span>.get(key);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于上一篇文章中我们对 ReentrantLock 已经有了了解了，上面的代码看起来就很简单，SegmentLock 类构造方法中调用 init 方法预先初始化指定数量的锁，然后就是提供了锁的获取以及加锁和解锁的方法。这里需要注意的一个地方就是我们获取锁的方式是：使用 key 的 hashCode 值向右无符号位移一位得到的值再对锁的数量取余，然后再用这个值作为索引去 Map 中获取锁。至于这里为什么要无符号位移呢，那是因为 hashCode 值有可能是得到一个负数，取余之后还是一个负数，用一个负数索引去 Map 中取值得到就是 null，会导致后面在使用时产生 NPE。接下来一起来看看如何使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SegmentLock&lt;String&gt; segmentLock = <span class="keyword">new</span> SegmentLock&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(String userId, <span class="keyword">int</span> amount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;verify that the account is normal...&quot;</span>);</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">  ReentrantLock lock = segmentLock.get(userId);</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;enter the deduction code block&quot;</span>);</span><br><span class="line">    Integer userAccountBalance = accountMap.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (userAccountBalance &gt;= amount) &#123;</span><br><span class="line">      <span class="comment">// deduction</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">      userAccountBalance -= amount;</span><br><span class="line">      accountMap.put(userId, userAccountBalance);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction success&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction failed, insufficient account balance.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从使用代码中可以看出，基本上和 ReentrantLock 的使用一样，只是由于我们预先创建好了一定数量的锁，直接根据用户 id 取锁，然后再进行加锁解锁的操作，这可以减少锁创建的性能开销，这对于并发付费的用户量不大的情况下性能会有很好的提升，这也是为什么采用分段锁的原因。</p>
<p>这里有个问题就是如果刚好两个用户 id 的 hash 值一样或者说 hash 值取余的结果一样，那么这两个用户获取的就是同一把锁，那在同时进行礼券消费时，一个用户先获取了锁并执行了加锁操作，另一个用户也获取了这把锁，在执行加锁的时候就需要等了，因为上一个用户已经用这把锁进行加锁操作了，等到上一个用户执行成功锁释放了之后就能进行加锁了。</p>
<p>但你想想，本身付费用户基数就不大，这种情况出现的概率其实很小了，所以在这里其实问题不大，只是提醒一下可能会有这种情况的出现，那么就需要注意加锁的代码块如果本来执行时间就很长的情况，这里可能会让其中一个用户等待的时间加倍，当然一般也不建议锁住一个资源很长时间，也就是要加锁的代码块执行时间很长。</p>
<p>优点：对于付费用户基数不大时，由于预创建了一部分锁，所以在付费加锁时性能表现很好。</p>
<p>缺点：可能会出现不同用户获取到相同锁的情况，导致用户需要等待上一用户释放锁后才能加锁往下执行。</p>
<p>–哈希锁</p>
<p>对于分段锁，其实我们是设定了一个并发付费用户量不是很大的场景，那如果说我们的系统随着慢慢的运营迭代已经俘获了更多的忠实用户，越来越多的用户认可我们的系统，这时候可能并发付费用户量已经上来了，而且有少部分用户已经开始抱怨我们的系统在付费的时候有卡顿，需要等一段时间。</p>
<p>这很可能就是我们所实现的分段锁数量已经不够了，很多用户 id 的 hash 值经过取余之后结果是一样的，那么获取的锁也是一样的，这时就需要等了，严重的时候可能多个用户同一时间获取的都是同一把锁，这时等待的时间就更长了。</p>
<p> 对此我们就需要进行优化改进了，既然是锁不够那就需要创建更多的锁，那是不是可以直接预创建更多数量的锁呢，但这时付费用户基数已经上来了，我们可能需要为每一个用户分配一把锁，这种方式恐怕不行，一是我们不知道哪些用户需要用，还有就是一上来就创建这么多的锁也不现实啊。</p>
<p>那么我们可以为每一个来付费的用户创建一把锁，付费结束之后再移除，注意不是预创建，而是付费时再创建，创建好之后同时会把锁放到 Map 中，以防同一个用户并发付费，这时就可以直接 Map 中获取同时加锁的次数加一，等到锁释放的时候再看下加锁的次数，如果等于一则从 Map 中移除，否则暂先不移除，只是释放锁就好了。来看看代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> fair = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SegmentLock&lt;T&gt; segmentLock = <span class="keyword">new</span> SegmentLock&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;T, ReentrantLockCount&gt; lockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fair = fair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        ReentrantLockCount lock;</span><br><span class="line">        <span class="comment">// 通过分段锁来保证获取锁时的线程安全</span></span><br><span class="line">        <span class="keyword">this</span>.segmentLock.lock(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock = <span class="keyword">this</span>.lockMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lock = <span class="keyword">new</span> ReentrantLockCount(<span class="keyword">this</span>.fair);</span><br><span class="line">                <span class="keyword">this</span>.lockMap.put(key, lock);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// map 中已经存在说明锁已经创建，直接数量加一</span></span><br><span class="line">                lock.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.segmentLock.unlock(key);</span><br><span class="line">        &#125;</span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        ReentrantLockCount reentrantLockCount = <span class="keyword">this</span>.lockMap.get(key);</span><br><span class="line">        <span class="comment">// 判断加锁的次数等于一的话可以将 map 中的锁移除</span></span><br><span class="line">        <span class="keyword">if</span> (reentrantLockCount.getCount() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.segmentLock.lock(key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (reentrantLockCount.getCount() == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.lockMap.remove(key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.segmentLock.unlock(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reentrantLockCount.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockCount</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ReentrantLock reentrantLock;</span><br><span class="line">        <span class="comment">// 记录加锁的次数</span></span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLockCount</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reentrantLock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reentrantLock.lock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count.decrementAndGet();</span><br><span class="line">            <span class="keyword">this</span>.reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码实现主要看 lock 和 unlock 方法就好了，当然还有一个包装了 ReentrantLock 的内部类 ReentrantLockCount，其中有一个字段来统计加锁的次数，这是为了避免同一个用户进行并发付费的时候重复创建锁，直接 Map 中获取，释放的时候如果加锁次数只有一次就可以直接移除。上面的 lock 方法和 unlock 方法采用了分段锁来保证锁的获取过程和移除过程是线程安全，不然可能导致锁的重复创建和重复移除问题。至于使用其实和分段锁差不多的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> HashLock&lt;String&gt; hashLock = <span class="keyword">new</span> HashLock&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consume1</span><span class="params">(String userId, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;verify that the account is normal...&quot;</span>);</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">  hashLock.lock(userId);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;enter the deduction code block&quot;</span>);</span><br><span class="line">    Integer userAccountBalance = accountMap.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (userAccountBalance &gt;= amount) &#123;</span><br><span class="line">      <span class="comment">// deduction</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">      userAccountBalance -= amount;</span><br><span class="line">      accountMap.put(userId, userAccountBalance);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction success&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction failed, insufficient account balance.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    hashLock.unlock(userId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用代码其实和分段锁的使用差不多的，至于里面加的那些睡眠可以不用管，只是为了测试的时候更能看出效果而已。</p>
<p>优点：很好地解决了不同用户共用锁的问题</p>
<p>缺点：需要通过分段锁来维护锁的获取和移除，同时还要维护加锁的次数，分段锁这里锁的数量会成为性能的瓶颈，而且稍有不慎锁没释放成功可能会产生内存泄漏的问题。</p>
<p> –弱引用锁</p>
<p>上面对 HashLock 缺点中也提到由于需要通过分段锁来维护锁的获取和移除，同时分段锁锁的数量可能会成为性能的瓶颈。那么有没有更好地解决办法呢。既然说到了这里那肯定是有的，这里就涉及到了之前 &lt;&lt;谈谈 Java 中的各种引用类型&gt;&gt; 这篇文章中的知识点了，利用弱引用的特性，这样就能够拿掉分段锁，把锁对象的资源回收交给 Java 虚拟机，然后对于已经被回收的锁进行移除，能有效避免不小心发生内存泄漏的问题。代码实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map 中锁数量阈值.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOCK_SIZE_THRESHOLD = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> ReferenceQueue&lt;ReentrantLock&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;T, WeakRefLock&lt;T, ReentrantLock&gt;&gt; lockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReentrantLock <span class="title">get</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以设置一个阈值，当锁的数量超过这个阈值时移除一部分被回收的锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lockMap.size() &gt; LOCK_SIZE_THRESHOLD) &#123;</span><br><span class="line">            clearEmptyRef();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WeakRefLock&lt;T, ReentrantLock&gt; weakRefLock = <span class="keyword">this</span>.lockMap.get(key);</span><br><span class="line">        ReentrantLock lock = weakRefLock == <span class="keyword">null</span> ? <span class="keyword">null</span> : weakRefLock.get();</span><br><span class="line">        <span class="keyword">while</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lockMap.putIfAbsent(key, <span class="keyword">new</span> WeakRefLock&lt;&gt;(<span class="keyword">new</span> ReentrantLock(), <span class="keyword">this</span>.queue, key));</span><br><span class="line">              <span class="comment">// 再次从 Map 中获取，保证同一用户获取的锁是一致的</span></span><br><span class="line">            weakRefLock = lockMap.get(key);</span><br><span class="line">            lock = weakRefLock == <span class="keyword">null</span> ? <span class="keyword">null</span> : weakRefLock.get();</span><br><span class="line">            <span class="keyword">if</span> (lock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> lock;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里注意如果堆资源过于紧张可能会返回空的情况，需要移除一部分被回收的锁</span></span><br><span class="line">            clearEmptyRef();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearEmptyRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reference&lt;? extends ReentrantLock&gt; ref;</span><br><span class="line">        <span class="keyword">while</span> ((ref = <span class="keyword">this</span>.queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WeakRefLock&lt;T, ? extends ReentrantLock&gt; weakRefLock = (WeakRefLock&lt;T, ? extends ReentrantLock&gt;) ref;</span><br><span class="line">            <span class="keyword">this</span>.lockMap.remove(weakRefLock.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakRefLock</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WeakRefLock</span><span class="params">(K referent, ReferenceQueue&lt;? <span class="keyword">super</span> K&gt; queue, T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent, queue);</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中主要是利用了弱引用的特性，拿掉了锁的获取和创建时维护加锁次数的判断过程，在获取锁时直接从 Map 中获取，如果拿到为空则创建，同时这里要解释一下代码里面清理被回收的锁的过程。第一处在 Map 中的锁数量超过设定的阈值后将已经被回收的锁进行移除，主要是为了不让 Map 中存放过多的已经被回收的锁占用资源，第二处移除主要是以防资源过于紧张的情况，刚刚创建的弱引用锁立即就被回收了，这时急需移除一部分已经被回收的锁。当然如果资源真的都已经紧张到这个程度了的话，也应该考虑考虑提高一下机器的配置了。使用代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> WeakHashLock&lt;String&gt; weakHashLock = <span class="keyword">new</span> WeakHashLock&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consume2</span><span class="params">(String userId, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;verify that the account is normal...&quot;</span>);</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">  ReentrantLock lock = weakHashLock.get(userId);</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;enter the deduction code block&quot;</span>);</span><br><span class="line">    Integer userAccountBalance = accountMap.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (userAccountBalance &gt;= amount) &#123;</span><br><span class="line">      <span class="comment">// deduction</span></span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">      userAccountBalance -= amount;</span><br><span class="line">      accountMap.put(userId, userAccountBalance);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction success&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">&quot; deduction failed, insufficient account balance.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上这里就不多说了，都基本上差不多，主要的区别还是锁的实现上不同而已。</p>
<p>优点：利用了弱引用的特性，解除了分段锁那部分代码带来的性能瓶颈问题，将回收操作交给 Java 虚拟机。</p>
<p>缺点：获取锁的代码实现看起来有点繁琐，应该还有更优雅的方式实现。</p>
<p>好了，到这里就基本上将细粒度锁的实现方式都说完了，每种实现方式优缺点也大概总结了一下，根据优缺点其实也就能够知道每种实现方式所适用的场景，在选择的时候根据业务需求来进行选择。对于最后一种实现方式其实还有更优雅的实现，我们接下来再用一篇文章来说下最后一种实现方式。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 MySQL 事务原理</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MySQL-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>对于 MySQL 事务，可能我们大家都不陌生，事务是对数据库中数据操作保证数据逻辑一致的最小操作单位，一个事务中可能包含多条语句，但这些语句作为一个整体，由事务来保证这个整体的操作要么都成功，要么都失败，不存在部分成功部分失败的情况。</p>
<a id="more"></a>

<p>同时事务还具备 ACID 的特性，分别是原子性(Atomicity)，一致性(Consistency)，隔离性(Isolation)，持久性(Durability)。</p>
<p><strong>原子性: 事务作为一个最小操作单位，事务中的所有 SQL 要么都执行，要么都不执行</strong></p>
<p><strong>一致性: 每个事务都满足数据库的完整性约束，也就是说如果从 A 账户向 B 账户转账，只要 A 账户里面减少了 100 元，那 B 账户里面就一定会增加 100 元。</strong></p>
<p><strong>隔离性: 并发进行的多个事务，各个事务之间的操作对其他事务是相互隔离的。</strong></p>
<p><strong>持久性: 事务在提交之后，对数据的修改是永久的，即时数据库发生故障也不会丢失。</strong></p>
<p>其中隔离性由于多个并发执行的事务同时操作同一条数据时，会带来数据的不一致性，包括脏读，不可重复读，幻读，因此有了不同的隔离级别来针对性的解决这些问题，分别是读未提交，读提交，可重复读，串行化。</p>
<p><strong>读未提交: 一个事物产生的修改，还没提交就已经被其他事物读取到，存在的问题是脏读，不可重复读，幻读。</strong></p>
<p><strong>读提交: 一个事务产生的修改，还没提交时对其他事务不可见，只有提交之后对其他事务才可见，存在的问题是不可重复读，幻读。</strong></p>
<p><strong>可重复读: 事务开启之后，其他事务产生的修改对该事务都不可见，包括未提交和已提交的事务，当然事务本身的修改在当前事务内还是可见的，存在的问题是幻读，不过对于 MySQL InnoDB 引擎引进的行锁和间隙锁，已经可以解决幻读的问题了。</strong></p>
<p><strong>串行化: 数据库中基本上所有事务都是按顺序执行的，只有读和读之间不影响，读和写，写和写都是互斥的，这时后面的事务需要等前面的事务提交之后才能执行。</strong></p>
<p>以上四种隔离级别从低到高，隔离级别越高，意味着性能越低，但数据越安全，所以在日常使用中需要综合各方面需求来选择其中一种，对于 MySQL 默认的隔离级别是可重复读，查看当前隔离级别设置的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;transaction_isolation&#39;;</span><br></pre></td></tr></table></figure>

<p>接下来我们看在特定场景，不同的隔离级别设置下，同一个事务看到的结果是怎样的，这里主要还是看前三种隔离级别，最后一种都串行化了也就不存在并行的事务了。还是以之前写 MySQL 文章最开始的那张表为例，我再贴下表结构和初始化数据:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    id bigint auto_increment primary key,</span><br><span class="line">    name varchar(32) not null comment &#39;用户名&#39;,</span><br><span class="line">    identity varchar(18) not null comment &#39;身份证号&#39;,</span><br><span class="line">    age int default 0 null comment &#39;年龄&#39;,</span><br><span class="line">    sex tinyint(1) default 0 not null comment &#39;性别 0：男，1：女&#39;,</span><br><span class="line">    birthday date null comment &#39;生日&#39;,</span><br><span class="line">    address varchar(128) default &#39;&#39; not null comment &#39;地址&#39;</span><br><span class="line">)</span><br><span class="line">comment &#39;用户表&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (1, &#39;张三&#39;, &#39;362422199401014501&#39;, 27, 0, &#39;1994-01-01&#39;, &#39;&#39;);</span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (2, &#39;李四&#39;, &#39;362422199402024502&#39;, 27, 0, &#39;1994-02-02&#39;, &#39;&#39;);</span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (3, &#39;王五&#39;, &#39;362422199403034503&#39;, 27, 1, &#39;1994-03-03&#39;, &#39;&#39;);</span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (4, &#39;赵六&#39;, &#39;362422199404044504&#39;, 27, 1, &#39;1994-04-04&#39;, &#39;&#39;);</span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (5, &#39;小明&#39;, &#39;362422199405054505&#39;, 27, 1, &#39;1994-05-05&#39;, &#39;&#39;);</span><br></pre></td></tr></table></figure>

<p>假如说目前有下面两个事务在操作修改数据，然后事务之间的执行顺序如下:</p>
<table>
<thead>
<tr>
<th>事务一</th>
<th>事务二</th>
</tr>
</thead>
<tbody><tr>
<td>① begin;<br />select * from users where id = 1;</td>
<td>① begin;<br />select * from users where id = 1;</td>
</tr>
<tr>
<td>② update users set age = 28 where id = 1;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>② select * from users where id = 1;# T1</td>
</tr>
<tr>
<td>③ commit;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>③ select * from users where id = 1;# T2</td>
</tr>
<tr>
<td></td>
<td>④ commit;</td>
</tr>
<tr>
<td></td>
<td>⑤ select * from users where id = 1;# T3</td>
</tr>
</tbody></table>
<p>从表格中可以看到，事务一和事务二开启之后都分别查询了 id = 1 的数据，这时查询出来的是张三的那条数据，并且年龄都是 27，接下来事务一将张三的年龄改成 28，这时还没提交，然后事务二再次查询了这条数据，此时记为 T1，紧接着事务一提交，事务二又查询了 id = 1 的数据，此时记为 T2，最后事务二自己提交事务，提交后又查询了一次 id = 1 的数据，此时记为 T3，那么在不同的隔离级别下，事务二在 T1，T2，T3 这三个时刻查询出来张三的年龄分别是多少呢，我们一个一个来分析:</p>
<p><strong>读未提交(Read Uncommitted):</strong></p>
<p>读未提交，顾名思义，一个事务可以读到其他事务未提交的数据。上面事务二的 T1，T2，T3 时刻都是在事务一更新数据之后查询的，因此 T1，T2，T3 时刻查出来张三的年龄都是 28，不管事务一的更新所在事务是否已经提交。</p>
<p><strong>读提交(Read Committed)</strong></p>
<p>读提交，意思也很明白了，一个事务只能读到其他事务已经提交的数据。上面事务二 T1 时刻事务一还没提交，它对张三年龄的更新对因此 T1 是不可见的，T1 时刻查出来张三的年龄还是 27，T2 和 T3 时刻事务一已经提交，因此 T2 和 T3 时刻事务二查询出来张三的年龄是 28。</p>
<p><strong>可重复读(Repeatable Read)</strong></p>
<p>事务开启之后，在整个事务内读到的数据都是一样的，其他事物的修改对当前事务不影响，T1 时刻事务一还没提交，肯定不可见，这时查出来张三的年龄还是 27， T2 时刻事务一已经提交，但其他事物的修改对当前事务不影响，这里查出来张三的年龄也是 27，T3时刻事务一已经提交，同时事务二本身也已经提交了，相当于再启动另一个事务继续查询，这时是可以看到事务一的修改，因此 T3 时刻查出来张三的年龄是 28。</p>
<hr>
<p>也许你对上面这些东西已经比较熟悉了，无非就是事务的 ACID 特性以及隔离性中的不同隔离级别，上面我们也用一个实际的例子来说明了三种隔离级别的不同情况，这时如果我问你事务中的隔离性是如何实现的呢？怎么做到在不同隔离级别下事务之间数据的可见性也不同？</p>
<p>其实是在事务开启时，会为整个事务创建一个一致性读视图，这个视图持续到事务的结束，在整个事务的执行期间所看到的数据都依赖于事务开启时创建的一致性读视图(consisitent read view)。当然一致性读视图并不是实际存在的物理结构，它只是用来定义事务执行期间能看到哪些数据。如何定义呢？</p>
<p>这里需要先提到一个日志 undo log，我们之前说在更新的时候会写入 redo log 和 binlog，而 undo log 你可以认为是在写入 redo log 的同时记录的一个日志。<strong>redo log 是重做日志，记录的是数据页的物理修改，也就是只能将数据恢复到最后一次提交的状态，并且是循环写的；undo log 则是回滚日志，一般是逻辑日志，根据每行记录进行记录日志，主要用来回滚行记录到之前的版本。</strong></p>
<p>比如说在三个不同事务里依次将张三的年龄依次更新成 28，29，30，SQL 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update users set age &#x3D; 28 where name &#x3D; &#39;张三&#39;; #① 事务一</span><br><span class="line"></span><br><span class="line">update users set age &#x3D; 29 where name &#x3D; &#39;张三&#39;; #② 事务二</span><br><span class="line"></span><br><span class="line">update users set age &#x3D; 30 where name &#x3D; &#39;张三&#39;; #③ 事务三</span><br></pre></td></tr></table></figure>

<p>上面这三个更新事务分别对应着数据库中三个数据版本，下面图中详细展示了三个事务更新后记录的 undo log。</p>
<p><img src="/images/undo_log.png" alt="undo log"></p>
<p>从上面图中可以看出，三个事务更新后都会记录相应的 undo log 用来回滚到上一个版本，那么在查询张三的年龄的时候，不同时刻启动的事务查询得到的年龄是不一样的，但数据库中数据肯定已经是最新值了，只不过根据事务的隔离级别不同，需要通过 undo log 回滚到对应的可见版本，这里举几个例子:</p>
<p>从图中可以看到刚开始张三的那条数据年龄是 27，对应的更新事务是 X，目前最新的数据年龄值是 30，对应的更新事务是事务三：</p>
<p>如果是在事务一启动之前开启事务 A 来查询，在事务 A 启动的时刻创建了一个一致性读视图，后面的更改对我都不可见，我只认我创建的视图中能看到的数据，后面在事务中查询看到的数据都依赖于视图中能看到的数据，虽然读到最新的值是 age=30，但是不可见，通过 undo log 回滚到上一个版本 age=29，同样不可见，直到回滚到 age = 27，可见。</p>
<p>如果是在事务一启动之后事务二启动之前开启事务 B 来查询，同样启动时创建一致性读视图，接下来在事务中查询读到数据库中最新的值是 age=30，不可见，通过 undo log 回滚到上一个版本 age=29，同样不可见，再往前回滚到上一个版本 age = 28，可见。</p>
<p>对于在事务二和事务三之间启动事务 C 查询，流程也是一样的，而在事务三之后启动事务 D，那么一致性读视图里面的最新值就是数据库中的最新值，不用回滚，直接可见。</p>
<p>从上面例子可以看出，一条记录在数据库中看起来就存在多个版本一样，也就是我们经常听到的多版本并发控制(MVCC)，不同时刻启动的事务看到的是不同版本的数据，但要注意，并不是说这多个版本的数据是物理结构上存在的，它们都是需要拿到当前的最新值再通过 undo log 进行回滚到相应的版本，那么就会引出一个问题了，对于那种长事务，往往数据已经更新了很多个版本了，但在这个事务里面依然需要通过 undo log 一步一步回滚到可见的那个版本，也就是说在事务提交前这些 undo log 就没办法进行删除，需要一直保留，直到没有对应的事务再需要这些日志的时候才能够删除，如果存在很多的长事务，就可能导致这些 undo log 越来越大，因此在我们日常的开发中，我们需要尽量的去避免使用长事务，长事务不仅会造成回滚日志会越来越大，还会导致锁资源的占用问题，这个后面在分析锁的时候再说。</p>
<p>上面也说了事务的很多东西了，事务的基本定义，ACID 特性，以及隔离性是如何实现的，然后引出了 undo log 这个新的日志，但 undo log 只是我们实现隔离性的一个辅助工具，能够让我们回滚到之前的数据版本，那 MySQL 是怎么去判定具体要回滚到哪个版本呢？</p>
<p>接下来我们再引出一个事务 id 的概念，实际上数据库在每个事务启动时都会向服务申请一个唯一的事务 id，而且这个事务 id 是顺序递增的，每次事务更新数据的时候会生成一个新的数据版本，并且把当前事务 id 赋值给这个数据版本，记为 trx_id，同时旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它，因此在新的数据版本中除了包含本次数据的值和当前更新的事务 id 外，还有一个引用(指向上一个数据版本)，通过 undo log 进行回滚时需要用到。上面的几个事务更新在加上事务 id 之后，更新流程图如下:</p>
<p><img src="/images/undo_log_trx_id.png" alt="undo log"></p>
<p>从图中可以看到最开始更新之前张三这条数据是由事务 id=100 的事务 X 所更新的，接下来依次被事务一事务二事务三所更新，对应的事务 id 分别是 105，110，115，而<strong>在不同时刻启动的事务会创建不同的一致性读视图，这个一致性读视图其实也就是给整个库打了个快照</strong>，注意并不是说事务启动的时候将整个库的数据拷贝一份出来，要是这样做的话就太费内存，太费时间了。</p>
<p>它的实现上是<strong>将目前还处于活跃事务的事务 id 放到一个数组里面，活跃事务是指事务开启了但还没提交的事务，数组中最小值记为低水位，当前系统中已经创建的事务 id 的最大值 +1 记为高水位，然后依据高低水位来判断数据版本可不可见</strong>，注意理解这句话，说明数组中包含的是活跃事务 id，中间已经提交了的事务是不在里面的，也就是说数组中的值不一定是连续的。</p>
<p>有了这个数组之后，就可以利用这个数组来判断数据可不可见了，判断规则如下:</p>
<p><strong>1.数据版本对应的事务 id 比最低水位小，说明是已经提交了的事务，该数据版本可见</strong></p>
<p><strong>2.数据版本对应的事务 id 比最高水位大，说明是在当前事务之后启动的事务，不管提没提交，该数据版本都不可见</strong></p>
<p><strong>3.数据版本对应的事务 id 大于等于最低水位小于等于最高水位，那存在两种情况:</strong></p>
<ul>
<li><strong>数组中包含该事务 id，说明是还未提交的事务，该数据版本不可见</strong></li>
<li><strong>数组中不包含该事务 id，说明是已经提交的事务，该数据版本可见</strong></li>
</ul>
<p>接下来我们来模拟几个事务的 SQL 执行场景，然后我们用上面的规则来分析可见性，看看是否和我们之前理解的数据可见性是一致的。下面的场景将会涵盖上面三种情况，SQL 执行的顺序就是按照表格从上到下的顺序，事务隔离级别没有特殊说明都是可重复读:</p>
<p><img src="/images/high_low_bit.png" alt="undo log"></p>
<p>上面表格中没有显式开启事务的都是自动提交，表头描述了每个事务的名称以及对应的事务 id，表格内容从上到下可以看到首先是事务一将 id = 1 的 age 字段更新成 28 并且自动提交，接下来启动事务二但没提交，紧接着事务三将 id = 1 的 age 字段更新成 30 并且自动提交，然后事务二再将  id = 1 的 age 字段更新成 29 依然没提交，再接着事务 A 启动，随后对事务二进行提交，然后事务四将 id = 1 的 age 字段更新成 31 并且自动提交，这时再回到事务 A 查询 id = 1 的那条数据，这时看到的 id = 1 的那条数据的 age 等于多少呢？</p>
<p>上面描述了这个场景的整个过程，我们用上面的规则来进行分析，其实主要就是分析事务 A 中的查询语句看到的 age 字段是多少。事务 A 启动时将当前库活跃事务的事务 id 放到一个数组里面，我们假设数据库目前只有这几个事务在操作数据库，那么事务 A 启动时处于活跃的事务就只有事务二是还没提交的，同时事务 A 启动时系统中已经创建的事务 id 的最大值是 103，高水位就是 104，那么事务 A 启动时对应的数组就是 [102, 104]，低水位就是 102，然后在事务 A 中进行查询 id = 1 的那条记录，该记录目前最新版本 age 的最新值是 31，对应的事务 id 是 105，105 比高水位大，对应上面规则中的第二种情况，那么该数据版本不可见，然后根据 undo log 回滚到前一个版本，前一个版本是事务二进行更新的，事务二的事务 id 是 102，等于最低水位并且数组中包含该事务 id，对应着上面规则中的第三种情况里面的第一种，数据版本依然不可见，继续根据 undo log 回滚到前一个版本，前一个版本是事务三进行更新的，事务三的事务 id 是 103，大于最低水位小于最高水位，但数组中没有包含该事务 id，对应着上面规则中的第三种情况里面的第二种，数据版本可见，所以在事务 A 中看到的数据 age = 30。而其实如果还需要再回滚的话，那就回滚到了事务一更新的版本，事务一的事务 id 是 101，比最低水位小，对应着上面规则中的第一种情况，该数据版本也是可见的。</p>
<p>上面的场景实际执行结果也是一样的，实际操作如下所示:</p>
<p><img src="/images/high_low_sql_execute.png" alt="undo log"></p>
<p>上面开了五个终端，每个终端里面都和 MySQL 建立连接，各个连接中的 SQL 执行顺序对应着表格中从上到下的顺序，可以看到最后查询出来的值也是我们上面按照高低水位的判断规则分析出来的结果 age = 30。</p>
<p>上面其实更多的是从底层实现层面来分析得到这个结果，如果说每次事务间的数据可见性都按照这个去分析就有点太麻烦了，所以也就有了下面更容易理解的判断方式，首先以事务启动的那一刻为准，</p>
<p>1.该事物开启时，对于还没提交的事务更新都是不可见的</p>
<p>2.该事务开启时，对于已经提交的事务更新都是可见的</p>
<p>再回到上面表格中模拟的场景，事务 A 开启时，事务一和事务三是已经提交了的，并且事务三在事务一之后提交，事务二还没提交，事务四在事务 A 开启时还没创建，那么在事务 A 中的查询，看到的就是事务三的更新 age = 30，这样去分析是不是就方便多了。从上面的分析也可以看到，事务开启后，不管在什么时候查询，前后看到的数据都是一致的，因为数据版本的可见性只取决于事务启动的那一刻，这个就是所谓的<strong>一致性读</strong>。</p>
<p>可能你注意到了上面表格中事务 A 中的查询语句后面有两个划线了的 SQL 语句，一个是更新，一个是查询，假如我们把这两个 SQL 语句放开执行，那么后面的这个查询语句查询到的数据是多少？如果按照上面一致性读的说法，执行更新语句时看到的张三的年龄应该是 30，age = 30 + 1，那紧接着的查询语句查询出来的张三的年龄应该就是 31。如果是这样的话看起来好像不太对，因为事务四的更新看起来就丢失了，因为在事务 A 中进行更新前， 事务四已经将张三的年龄更新成 31 了。</p>
<p>事实上，我们真正去执行的时候，事务 A 中查询得到的值是 age = 32，也就是事务 A 里面是认事务四的那个更新的，当然也必须得认，不然就都乱套了，但这样就又和我们上面的一致性读说法好像不一致了，这里就需要引出另一个概念，<strong>对于查询是按照一致性读的原则，而对于更新则是按照当前读的原则</strong>，也就是说更新都是从最新版本的数据上开始更新的，所以这里就是直接从事务四对应的版本的数据上进行更新的，age = 31 + 1，紧接着的查询语句一看最新版本的数据是 32，对应的事务 id 是 104，和自己的事务 id 相等，这个版本是自己的更新，那也是要认的，因此查询出来的数据就是 age = 32，下面我单独将事务 A 加上更新语句之后的执行截图贴出来:</p>
<p><img src="/images/update_current_read.png" alt="undo log"></p>
<p>其实除了更新语句，对于加读锁或者写锁的查询也是当前读，我们可以简单的模拟一下这种场景，先在一个连接中开启事务，然后在另一个连接中更新一条数据，再回到第一个连接中加读锁或者写锁去查询刚才更新的那条数据。</p>
<p><img src="/images/lock_share_current_read.png" alt="undo log"></p>
<p>上面截图中就是先在上面的窗口查询当前 id = 1 的那条记录，age = 35，然后开启事务，紧接着在下面的窗口将 id = 1 的记录 age 更新成 40，再回到上面的窗口中去查询，可以看到在加读锁或者写锁的时候都是当前读，查询到的是当前最新版本的数据，其中在查询语句后面加上 lock in share mode，表示加读锁，查询语句后面加上 for update，表示加写锁，读读不冲突，读写和写写是冲突的，这个后面提到锁的时候再具体细说。</p>
<p>上面我们就已经描述了在可重复读的隔离级别下，事务开启时会创建一个一致性视图，接下来的数据查询都依赖于事务开启时创建的一致性视图，而如果是读提交的隔离级别，不妨先来实际操作下，先将事务的隔离级别修改成读提交:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>

<p>注意执行完上面的 SQL 之后将连接断开，重新连接之后才会生效，这个操作最好不要在生产库上做测试。</p>
<p>修改好了之后，同样用刚才的方式做测试，在一个连接里面开启事务，另一个连接里面更新，再回到第一个连接里面去查询，结果如下:</p>
<p><img src="/images/read_commited.png" alt="undo log"></p>
<p>从结果可以看到，第一个窗口中查到的是已经提交的最新版本的值，这个其实和可重复读的隔离级别的区别就是，<strong>读提交是在每个 SQL 执行前都会重新创建一个一致性读视图，而可重复读则是在事务正式开启时创建，所以读提交的隔离级别下，每次都查询得到已经提交的最新版本的值。而对于读未提交的隔离级别那就是每次直接将当前数据的最新版本返回就可以了，也就没有视图的概念了。</strong></p>
<p>上面我们可能多次提到一致性读视图，这里可能需要进行说明下，它和我们在查询时通过 create view 的方式创建的视图是不一样的，这里的一致性视图是静态的，当前视图对应的数据是由字段上的当前值通过 undo log 回滚计算得到的，它是用来辅助实现可重复读和读提交的隔离级别。而通过 create view 的方式创建的视图则是利用查询语句定义的一张虚拟的表，调用的时候执行相应的查询语句来生成查询结果。</p>
<p>还有一点你可能也注意到了，我在上面的实践中开启事务都是用的 start transaciton with consistent snapshot; 语句，和我熟悉的 begin 或者 start transaction 好像有点不一样，这里我们来了解下他们之间的区别:</p>
<p>begin 或者 start transaction: 一致性读的视图不会马上创建，而是在执行 begin 或者 start transaction 后面的第一个 SQL 语句时生成，这个SQL可以是 select，update，delete，insert 其中的任意一种，事务 id 也是此时才被分配，当然这其实也是能理解，这样做可以最大程度的支持事务之间并发。<br>start transaciton with consistent snapshot: 该语句执行后，会马上创建一个一致性读的视图，同时事务 id 也是立即被分配。</p>
<p>注意: 一致性读视图是基于整库的，在可重复读的隔离级别下，全库快照秒级实现，这正是 InnoDB 利用了“所有数据都有多个版本”的这个特性来实现的。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解 MySQL 的 SQL 执行流程</title>
    <url>/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-MySQL-%E7%9A%84-SQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>对于 MySQL 的认识，我们大部分人可能都还只是停留在增删改查的阶段，当然我们接触的更多的也就是页面上输入一些信息，调用后台接口保存到数据库，然后再从数据库查询得到值后返回给前端展示在页面上，这也就是业界俗称的 CRUD 工程师。怎么说呢，如果我们日常只能接触到这些 CRUD 的需求，那就算是 CRUD，我们也要努力将 CRUD 做到极致。</p>
<a id="more"></a>

<p>怎么个极致法呢？那就是我们要对我们日常写的这些 CRUD 语句做到心里有数，每写出一个 SQL 我们脑海里都能够知道这个 SQL 经历了哪些过程才得到我们想要的数据，具体体现在 MySQL 在收到我们发出的 SQL 语句之后是怎么执行的，走了哪个索引，为什么选择这个索引，大概需要扫描多少行记录，执行这个 SQL 加了哪些锁，以及为什么有时需要开启事务，不同事务之间看到的数据为什么不一样等等，这些东西都需要我们去了解和熟悉，这样才能在遇到更复杂的需求的时候从容应对。</p>
<p>首先我们来看看一个 SQL 的执行在服务器上经历了哪些过程，对于查询语句和更新语句整体上差不太多，更新语句只不过是先查到结果再进行更新，我们日常使用的最多的应该是查询 SQL 了，先来看一个查询 SQL 发到服务器上会经历那些过程才得到我们想要的数据。</p>
<p>注: 下面的测试是基于 MySQL 服务器，版本号是 8.0.26</p>
<h3 id="查询-SQL"><a href="#查询-SQL" class="headerlink" title="查询 SQL"></a>查询 SQL</h3><p>首先通过下面的建表语句创建一张表，并插入几条测试数据，建表语句如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    id bigint auto_increment primary key,</span><br><span class="line">    name varchar(32) not null comment &#39;用户名&#39;,</span><br><span class="line">    identity varchar(18) not null comment &#39;身份证号&#39;,</span><br><span class="line">    age int default 0 null comment &#39;年龄&#39;,</span><br><span class="line">    sex tinyint(1) default 0 not null comment &#39;性别 0：男，1：女&#39;,</span><br><span class="line">    birthday date null comment &#39;生日&#39;,</span><br><span class="line">    address varchar(128) default &#39;&#39; not null comment &#39;地址&#39;</span><br><span class="line">)</span><br><span class="line">comment &#39;用户表&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (1, &#39;张三&#39;, &#39;362422199401014501&#39;, 27, 0, &#39;1994-01-01&#39;, &#39;&#39;);</span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (2, &#39;李四&#39;, &#39;362422199402024502&#39;, 27, 0, &#39;1994-02-02&#39;, &#39;&#39;);</span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (3, &#39;王五&#39;, &#39;362422199403034503&#39;, 27, 1, &#39;1994-03-03&#39;, &#39;&#39;);</span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (4, &#39;赵六&#39;, &#39;362422199404044504&#39;, 27, 1, &#39;1994-04-04&#39;, &#39;&#39;);</span><br><span class="line">INSERT INTO activity.users (id, name, identity, age, sex, birthday, address) VALUES (5, &#39;小明&#39;, &#39;362422199405054505&#39;, 27, 1, &#39;1994-05-05&#39;, &#39;&#39;);</span><br></pre></td></tr></table></figure>

<p>目前 users 表已经建好了，里面有五条测试数据，现在我们想要查出用户表中 id = 1 的数据，我们的 SQL 应是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users where id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>不出意外的话你拿这个 SQL 去终端执行，得到的是张三的那条数据。</p>
<p><img src="/images/simple_query.png" alt="simple_query"></p>
<p>也许我们实现业务需求的时候可能到这里就结束了，但既然我们要做一个极致的 CRUD 工程师，那可不能就这么结束了，接下来我们要刨根问底，看看这个 SQL 在服务器上到底是怎么执行的。</p>
<p>MySQL 服务器它是由两部分组成，分别是 Server 层和存储引擎层，Server 层又有连接器，缓存(新版本已经去掉)，分析器，包括词法分析器和语法分析器，优化器，执行器这些服务，存储引擎层则主要是负责数据的存储和提取，同时存储引擎层是可以替换 的，根据业务需要选择合适的引擎，默认是 InnoDB，常见的引擎还有 Memory，MyISAM 等，这里暂时先不讨论这些引擎的优劣。</p>
<p>我先贴一张 SQL 的执行流程图，下面我会对这个流程图进行详细介绍，你可以对照着这个图看下面的内容，这样更容易理解一些。</p>
<p><img src="/images/sql_execute_flow.png" alt="SQL 执行流程"></p>
<p>从上面图中可以看到，首先客户端需要和服务器端建立连接，而服务器端负责和客户端建立连接的是连接器，它先是验证建立连接的用户名密码是否正确，如果不正确会直接报错 Access denied for user 拒绝连接，验证成功后这时会去查询得到该用户所拥有的权限信息，后面在执行 SQL 的过程中所依赖的权限验证就来自于这里获取得到的权限信息，也就是说修改用户的权限信息对于已经连接成功的用户是不生效的，需要重新建立连接后才生效。</p>
<p>连接建立成功之后，接下来就可以执行 SQL 了，客户端通过建立好的连接向服务器端发送 SQL 语句，服务器端接收到 SQL 后，会经历以下流程:</p>
<p>在之前的版本中首先会去缓存中看有没有命中的缓存，如果命中就直接返回缓存中的数据，不过后期的版本中已经将缓存去掉了，主要是因为缓存的利用率不高，每次将查询之后得到数据进行缓存，但只要对刚才查询的表有更新，和这个表有关的缓存就都被清空了，所以经常出现的情况就是往往缓存中的数据还没用到就已经被清空了，这可能只适合于一些配置表，查询较频繁但不怎么更新的数据，由于后期的版本中已经将缓存去掉了，所以上面图中我就没画出来。</p>
<p>从 MySQL 8.0 版本后，SQL 进来通过分析器对 SQL 进行词法分析和语法分析，词法分析主要是解析 SQL 中的关键词，然后看表以及字段是否存在，是查询语句还是更新语句，语法分析则是看提供的 SQL 是否有语法错误，如果有，直接返回客户端语法错误: You have an error in your SQL syntax，并提示错误信息，如果 SQL 没问题则继续往下执行。</p>
<p>在经过词法和语法分析之后，优化器会对 SQL 进行一个优化，比如说在多个表进行连接查询的时候使用哪一个表作为驱动表，也就是决定先查哪个表，后查哪个表，以及在查询时选择走哪一个索引，这些都是需要在优化器中做的。在经过优化器之后，这个 SQL 的执行方案也就确定下来了，其实也就意味着确定了接下来执行器具体是调用引擎层的哪个接口来提取数据，执行器只管去执行就好了，但优化器只是选择它认为性能最合适的方式执行，却不一定是最优选择，所以也就存在选错索引的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users where id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>拿上面的 SQL 来说，目的是要查询 users 表中 id = 1 的记录，执行器这时会调用引擎层具体的接口，取出满足条件 id = 1 的第一行记录，这里由于 id 是主键，所以执行器在拿到 id = 1 的第一行记录后直接就返回了，同时对于唯一索引也是一样的。</p>
<p>这是查询条件是主键或者唯一索引的情况，如果说查询条件不是主键或唯一索引只是普通索引会怎么样呢，这时执行器会继续调用引擎层满足条件下一行的接口，直到取到最后没有取到满足条件的行为止。还有就是如果查询条件完全没有索引，我们知道这时会进行全表扫描，就比如说下面的 SQL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users where name &#x3D; &#39;123&#39;;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 是要查询 users 表中 name = ’123‘ 的记录，由于 name 字段没有索引，这时执行器会调用引擎层取这个表第一行记录的接口提取数据，取出表中的第一行数据后判断 name 字段是否等于 ’123‘，如果是放入结果集中，不是的话则跳过这一行调用取表中下一行数据的，一直取到表中的最后一行数据，最后将结果集返回给客户端。</p>
<p>这里需要注意判断是否满足条件是在 Server 层执行器中判断的，而上面有索引的情况是直接取满足条件的记录，这些都是引擎层定义好的接口，执行器根据优化器制定的执行方案调用引擎层不同的接口来提取数据。</p>
<h3 id="更新-SQL"><a href="#更新-SQL" class="headerlink" title="更新 SQL"></a>更新 SQL</h3><p>上面就是一个查询语句发送给 MySQL 服务之后的大体执行流程，接下来再看下对于一个更新语句 MySQL 服务又是怎么执行的呢。简单的来说，对于更新 SQL 整体流程和上面的流程是一致的，更新 SQL 是先查出来再修改写入，也就是前面的流程都是一致的，包括分析器，优化器，执行器这些流程都会走，唯一不同地方就是执行器在执行的时候先将要更新的数据查出来然后更新，再调用引擎层接口写入，而且这里涉及到更新记录也就还需要记录日志，也就是我们经常听到的 binlog，同时对于 InnoDB 引擎来说其实还要记录一个我们不常听到的 redo log，这两个日志分别是什么，又有什么作用，接下来我们就一起来看下这两个东西。</p>
<p>首先对于 binlog，可能我们大多数人都听说过，它是属于 Server 层的一个归档日志，所有引擎共用，主要用于数据归档以及主从库间的数据同步，有两种模式，statement 格式记录的是 SQL 语句，row 格式记录的则是一行记录修改前和修改后的内容，有两条记录。</p>
<p>而 redo log，它是 InnoDB 引擎层特有的一个日志，也叫重做日志，也正是因为它 InnoDB 引擎层才能够做到崩溃恢复的功能，它记录的是数据在页上做了什么改动，而且它的大小是有限的，是一个循环结构，写满之后就要擦除之前的数据从头开始继续写，在服务空闲或者写满时需将还没持久化的数据进行持久化，然后再擦除已经持久化的日志腾出空间提供继续写。redo log 归根结底是 MySQL 实现 WAL(Write-Ahead Logging) 机制(先写日志，再写磁盘)的一种手段，因为 MySQL 在进行更新操作时为了能够快速响应，采用了异步写回磁盘的技术，也就是写入内存后就返回，后续空闲或者 redo 写满了之后再回刷到磁盘，但这时就存在服务器 crash 后内存中数据丢失的风险，而有了 redo log，一是不用每次都实时将数据写到磁盘，只需要记录 redo log，写入内存就可以了，而且 redo log 是顺序写，而如果直接将数据写到磁盘的话很大概率是随机 IO，这种方式可以大大提高响应速度，还一个就是具备 crash safe 的能力，就算服务器 crash 了，重启之后可以通过重放 redo log 进行数据恢复。</p>
<p>这里可能有点不太好理解，用一个具体的例子来看，比如说我现在要更新上面表中 id 等于 1 的年龄字段，更新 SQL 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update users set age &#x3D; 28 where id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 同样的会走一遍上面的 SQL 执行流程，这里我就不再重复，毕竟前面都是一样的，重点说一下走到执行器的那部分的流程，<strong>首先执行器收到优化器制定的执行方案后开始调用引擎层接口取出 id 等于 1 的记录，引擎层会去看要查询的数据是否在内存中，在的话直接从内存中取，没有的话则去磁盘中取，取到后将 age 更新成 28，然后调用引擎层接口将新的记录写入到内存，引擎层在写入内存后记录 redo log，此时处于 prepare 状态，然后返回给执行器，执行器收到之后再记录 binlog，紧接着调用引擎层提交事务的接口，引擎层将刚才记录的 redo log 状态更新成 commit 状态，整个更新结束。</strong></p>
<p>上面描述相对应的最后执行器那部分的执行流程图如下，其中浅色部分表示的是 Server 层的行为，深色部分表示的是引擎层：</p>
<p><img src="/images/update_sql_execute_flow.png" alt="更新 SQL 执行流程图"></p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>上面提到了数据在更新的时候，会记录两份日志，一个是 binlog，一个是 redo log，同时也提到了各自大概的作用和区别，接下来我们再来看下 Server 层既然已经有了 binlog，为什么 InnoDB 引擎还要引入 redo log，以及这两个日志是怎么配合使用的。</p>
<p>第一个问题，Server 层既然已经有了 binlog，为什么 InnoDB 引擎还要引入 redo log？其实上面我们已经提到了，因为它 InnoDB 引擎层才能够做到崩溃恢复的功能，同时 binlog 是 Server 层共用的，设计的初衷也就不具备这一功能，而是直接交给各个引擎层去实现。比如说在某一时刻，MySQL 服务突然挂了，这时可能有一部分修改的数据还在内存中，随着 MySQL 服务的崩溃也就丢失了，而如果有了 redo log，在服务重启后时候就可以将还在内存中没来得及持久化到磁盘上的数据通过重放 redo log 里面的日志来恢复数据。</p>
<p>当然你也可以说通过 binlog 来恢复数据， 可是 binlog 设计的初衷就不是用来服务 crash 恢复数据的，它更多的是用于恢复到一个之前的某个时间点的数据，由于它是增量写入的，可以记录很长时间的 log，理论上来说可以恢复到之前任意时间点的数据库。比如说数据库在某一天误操作删除了数据，那么就可以找到距离误操作最近的时间节点前的 bin log 重放到临时数据库里，然后选择当天误删的数据恢复到线上数据库。</p>
<p>第二个问题，这两个日志是怎么配合使用的呢，其实上面的那张 SQL 更新执行器部分的流程图已经可以说明一些问题，更新一条记录时，执行器会在记录 binlog 前后分别调用一次引擎层，然后引擎层第一次在更新完内存中的数据后往 redo log 里面记录日志，状态是 prepare，第二次才更新为 commit 状态，这也就是所谓的两阶段提交，为什么要这么做呢，这主要是为了保证 binlog 和 redo log 两份日志的逻辑一致性。如果说不采用两阶段提交的方式，直接先记录 binlog 再记录 redo log，或者说先记录 redo log 再记录 binlog，这两种方式会出现什么情况呢。</p>
<p>第一种方式: 先记录 binlog 再记录 redo log<br>假如说更新数据时在写完 binlog 后系统崩溃了，待服务重启后，redo log 里面根本没有记录这条数据的更新，而 binlog 却有这条数据的更新，后期如果说要通过 binlog 备份库或者说要将这个库恢复到某个时间点的时候，由于 binlog 中记录了这个数据的更新，备份或者恢复的库中的数据将是更新后的数据，而原来的库里面却是更新之前的数据，从而就会造成两个库的数据不一致。</p>
<p>第二种方式: 先记录 redo log 再记录 binlog<br>相反先记录 redo log 再记录 binlog，同样的更新数据时在写完 redo log 后系统崩溃了，待服务重启后，由于 redo log 中记录了数据的更新，通过重放 redo log 将刚才要更新的数据进行更新，但此时 binlog 中是没有记录这条数据的更新的，同样的后期通过 binlog 备份库或者说要将这个库恢复到某个时间点的时候，由于 binlog 中没有记录这个数据的更新，备份或者恢复的库中的数据将是更新前的数据，而原来的库里面是更新后的数据，也会造成两个库的数据不一致。</p>
<p>从上面两种方式的处理来看都可能会造成两份日志的逻辑不一致，而采用两阶段提交的方式之后，我们来看系统在不同时间点崩溃，两份日志是怎么保证逻辑一致性的。在上面流程图中我将几个记录日志的操作进行了标号 ①②③，这时崩溃的时机可能有以下四种情况:</p>
<ol>
<li>在 ① 之前服务崩溃，对应的 redo log 和 binlog 都没有记录，此次数据更新失败，后期通过 binlog 备份或恢复出来的数据是更新前的数据</li>
<li>在 ③ 之后服务崩溃，对应的 redo log 和 binlog 都有记录，且 redo log 中日志状态是 commit，此次数据更新成功，后期通过 binlog 备份或恢复出来的数据是更新后的数据</li>
<li>在 ① 和 ② 之间服务崩溃，redo log 中有记录且状态是 prepare，binglog 中没有记录，服务重启之后看到 redo log 中是 prepare 状态，binlog 中没有此次更新日志，事务将会进行回滚，此次数据更新失败，后期通过 binlog 备份或恢复出来的数据是更新前的数据</li>
<li>在 ② 和 ③ 之间服务崩溃，redo log 中有记录且状态是 prepare，binglog 中也有记录，服务重启之后看到 redo log 中是 prepare 状态，binlog 中也有记录，事务将会进行提交，此次数据更新成功，后期通过 binlog 备份或恢复出来的数据是更新后的数据</li>
</ol>
<p>从上面四种情况的分析可以看出，采用两阶段提交之后两份日志保证了逻辑一致性，不存在说后期备份或者恢复出来的数据和原来的数据不一致的情况。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Dubbo 远程调用链路源码分析</title>
    <url>/Dubbo-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="服务端定义和实现"><a href="#服务端定义和实现" class="headerlink" title="服务端定义和实现"></a>服务端定义和实现</h3><p>这里用的是 Dubbo 官方最简单的一个 dubbo 接口请求的例子，服务端接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GreetingsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端接口实现如下：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingsServiceImpl</span> <span class="keyword">implements</span> <span class="title">GreetingsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hi, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端接口暴露"><a href="#服务端接口暴露" class="headerlink" title="服务端接口暴露"></a>服务端接口暴露</h3><p>服务端接口定义好之后，需要将接口注册到注册中心暴露出去，这样消费端就可以通过注册中心获取到服务端的接口定义和请求地址，接口注册到 zookeeper 并启动服务端:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_HOST = System.getProperty(<span class="string">&quot;zookeeper.address&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_PORT = System.getProperty(<span class="string">&quot;zookeeper.port&quot;</span>, <span class="string">&quot;2181&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_ADDRESS = <span class="string">&quot;zookeeper://&quot;</span> + ZOOKEEPER_HOST + <span class="string">&quot;:&quot;</span> + ZOOKEEPER_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置服务端接口</span></span><br><span class="line">        ServiceConfig&lt;GreetingsService&gt; service = <span class="keyword">new</span> ServiceConfig&lt;&gt;();</span><br><span class="line">        service.setInterface(GreetingsService.class);</span><br><span class="line">        service.setRef(<span class="keyword">new</span> GreetingsServiceImpl());</span><br><span class="line">        <span class="comment">// 暴露及注册当前服务</span></span><br><span class="line">        DubboBootstrap.getInstance()</span><br><span class="line">                .application(<span class="string">&quot;first-dubbo-provider&quot;</span>)</span><br><span class="line">                .registry(<span class="keyword">new</span> RegistryConfig(ZOOKEEPER_ADDRESS))</span><br><span class="line">                .protocol(<span class="keyword">new</span> ProtocolConfig(<span class="string">&quot;dubbo&quot;</span>, -<span class="number">1</span>))</span><br><span class="line">                .service(service)</span><br><span class="line">                .start()</span><br><span class="line">                .await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费端发起调用"><a href="#消费端发起调用" class="headerlink" title="消费端发起调用"></a>消费端发起调用</h3><p>服务端将自身接口定义信息注册到 zookeeper，消费端同样需要连接 zookeeper 获取到相关定义信息，然后发起远程请求调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_HOST = System.getProperty(<span class="string">&quot;zookeeper.address&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_PORT = System.getProperty(<span class="string">&quot;zookeeper.port&quot;</span>, <span class="string">&quot;2181&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_ADDRESS = <span class="string">&quot;zookeeper://&quot;</span> + ZOOKEEPER_HOST + <span class="string">&quot;:&quot;</span> + ZOOKEEPER_PORT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 引用远程服务端接口，此实例很重，封装了与注册中心的连接以及与提供者的连接，需自行缓存，否则可能造成内存和连接泄漏</span></span><br><span class="line">        ReferenceConfig&lt;GreetingsService&gt; reference = <span class="keyword">new</span> ReferenceConfig&lt;&gt;();</span><br><span class="line">        reference.setInterface(GreetingsService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接注册中心配置</span></span><br><span class="line">        DubboBootstrap.getInstance()</span><br><span class="line">                .application(<span class="string">&quot;first-dubbo-consumer&quot;</span>)</span><br><span class="line">                .registry(<span class="keyword">new</span> RegistryConfig(ZOOKEEPER_ADDRESS))</span><br><span class="line">                .reference(reference)</span><br><span class="line">                .start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费端创建服务端接口代理对象，让使用者看起来像是调用本地方法一样</span></span><br><span class="line">        <span class="comment">// 该代理对象封装了所有和服务端通讯的细节，对象较重，需缓存复用</span></span><br><span class="line">        GreetingsService service = reference.get();</span><br><span class="line">        String message = service.sayHi(<span class="string">&quot;dubbo&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Receive result ======&gt; &quot;</span> + message);</span><br><span class="line">        System.in.read();</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先启动服务端，然后再启动消费端，正常的话就能在消费端的控制台打印如下信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Receive result ======&gt; hi, dubbo</span><br></pre></td></tr></table></figure>

<p>上面就是一次完整的 RPC 请求，看起来似乎挺简单的，代码量也很少，但 dubbo 框架底层可是为我们做了大量的工作，我们可以尝试跟着消费端的请求链路一直到服务端处理请求，再到消费端接收响应，看看整个链路到底是怎样的。</p>
<h3 id="消费端请求链路源码跟踪"><a href="#消费端请求链路源码跟踪" class="headerlink" title="消费端请求链路源码跟踪"></a>消费端请求链路源码跟踪</h3><p><img src="/images/dubbo_consumer_proxy_obj.png" alt="dubbo_consumer_proxy_obj"></p>
<p>从上面断点处可以看到从 reference 里面获取到服务端对象是个代理对象，代理对象代理的是 InvokerInvocationHandler 属性对象，具体可以跟踪下 <code>reference.get</code> 方法，最后就是到 <code>JavassistProxyFactory</code> 类里面的 <code>getProxy</code> 方法，创建代理对象的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br></pre></td></tr></table></figure>

<p>而 <code>InvokerInvocationHandler</code> 类里面只有一个 <code>invoke</code> 方法，先是做了一些特殊方法的校验，若是直接本地执行后返回，否则组装对应的请求参数，调用 InvocationUtil.invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># InvokerInvocationHandler.invoke</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验是否是一些特殊方法，若是，直接执行</span></span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;$destroy&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            invoker.destroy();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span> &amp;&amp; <span class="string">&quot;equals&quot;</span>.equals(methodName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组装请求调用参数，</span></span><br><span class="line">    RpcInvocation rpcInvocation = <span class="keyword">new</span> RpcInvocation(serviceModel, method.getName(), invoker.getInterface().getName(), protocolServiceKey, method.getParameterTypes(), args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serviceModel <span class="keyword">instanceof</span> ConsumerModel) &#123;</span><br><span class="line">        rpcInvocation.put(Constants.CONSUMER_MODEL, serviceModel);</span><br><span class="line">        rpcInvocation.put(Constants.METHOD_MODEL, ((ConsumerModel) serviceModel).getMethodModel(method));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 InvocationUtil.invoke 方法，底层异步调用返回</span></span><br><span class="line">    <span class="keyword">return</span> InvocationUtil.invoke(invoker, rpcInvocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了 InvocationUtil.invoke 方法里面则是调用 invoker.invoke 方法，而 invoker 从上面可以看到是 MigrationInvoker 对象，也就是调用 MigrationInvoker 对象里面的 invoke 方法，里面主要是做了些校验然后继续调用 <code>MockClusterInvoker.invoke</code> 方法，再是 <code>AbstractCluster$ClusterFilterInvoker.invoke</code>，然后到 <code>FilterChainBuilder.CopyOfFilterChainNode.invoke</code> 方法，在 <code>FilterChainBuilder</code> 里面将会执行一系列的 Filter 链，这个后面单独再讲，这次主要是先跟着源码整体走一遍，等执行完这些 Filter 链后继续走到 <code>FailoverClusterInvoker.doInvoke</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># FailoverClusterInvoker.doInvoke</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">        checkInvokers(copyInvokers, invocation);</span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 计算方法调用失败时重试次数，默认重试 2 次，总共执行 3 次</span></span><br><span class="line">        <span class="keyword">int</span> len = calculateInvokeTimes(methodName);</span><br><span class="line">        <span class="comment">// retry loop.</span></span><br><span class="line">        RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">        Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">        <span class="comment">// 在这里进行循环调用</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class="line">            <span class="comment">//<span class="doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                checkWhetherDestroyed();</span><br><span class="line">                copyInvokers = list(invocation);</span><br><span class="line">                <span class="comment">// check again</span></span><br><span class="line">                checkInvokers(copyInvokers, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">            invoked.add(invoker);</span><br><span class="line">            RpcContext.getServiceContext().setInvokers((List) invoked);</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 带上 Context 调用 DubboInvoker.invoke 方法</span></span><br><span class="line">                Result result = invokeWithContext(invoker, invocation);</span><br><span class="line">                <span class="comment">// 请求成功，立即退出循环返回，否则继续循环调用</span></span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                    providers.add(invoker.getUrl().getAddress());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RpcException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看到 Dubbo 里面的重试逻辑，通过获取方法上配置的重试次数进行相应的 for 循环调用，成功立即退出循环返回，for 循环里面调用的是 <code>DubboInvoker.invoke</code> 方法：DubboInvoker 继承了 AbstractInvoker 类，调用的是 AbstractInvoker 的 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#  AbstractInvoker.invoke</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// if invoker is destroyed due to address refresh from registry, let&#x27;s allow the current invoke to proceed</span></span><br><span class="line">    <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">        logger.warn(PROTOCOL_FAILED_REQUEST, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Invoker for service &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; is destroyed, &quot;</span> + <span class="string">&quot;, dubbo version is &quot;</span> + Version.getVersion() + <span class="string">&quot;, this invoker should not be used any longer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备远程调用的一些参数</span></span><br><span class="line">    prepareInvocation(invocation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始异步执行远程调用，返回得到异步的结果</span></span><br><span class="line">    AsyncRpcResult asyncResult = doInvokeAndReturn(invocation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里要注意，针对上一步的返回结果，判断是哪种调用方式，决定是否需要阻塞等待执行结果</span></span><br><span class="line">    waitForResultIfSync(asyncResult, invocation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> asyncResult;</span><br><span class="line">&#125;</span><br><span class="line"># DubboInvoker.doInvoke</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">    <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">    inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">    ExchangeClient currentClient;</span><br><span class="line">    <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">        currentClient = clients[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本次调用的超时时间</span></span><br><span class="line">        <span class="keyword">int</span> timeout = RpcUtils.calculateTimeout(getUrl(), invocation, methodName, DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 发起调用前就已经超时了，直接返回超时调用终止异常</span></span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">new</span> RpcException(RpcException.TIMEOUT_TERMINATE,</span><br><span class="line">                <span class="string">&quot;No time left for making the following call: &quot;</span> + invocation.getServiceName() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + invocation.getMethodName() + <span class="string">&quot;, terminate directly.&quot;</span>), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        invocation.setAttachment(TIMEOUT_KEY, String.valueOf(timeout));</span><br><span class="line"></span><br><span class="line">        Integer payload = getUrl().getParameter(PAYLOAD, Integer.class);</span><br><span class="line">        <span class="comment">// 组装请求传输参数</span></span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        <span class="keyword">if</span> (payload != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setPayload(payload);</span><br><span class="line">        &#125;</span><br><span class="line">        request.setData(inv);</span><br><span class="line">        request.setVersion(Version.getProtocolVersion());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">            <span class="comment">// 单向请求，也就是不关心请求结果的调用，发出请求后立即返回</span></span><br><span class="line">            <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">            request.setTwoWay(<span class="keyword">false</span>);</span><br><span class="line">            currentClient.send(request, isSent);</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 双向请求，关心请求结果的调用，发出请求后需接收响应结果</span></span><br><span class="line">            request.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">// 构建一个回调 ExecutorService 来处理响应结果</span></span><br><span class="line">            ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line">            <span class="comment">// 请求 ReferenceCountExchangeClient.request-&gt; ReferenceCountExchangeClient.request</span></span><br><span class="line">            <span class="comment">// -&gt; HeaderExchangeClient.request -&gt; HeaderExchangeChannel.request</span></span><br><span class="line">            <span class="comment">// 注意这里返回的是 CompletableFuture 对象，用的是 concurrent 包下面的一个对象</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                currentClient.request(request, timeout, executor).thenApply(AppResponse.class::cast);</span><br><span class="line">            <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">            FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line">            AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line">            result.setExecutor(executor);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># DubboInvoker.getCallbackExecutor</span><br><span class="line"><span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">getCallbackExecutor</span><span class="params">(URL url, Invocation inv)</span> </span>&#123;</span><br><span class="line">    ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension().getExecutor(url);</span><br><span class="line">    <span class="keyword">if</span> (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)) &#123;</span><br><span class="line">          <span class="comment">// 如果是同步调用每次创建 ThreadlessExecutor 返回，后面通过这个线程池来处理响应结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadlessExecutor(sharedExecutor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sharedExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做的逻辑就更多一些了，上面我列了一些，可能很多没有跟进去执行，比如上面计算超时时间，构建回调 ExecutorService 里面的逻辑都比较多，这里先把主流程熟悉，最后调用 currentClient.request 方法，请求的是 <code>ReferenceCountExchangeClient.request-&gt; ReferenceCountExchangeClient.request -&gt; HeaderExchangeClient.request -&gt; HeaderExchangeChannel.request</code>，最后到 <code>HeaderExchangeChannel.request</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># HeaderExchangeChannel.request</span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">&quot;Failed to send request &quot;</span> + request + <span class="string">&quot;, cause: The channel &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; is closed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Request req;</span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        req = (Request) request;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// create request.</span></span><br><span class="line">        req = <span class="keyword">new</span> Request();</span><br><span class="line">        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">        req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">        req.setData(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 DefaultFuture 对象，设置响应结果处理线程池，同时配置响应超时检测</span></span><br><span class="line">    DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout, executor);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 底层通过集成 netty 和服务端进行通讯，将消费端要请求服务端的方法以及参数传递到服务端</span></span><br><span class="line">        <span class="comment">// 这里可以看出来消费端是异步请求服务端的，将请求消息发出去之后立马就返回了，只不过返回的是 CompletableFuture 对象</span></span><br><span class="line">        channel.send(req);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        future.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 DefaultFuture 对象也会做一些关联处理，以便收到服务端响应的时候能找到对应的请求进行匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># DefaultFuture</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">newFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, request, timeout);</span><br><span class="line">    <span class="comment">// future 保存当前回调处理的线程池</span></span><br><span class="line">    future.setExecutor(executor);</span><br><span class="line">    <span class="comment">// 如果是 ThredlessExecutor 类型，也就是同步调用时，将 future 关联上当前线程池</span></span><br><span class="line">    <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ((ThreadlessExecutor) executor).setWaitingFuture(future);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行超时检测</span></span><br><span class="line">    timeoutCheck(future);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">    <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">    <span class="comment">// 放入等待响应的 Future Map 集合，响应回来的时候通过这个可以设置请求结果</span></span><br><span class="line">    FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// 放入等待响应 Channel 集合，优雅关闭的时候通过这个 Map 来判断是否还有等待响应的请求</span></span><br><span class="line">    CHANNELS.put(id, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的流程可以看到消费端在把请求发送给服务端后立马就返回了，返回的是一个 Future，Future 里面包含了当前回调处理的线程池以及超时检测任务，而并没有一直在等服务端的执行结果，这个过程是异步执行的，然后在下一步 waitForResultIfSync 里面来决定什么时候取服务端返回的结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#  AbstractInvoker.invoke</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForResultIfSync</span><span class="params">(AsyncRpcResult asyncResult, RpcInvocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (InvokeMode.SYNC != invocation.getInvokeMode()) &#123;</span><br><span class="line">          <span class="comment">// 如果不是同步调用，直接返回，不需要等待结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * NOTICE!</span></span><br><span class="line"><span class="comment">         * must call &#123;@link java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">         * &#123;@link java.util.concurrent.CompletableFuture#get()&#125; was proved to have serious performance drop.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object timeout = invocation.getObjectAttachmentWithoutConvert(TIMEOUT_KEY);</span><br><span class="line">        <span class="keyword">if</span> (timeout <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">              <span class="comment">// 配置了超时时间，阻塞一定时间等待结果，超时则抛出异常，在下面进行捕获对应异常抛出</span></span><br><span class="line">            asyncResult.get((Integer) timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有配置超时时间，无限等待阻塞等待结果，一般不会无限等待，有默认的超时时间</span></span><br><span class="line">            asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># AsyncRpcResult.get</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">      <span class="comment">// 获取刚才设置的回调处理线程池，同步调用则是调用 threadlessExecutor 里面的 waitAndDrain 来阻塞等待结果</span></span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">        threadlessExecutor.waitAndDrain();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 否则直接通过 CompletableFuture 里面的 get 方法阻塞等结果</span></span><br><span class="line">    <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是同步调用则直接返回，不需要阻塞等待执行结果，同样直接返回给业务代码一个 Future，业务代码拿到 Future 后自行决定在什么地方拿执行结果，或者也可以直接绑定回调；如果是同步调用的话根据超时时间配置来阻塞等待一定时间等待响应结果，具体阻塞方式根据调用方式的不同阻塞的方式也不同，同步调用采用的是 ThreadlessExecutor 线程池来阻塞，否则是 CompletableFuture 里面的 get 方法阻塞等结果。这里可能得先熟悉下 ThreadlessExecutor 这个类：</p>
<p>1.正常线程池的作用是管理池中的线程和调度线程执行，而 ThreadlessExecutor 线程池则并不管理任何线程</p>
<p>2.通过 execute 方法提交给这个执行器的任务并不会被安排线程执行，而正常的线程池是会进行执行调度的，对于 ThreadlessExecutor 线程池来说提交的任务直接存储在阻塞队列中，只有调用 waitAndDrain 方法时才会真正执行，而且执行任务的线程正是调用 waitAndDrain 方法的线程</p>
<p>通过查看 ThreadlessExecutor 类中的 waitAndDrain 和 execute 方法就能知道该类是如何实现上面的特性了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"><span class="comment">// 通常，#waitAndDrain 方法只会被调用一次。它第一次阻止响应，一旦响应结果到达，正在执行 waitAndDrain 等待的线程将会立即返回，然后整个请求过程然后完成。</span></span><br><span class="line"><span class="comment">// 对 #waitAndDrain 方法的后续调用（如果有的话）都会立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitAndDrain</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFinished()) &#123;</span><br><span class="line">          <span class="comment">// 如果任务状态已经完成，直接返回不做任何处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runnable runnable;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 从阻塞队列里面取要执行的任务，如果队列为空则阻塞等待，主要通过 LinkedBlockingQueue 里面的 ReentrantLock 来实现阻塞</span></span><br><span class="line">          <span class="comment">// 等待直到有任务，则继续往下执行任务和所有排队的任务（如果有的话）</span></span><br><span class="line">        runnable = queue.take();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        setWaiting(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 获取对象锁，设置状态，开始执行任务，注意这里并没有再开线程执行，而是直接由调用 waitAndDrain 方法的线程来执行</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        setWaiting(<span class="keyword">false</span>);</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 如果队列里面还有任务则继续执行</span></span><br><span class="line">    runnable = queue.poll();</span><br><span class="line">    <span class="keyword">while</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        runnable.run();</span><br><span class="line">        runnable = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务状态设置已完成</span></span><br><span class="line">    setFinished(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    runnable = <span class="keyword">new</span> RunnableWrapper(runnable);</span><br><span class="line">      <span class="comment">// 获取对象锁，判断调用线程是否还在等待回调任务，如果是则将该任务加入阻塞队列，然后上面 waitAndDrain 方法里面的阻塞结束，拿到任务后往下执行</span></span><br><span class="line">      <span class="comment">// 否则，直接在当前线程中执行完成，这也间接说明了当 waitAndDrain 被调用结束，已经将 waiting 状态设置为 true 后，就不会再往队列里面添加任务</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isWaiting()) &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上也就能看出，如果是同步调用的话，消费端在将请求信息发送给服务端后，通过调用 ThreadlessExecutor 类里面的  waitAndDrain 进行阻塞等待服务端的响应结果。那么后续消费端在接收到服务端的响应结果后必然会调用 execute 方法来唤醒阻塞等待结果的地方继续往下执行。</p>
<p>到这里消费端的请求流程就算是结束了，然后就是服务端收到请求执行相应方法然后响应返回给消费端，消费端这里拿到结果之后继续往下走，返回给业务代码相应的执行结果，下面看看服务端收到消费端的请求后的流程。</p>
<h3 id="服务端处理请求链路源码跟踪"><a href="#服务端处理请求链路源码跟踪" class="headerlink" title="服务端处理请求链路源码跟踪"></a>服务端处理请求链路源码跟踪</h3><p>首先，Dubbo 底层集成的改造后 Netty 通讯框架，端点收到消息后将数据解析出来，通过 <code>AllChannelHandler.received</code> 方法来处理，首先获取一个线程池，这里要注意的是如果作为服务端收到的是请求消息，则是获取共享线程池中的线程来进行处理，如果是作为消费端收到的是响应消息，那就是获取在请求时创建的回调处理线程池。</p>
<p>拿到线程池后将消息封装成 ChannelEventRunnable 任务提交到线程池中执行，在 <code>ChannelEventRunnable</code> 线程中处理各种连接和断开连接以及请求响应的消息，再通过 Handler 来根据不同消息做不同的逻辑处理，这里对应的是 HeaderExchangeHandler 处理器，服务端收到的是请求消息，对应的也就是请求消息处理逻辑，后面消费端接收响应的代码逻辑也是在这里，只不过对应的是响应消息，走的是响应消息的处理分支。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># AllChannelHandler.received</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程池处理消息，如果是请求消息则从共享线程池中获取，但如果是响应消息的话这里返回的就是在请求时创建的回调处理线程池</span></span><br><span class="line">    ExecutorService executor = getPreferredExecutorService(message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 将消息封装成 ChannelEventRunnable 任务提交到线程池</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span>(message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException)&#123;</span><br><span class="line">            sendFeedback(channel, (Request) message, t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">&quot; error when process received event .&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># ChannelEventRunnable.received</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        <span class="comment">// 作为服务端接收到请求消息，执行请求消息处理逻辑</span></span><br><span class="line">        Request request = (Request) message;</span><br><span class="line">        <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">            <span class="comment">// 事件处理</span></span><br><span class="line">            handlerEvent(channel, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                  <span class="comment">// 双向请求，需要返回结果,调用 DubboProtocol.reply 方法得到一个异步结果，绑定回调，结果出来后立马将结果发送给消费端</span></span><br><span class="line">                  <span class="comment">// reply 方法里面紧接着调用 FilterChainBuilder.CallbackRegistrationInvoker.invoke 方法，</span></span><br><span class="line">                  <span class="comment">// 在里面根据请求的方法和参数异步执行真正的方法，同时绑定一系列 Filter 过滤器回调，异步结果出来后立马执行</span></span><br><span class="line">                handleRequest(exchangeChannel, request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 单向请求，不需要返回结果</span></span><br><span class="line">                handler.received(exchangeChannel, request.getData());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">          <span class="comment">// 作为消费端收到服务端的调用响应，执行响应消息处理逻辑</span></span><br><span class="line">        handleResponse(channel, (Response) message);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isClientSide(channel)) &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> Exception(<span class="string">&quot;Dubbo client can not supported string message: &quot;</span> + message + <span class="string">&quot; in channel: &quot;</span> + channel + <span class="string">&quot;, url: &quot;</span> + channel.getUrl());</span><br><span class="line">            logger.error(TRANSPORT_UNSUPPORTED_MESSAGE, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String echo = handler.telnet(channel, (String) message);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(echo)) &#123;</span><br><span class="line">                channel.send(echo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.received(exchangeChannel, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们先看作为服务端收到请求消息的处理链路:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ChannelEventRunnable.handleRequest</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 构建响应消息</span></span><br><span class="line">    Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">    <span class="comment">// find handler by message class.</span></span><br><span class="line">    Object msg = req.getData();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 DubboProtocol 里面 reply 方法得到异步 Future</span></span><br><span class="line">        CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line">        <span class="comment">// 绑定异步完成回调，将执行结果发送给消费端</span></span><br><span class="line">        future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.setStatus(Response.OK);</span><br><span class="line">                    res.setResult(appResult);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送响应结果给消费端</span></span><br><span class="line">                channel.send(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                logger.warn(TRANSPORT_FAILED_RESPONSE, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Send result to consumer failed, channel is &quot;</span> + channel + <span class="string">&quot;, msg is &quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">        res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">        channel.send(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看到服务端在收到消费的请求消息后，调用相应 DubboProtocol 的 reply 方法得到异步 Future，然后在 Future 上绑定一个执行完成的回调，执行完成后将结果发送给消费端，说明服务端也是异步去执行消费端的请求方法逻辑，等到执行完成后异步返回给消费端。而在 <code>DubboProtocol.reply</code> 方法里面调用的是<code>FilterChainBuilder.CallbackRegistrationInvoker.invoke</code> 方法，紧接着请求 <code>FilterChainBuilder.CopyOfFilterChainNode.invoke</code> 方法，在里面执行一系列的Filter 链，然后通过反射执行最终要执行的方法，当然执行结果也是异步返回的，返回的是一个异步 Future，然后同样在 Future 上绑定一系列的回调过滤器。</p>
<h3 id="消费端接收响应链路源码跟踪"><a href="#消费端接收响应链路源码跟踪" class="headerlink" title="消费端接收响应链路源码跟踪"></a>消费端接收响应链路源码跟踪</h3><p>如刚才所说 Dubbo 底层集成的是改造后 Netty 通讯框架，同样消费端收到响应消息后将数据解析出来，然后通过 <code>AllChannelHandler.received</code> 方法来处理，获取线程池时由于是作为消费端接收的是响应消息，那么这里拿到的线程池就是发起请求时创建的回调处理线程池，而且如果是同步调用的话返回的就是 ThreadlessExecutor，然后调用 ThreadlessExecutor 的 execute 方法将消息封装成 ChannelEventRunnable 任务加入到阻塞队列，然后刚才请求时阻塞地方被唤醒，拿到提交 ChannelEventRunnable 任务开始往下执行，在 ChannelEventRunnable 里面判断是响应消息，执行响应消息处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># AllChannelHandler.getPreferredExecutorService</span><br><span class="line"><span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getPreferredExecutorService</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">          <span class="comment">// 收到的是响应消息</span></span><br><span class="line">        Response response = (Response) msg;</span><br><span class="line">        DefaultFuture responseFuture = DefaultFuture.getFuture(response.getId());</span><br><span class="line">        <span class="comment">// 根据响应消息id获取对应请求时在 DefaultFuture 里面通过 Map 关联的 future，</span></span><br><span class="line">        <span class="comment">// 当然这里可能由于超时等原因 future 已经被移除了，然后通过共享线程池来处理</span></span><br><span class="line">        <span class="keyword">if</span> (responseFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 通过 future 获取请求时设置的回调线程池，如果是同步调用的话返回的是 ThreadlessExecutor，</span></span><br><span class="line">              <span class="comment">// 然后将消息封装成 ChannelEventRunnable 任务提交给它去执行设置返回结果，之前阻塞的地方阻塞结束，拿到执行结果后继续往下执行</span></span><br><span class="line">            ExecutorService executor = responseFuture.getExecutor();</span><br><span class="line">            <span class="keyword">if</span> (executor == <span class="keyword">null</span> || executor.isShutdown()) &#123;</span><br><span class="line">                executor = getSharedExecutorService(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> executor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSharedExecutorService(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># HeaderExchangeHandler.handleResponse</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">        DefaultFuture.received(channel, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># DefaultFuture.received</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">    received(channel, response, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># DefaultFuture.received</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response, <span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 通过请求响应id映射请求时的 future</span></span><br><span class="line">        DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Timeout t = future.timeoutCheckTask;</span><br><span class="line">            <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                <span class="comment">// 如果收到响应结果后还没有超时，将超时检测任务取消</span></span><br><span class="line">                t.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            future.doReceived(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 没有匹配到说明服务端执行可能已经超时了，消费端已经返回，不再处理超时的响应结果</span></span><br><span class="line">            logger.warn(PROTOCOL_TIMEOUT_SERVER, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The timeout response finally returned at &quot;</span></span><br><span class="line">                + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                + <span class="string">&quot;, response status is &quot;</span> + response.getStatus()</span><br><span class="line">                + (channel == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, channel: &quot;</span> + channel.getLocalAddress()</span><br><span class="line">                + <span class="string">&quot; -&gt; &quot;</span> + channel.getRemoteAddress()) + <span class="string">&quot;, please check provider side for detailed result.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        CHANNELS.remove(response.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># DefaultFuture.doReceived</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;response cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">          <span class="comment">// 响应成功，将 future 状态设置已完成并设置结果</span></span><br><span class="line">        <span class="keyword">this</span>.complete(res.getResult());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> RemotingException(channel, res.getErrorMessage()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果回调处理线程池是 ThreadlessExecutor，可能由于某种原因 ThreadlessExecutor 还在等待结果，需要通知该线程池结果已经返回</span></span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">        <span class="keyword">if</span> (threadlessExecutor.isWaiting()) &#123;</span><br><span class="line">            threadlessExecutor.notifyReturn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The result has returned, but the biz thread is still waiting&quot;</span> +</span><br><span class="line">                <span class="string">&quot; which is not an expected state, interrupt the thread manually by returning an exception.&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在处理响应之前需先找到当前响应是对应哪个请求，通过请求和响应 id 进行匹配，将当时保存在 Map 中的映射关系移出，如果没有匹配上，说明服务端响应超时，则不在处理该响应结果，打印出告警日志，如果能匹配上说明还没有超时，继续往下执行，判断超时检测任务是否还存在，如果在则将超时检测任务取消， 获取到请求时的 future 将状态设置为已完成并设置响应结果，这样刚才阻塞那里的第二步就能够获取到执行结果了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># AsyncRpcResult.get</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">      <span class="comment">// 获取刚才设置的回调处理线程池，同步调用则是调用 threadlessExecutor 里面的 waitAndDrain 来阻塞等待结果</span></span><br><span class="line">    <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">          <span class="comment">// 阻塞等待响应任务入队列</span></span><br><span class="line">        threadlessExecutor.waitAndDrain();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 通过 CompletableFuture 里面的 get 获取响应结果</span></span><br><span class="line">    <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里从消费端发起请求，服务端接收请求，处理请求并返回执行结果给消费端，再到消费端收到响应结果整个链路的分析就结束了，里面还是涉及到比较多的东西的，当然这里只是把 Dubbo 请求的整体主链路走通了，还有很多一些细节的地方没有深入的分析，比如说 Dubbo 的负载均衡，过滤器链，异步调用流程处理，线程池模型等等，这些等后续再针对具体的功能来进行分析研究了，下面再列一下 Dubbo 里面整体主链路涉及的一些类和方法：</p>
<p>consumer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request:</span><br><span class="line">InvokerInvocationHandler.invoke-&gt;RpcInvocation-&gt;InvocationUtil.invoke-&gt;MigrationInvoker.invoke-&gt;MockClusterInvoker.invoke-&gt;AbstractCluster$ClusterFilterInvoker.invoke-&gt;FilterChainBuilder.CopyOfFilterChainNode.invoke(执行一系列的Filter链)-&gt;FailoverClusterInvoker.doInvoke-&gt;DubboInvoker.doInvoke-&gt;ReferenceCountExchangeClient.request-&gt;HeaderExchangeClient.request-&gt;AsyncRpcResult.get</span><br><span class="line"></span><br><span class="line">response:</span><br><span class="line">AllChannelHandler.received-&gt;AllChannelHandler.getPreferredExecutorService-&gt;ChannelEventRunnable.run-&gt;HeaderExchangeHandler.received-&gt;HeaderExchangeHandler.handleResponse-&gt;DefaultFuture.received-&gt;DefaultFuture.doReceived</span><br></pre></td></tr></table></figure>

<p>provider:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AllChannelHandler.received-&gt;AllChannelHandler.getPreferredExecutorService-&gt;ChannelEventRunnable.run-&gt;HeaderExchangeHandler.received-&gt;HeaderExchangeHandler.handleRequest-&gt;DubboProtocol.reply-&gt;FilterChainBuilder.CallbackRegistrationInvoker.invoke-&gt;FilterChainBuilder.CopyOfFilterChainNode.invoke(执行一系列的Filter链)-&gt;绑定一系列回调过滤器-&gt;future.whenComplete</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
  </entry>
</search>
